"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["2393"],{9160:function(n,e,s){s.r(e),s.d(e,{default:()=>i});var r=s(2676),a=s(453);function t(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",strong:"strong",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",h3:"h3",img:"img"},(0,a.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"httprunner2小时入门版",children:["HttpRunner—2小时入门版",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#httprunner2小时入门版",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"一简介",children:["一、简介",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一简介",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["接口测试很多同学用 ",(0,r.jsx)(e.code,{children:"Postman"}),"、",(0,r.jsx)(e.code,{children:"Jmeter"})," 来做，用起来也挺简单的，但是接口用例多了之后就发现不好管理维护，要落地到公司级 CI 项目就有点难搞了；"]}),"\n",(0,r.jsxs)(e.p,{children:["稍微有点技术能力的同学更愿意直接用 ",(0,r.jsx)(e.code,{children:"requests"})," 来做接口自动化，但是大多用 ",(0,r.jsx)(e.code,{children:"requests"})," 来做的接口自动化项目，在工程化方面都做得不太好，与其说是接口自动化项目，不如说是接口脚本的集中存放，没有体系化的框架结构设计，因此在大型 CI 项目中落地也显得不太够用，维护人员除了忙于接口脚本的维护，还要投入大量时间做新功能和修复代码中的 Bug。"]}),"\n",(0,r.jsxs)(e.p,{children:["想要轻松快速的落地接口自动化，又不想自己去折腾，我个人还是推荐 ",(0,r.jsx)(e.code,{children:"HttpRunner"}),"，只需要写写配置文件就把活干完了；"]}),"\n",(0,r.jsxs)(e.h2,{id:"二安装",children:["二、安装",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#二安装",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["系统环境：",(0,r.jsx)(e.code,{children:"deepin"})," / ",(0,r.jsx)(e.code,{children:"UOS"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-console",children:'sudo bash -c "$(curl -ksSL https://httprunner.com/script/install.sh)"\n'})}),"\n",(0,r.jsxs)(e.p,{children:["注意，使用 ",(0,r.jsx)(e.code,{children:"sudo"})," 安装，不然命令行工具无法写入系统环境变量。"]}),"\n",(0,r.jsx)(e.p,{children:"装完之后会有一些版本、命令行参数的输出，说明安装成功。"}),"\n",(0,r.jsxs)(e.h2,{id:"三创建项目",children:["三、创建项目",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#三创建项目",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"hrp startproject funny-api-autotest\n"})}),"\n",(0,r.jsxs)(e.p,{children:["这里会使用 ",(0,r.jsx)(e.code,{children:"venv"})," 创建一个虚拟，有可能报错需要安装 ",(0,r.jsx)(e.code,{children:"python3-venv"}),"；"]}),"\n",(0,r.jsx)(e.p,{children:"不要慌，我们来修复一下环境："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"# 安装依赖\nsudo apt install python3-pip\n# 安装venv\nsudo apt install python3-venv\n# 把之前创建失败的虚拟环境删掉\ncd ~/.hrp/\nrm -rf venv\n# 重新创建一个\npython3 -m venv venv\n# 激活虚拟环境\nsource ~/.hrp/venv/bin/activate\n# 把pip更新一下\npip install --upgrade pip setuptools wheel\n# 安装依赖funppy\npip install funppy\n"})}),"\n",(0,r.jsx)(e.p,{children:"如果不出意外，环境就安装好了；"}),"\n",(0,r.jsxs)(e.h2,{id:"四目录结构",children:["四、目录结构",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#四目录结构",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:".\n├── debugtalk.py # 定义一些函数并返回一些值，函数名和参数可以传入到yml文件参数里面；\n├── .env # 定义全局的环境变量\n├── .gitignore\n├── har # 导出的har文件\n├── proj.json # 工程信息\n├── README.md\n├── results # 测试报告\n└── testcases # 测试用例\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"testcases"})})}),"\n",(0,r.jsxs)(e.p,{children:["这里面用例是 ",(0,r.jsx)(e.code,{children:"yaml"})," 或 ",(0,r.jsx)(e.code,{children:"json"})," 文件，用 ",(0,r.jsx)(e.code,{children:"yaml "})," 文件写接口自动化的用例也是常规操作，因为接口几乎都是以字典（或 ",(0,r.jsx)(e.code,{children:"json"}),"）的形式提供参数，而 ",(0,r.jsx)(e.code,{children:"yaml"})," 文件读出来刚好就是，所以大家就喜欢用这种格式。"]}),"\n",(0,r.jsxs)(e.p,{children:["前面我说这个框架简单就是因为把接口的信息就直接在 ",(0,r.jsx)(e.code,{children:"yaml"})," 文件里面一配置，活就干完了，根本都不需要写代码；"]}),"\n",(0,r.jsxs)(e.p,{children:["对新手来说简直了，下面介绍一下 ",(0,r.jsx)(e.code,{children:"yaml"})," 文件的字段："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'config:\n    name: "request methods testcase with functions"\n    variables:\n        foo1: config_bar1\n        foo2: config_bar2\n        expect_foo1: config_bar1\n        expect_foo2: config_bar2\n    base_url: "https://postman-echo.com"\n    verify: False\n    export: ["foo3"]\n\nteststeps:\n-\n    name: get with params\n    variables:\n        foo1: bar11\n        foo2: bar21\n        sum_v: "${sum_two(1, 2)}"\n    request:\n        method: GET\n        url: /get\n        params:\n            foo1: $foo1\n            foo2: $foo2\n            sum_v: $sum_v\n        headers:\n            User-Agent: HttpRunner/${get_httprunner_version()}\n    extract:\n        foo3: "body.args.foo2"\n    validate:\n        - eq: ["status_code", 200]\n        - eq: ["body.args.foo1", "bar11"]\n        - eq: ["body.args.sum_v", "3"]\n        - eq: ["body.args.foo2", "bar21"]\n-\n    name: post form data\n    variables:\n        foo2: bar23\n    request:\n        method: POST\n        url: /post\n        headers:\n            User-Agent: HttpRunner/${get_httprunner_version()}\n            Content-Type: "application/x-www-form-urlencoded"\n        data: "foo1=$foo1&foo2=$foo2&foo3=$foo3"\n    validate:\n        - eq: ["status_code", 200]\n        - eq: ["body.form.foo1", "$expect_foo1"]\n        - eq: ["body.form.foo2", "bar23"]\n        - eq: ["body.form.foo3", "bar21"]\n'})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"config：测试用例的公共配置部分，包括用例名称、base_url、参数化数据源、是否开启 SSL 校验等，举例："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'config:\n  name: "demo with complex mechanisms"\n  verify: False\n  base_url: "https://postman-echo.com"\n  headers:\n    X-Request-Timestamp: "165460624942"\n  parameters:\n    user_agent: [ "iOS/10.1", "iOS/10.2" ]\n    username-password: ${parameterize($file)}\n  parameters_setting:\n    strategies:\n      user_agent:\n        name: "user-identity"\n        pick_order: "sequential"\n      username-password:\n        name: "user-info"\n        pick_order: "random"\n    limit: 6\n  think_time:\n    strategy: random_percentage\n    setting:\n      max_percentage: 1.5\n      min_percentage: 1\n    limit: 4\n  variables:\n    app_version: v1\n    user_agent: iOS/10.3\n    file: examples/hrp/account.csv\n  websocket:\n    reconnection_times: 5\n    reconnection_interval: 2000\n  export: ["app_version"]\n  weight: 10\n'})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"teststeps：有序步骤的集合；"}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"测试步骤类型"}),"\n",(0,r.jsx)(e.th,{children:"含义"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"request"}),"\n",(0,r.jsx)(e.td,{children:"用于发起 HTTP 请求的步骤类型"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"api"}),"\n",(0,r.jsx)(e.td,{children:"用于引用 API 的步骤类型"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"testcase"}),"\n",(0,r.jsx)(e.td,{children:"用于引用其他测试用例的步骤类型"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"transaction"}),"\n",(0,r.jsx)(e.td,{children:"用于定义一个事务"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"rendezvous"}),"\n",(0,r.jsx)(e.td,{children:"集合点"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"think_time"}),"\n",(0,r.jsx)(e.td,{children:"思考时间"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"websocket"}),"\n",(0,r.jsx)(e.td,{children:"用于发起 WebSocket 请求的步骤类型"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"除了基本的测试步骤之外，部分测试步骤还可以进行增强；"}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"增强操作类型"}),"\n",(0,r.jsx)(e.th,{children:"含义"}),"\n",(0,r.jsx)(e.th,{children:"适用的测试步骤"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"variables"}),"\n",(0,r.jsx)(e.td,{children:"局部变量"}),"\n",(0,r.jsx)(e.td,{children:"通用"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"setup_hooks"}),"\n",(0,r.jsx)(e.td,{children:"前置函数"}),"\n",(0,r.jsx)(e.td,{children:"request/api/websocket"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"teardown_hooks"}),"\n",(0,r.jsx)(e.td,{children:"后置函数"}),"\n",(0,r.jsx)(e.td,{children:"request/api/websocket"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"extract"}),"\n",(0,r.jsx)(e.td,{children:"参数提取"}),"\n",(0,r.jsx)(e.td,{children:"request/api/websocket"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"validate"}),"\n",(0,r.jsx)(e.td,{children:"结果校验"}),"\n",(0,r.jsx)(e.td,{children:"request/api/websocket"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"export"}),"\n",(0,r.jsx)(e.td,{children:"导出变量"}),"\n",(0,r.jsx)(e.td,{children:"testcase"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"举例："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'teststeps:\n  -\n    name: get with params\n    variables:\n      foo1: ${ENV(USERNAME)}\n      foo2: bar21\n      sum_v: "${sum_two_int(1, 2)}"\n    request:\n      method: GET\n      url: $base_url/get\n      params:\n        foo1: $foo1\n        foo2: $foo2\n        sum_v: $sum_v\n    extract:\n      foo3: "body.args.foo2"\n    validate:\n      - eq: ["status_code", 200]\n      - eq: ["body.args.foo1", "debugtalk"]\n      - eq: ["body.args.sum_v", "3"]\n      - eq: ["body.args.foo2", "bar21"]\n  -\n    name: post form data\n    variables:\n      foo2: bar23\n    request:\n      method: POST\n      url: $base_url/post\n      headers:\n        Content-Type: "application/x-www-form-urlencoded"\n      body: "foo1=$foo1&foo2=$foo2&foo3=$foo3"\n    validate:\n      - eq: ["status_code", 200]\n      - eq: ["body.form.foo1", "$expect_foo1"]\n      - eq: ["body.form.foo2", "bar23"]\n      - eq: ["body.form.foo3", "bar21"]\n'})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"特殊值的规则："})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["变量引用：约定通过 ",(0,r.jsx)(e.code,{children:"${}"})," 或 ",(0,r.jsx)(e.code,{children:"$"})," 的形式来引用变量，例如 ",(0,r.jsx)(e.code,{children:"$foo1"})," 或 ",(0,r.jsx)(e.code,{children:"${foo1}"})]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["函数调用：约定通过 ",(0,r.jsx)(e.code,{children:"${}"})," 的形式来调用插件函数，例如 ",(0,r.jsx)(e.code,{children:"${sum_two(1, 2)}"})," ；"]}),"\n",(0,r.jsxs)(e.p,{children:["有同学要问了，yaml 文件里面写 ",(0,r.jsx)(e.code,{children:"${sum_two(1, 2)}"}),"，从哪里来的；"]}),"\n",(0,r.jsxs)(e.p,{children:["其实，",(0,r.jsx)(e.code,{children:"sum_two"})," 在",(0,r.jsx)(e.code,{children:"debugtalk.py"})," 里面定义;"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# debugtalk.py\n\nimport funppy\n\ndef sum_two_int(a: int, b: int) -> int:\n    return a + b\n\nif __name__ == '__main__':\n    funppy.register(\"sum_two\", sum_two_int)\n    funppy.serve()\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"五执行用例",children:["五、执行用例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#五执行用例",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"hrp run testcases/demo_requests.yml --gen-html-report\n"})}),"\n",(0,r.jsxs)(e.p,{children:["执行完成之后，在 ",(0,r.jsx)(e.code,{children:"result"})," 目录下生成 ",(0,r.jsx)(e.code,{children:"html"})," 测试报告。"]}),"\n",(0,r.jsxs)(e.h2,{id:"六实例",children:["六、实例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#六实例",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"1mock接口",children:["1、mock接口",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1mock接口",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["咱们先使用 ",(0,r.jsx)(e.code,{children:"FastAPI"})," 简单 ",(0,r.jsx)(e.code,{children:"Mock"})," 一个接口："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# mock.py\nimport os\n\nimport uvicorn\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get("/items/")\nasync def read_item(name: str = ""):\n    return {"name": name}\n\n\nif __name__ == \'__main__\':\n    uvicorn.run(\n        app="mock:app",\n        host=os.popen("hostname -I").read().split(" ")[0], # 自动获取本机IP\n        port=5000,\n        reload=True\n    )\n\n'})}),"\n",(0,r.jsx)(e.p,{children:"看看接口文档，非常简单的一个接口"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/httprunner/1.png",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"好，那咱们回到httprunner里面来写用例了；"}),"\n",(0,r.jsxs)(e.h3,{id:"2写接口用例",children:["2、写接口用例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2写接口用例",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"用例也非常简单："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-yaml",children:'# testcases/demo_1.yml\n\nconfig:\n    name: "demo_1"\n    variables:\n        name: mikigo\n    verify: False\n\nteststeps:\n-\n    name: get with params\n    request:\n        method: GET\n        url: http://10.8.7.199:5000/items/  # ip写你的机器的ip\n        params:\n            name: mikigo\n    validate:\n        - eq: ["status_code", 200]\n        - eq: ["body.name", "mikigo"]\n\n'})}),"\n",(0,r.jsxs)(e.h3,{id:"3执行用例",children:["3、执行用例",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3执行用例",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"使用hrp命令执行"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"hrp run testcases/demo_1.yml --gen-html-report\n"})}),"\n",(0,r.jsx)(e.p,{children:"run 是使用 go 驱动执行；"}),"\n",(0,r.jsx)(e.p,{children:"如果你习惯使用 pytest："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"hrp pytest testcases/demo_1.yml\n"})}),"\n",(0,r.jsxs)(e.p,{children:["后面你要生成什么报告，加什么参数就完全按照 ",(0,r.jsx)(e.code,{children:"pytest"})," 的规范来就好，不过 ",(0,r.jsx)(e.code,{children:"pytest"})," 那一套咱们已经熟得不能再熟了，没啥意思，就用 go 驱动吧。"]}),"\n",(0,r.jsxs)(e.p,{children:["跑完之后在 ",(0,r.jsx)(e.code,{children:"results"})," 目录下生成一个 ",(0,r.jsx)(e.code,{children:"html"})," 文件，打开它："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/httprunner/2.png",alt:""})}),"\n",(0,r.jsxs)(e.h2,{id:"七debugtalkpy底层实现原理",children:["七、debugtalk.py底层实现原理",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#七debugtalkpy底层实现原理",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["前面讲到可以在 ",(0,r.jsx)(e.code,{children:"debugtalk.py"})," （下面就用“它”指代）里面定义一些变量或函数，然后在用例里面通过 ",(0,r.jsx)(e.code,{children:"$var"})," 、",(0,r.jsx)(e.code,{children:"${func()}"})," 的方式调用；"]}),"\n",(0,r.jsxs)(e.p,{children:["这章咱们就讲讲，为啥在 ",(0,r.jsx)(e.code,{children:"debugtalk.py"})," 里面定义的代码，能在 ",(0,r.jsx)(e.code,{children:"yaml"})," 文件里面写字符串的方式调用；"]}),"\n",(0,r.jsxs)(e.h3,{id:"1获取路径",children:["1、获取路径",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1获取路径",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"loader.py"})," 里面："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# loader.py\ndef locate_project_root_directory(test_path: Text) -> Tuple[Text, Text]:\n    """locate debugtalk.py path as project root directory\n\n    Args:\n        test_path: specified testfile path\n\n    Returns:\n        (str, str): debugtalk.py path, project_root_directory\n\n    """\n    ...\n    return debugtalk_path, project_root_directory\n'})}),"\n",(0,r.jsxs)(e.p,{children:["很明显返回了两个路径：",(0,r.jsx)(e.code,{children:"ebugtalk_path"}),", ",(0,r.jsx)(e.code,{children:"project_root_directory"})]}),"\n",(0,r.jsxs)(e.h3,{id:"2原始数据",children:["2、原始数据",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2原始数据",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# loader\ndef load_project_meta(test_path: Text, reload: bool = False) -> ProjectMeta:\n    """load testcases, .env, debugtalk.py functions.\n        testcases folder is relative to project_root_directory\n        by default, project_meta will be loaded only once, unless set reload to true.\n\n    Args:\n        test_path (str): test file/folder path, locate project RootDir from this path.\n        reload: reload project meta if set true, default to false\n\n    Returns:\n        project loaded api/testcases definitions,\n            environments and debugtalk.py functions.\n\n    """\n    ...\n    return project_meta\n'})}),"\n",(0,r.jsxs)(e.p,{children:["返回的 ",(0,r.jsx)(e.code,{children:"project_meta"})," 是 ",(0,r.jsx)(e.code,{children:"pydantic"})," 的模型对象，你可以理解成就是一个字典；"]}),"\n",(0,r.jsx)(e.p,{children:"在这个函数里面主要逻辑是通过一个函数获取它里面的函数对象："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# loader\ndef load_module_functions(module) -> Dict[Text, Callable]:\n    """load python module functions.\n\n    Args:\n        module: python module\n\n    Returns:\n        dict: functions mapping for specified python module\n\n            {\n                "func1_name": func1,\n                "func2_name": func2\n            }\n\n    """\n    module_functions = {}\n    for name, item in vars(module).items():\n        if isinstance(item, types.FunctionType):\n            module_functions[name] = item\n    return module_functions\n'})}),"\n",(0,r.jsxs)(e.p,{children:["这里面主要用到了 ",(0,r.jsx)(e.code,{children:"vars"})," 函数来获取，感兴趣的同学可以去查一下这个用法；"]}),"\n",(0,r.jsxs)(e.p,{children:["到这里也就是说获取到了它里面的 ",(0,r.jsx)(e.code,{children:"函数名"})," 及 ",(0,r.jsx)(e.code,{children:"函数对象"})," ，有了函数对象在合适的位置调用就行了；"]}),"\n",(0,r.jsx)(e.p,{children:"咱们接着往后看；"}),"\n",(0,r.jsxs)(e.h3,{id:"3参数解构",children:["3、参数解构",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3参数解构",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"parser.py"})," 中进行参数结构："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# parser.py\ndef parse_parameters(\n    parameters: Dict,\n) -> List[Dict]:\n    """parse parameters and generate cartesian product.\n\n    Args:\n        parameters (Dict) parameters: parameter name and value mapping\n            parameter value may be in three types:\n                (1) data list, e.g. ["iOS/10.1", "iOS/10.2", "iOS/10.3"]\n                (2) call built-in parameterize function, "${parameterize(account.csv)}"\n                (3) call custom function in debugtalk.py, "${gen_app_version()}"\n\n    Returns:\n        list: cartesian product list\n    """\n    ...\n    return utils.gen_cartesian_product(*parsed_parameters_list)\n'})}),"\n",(0,r.jsx)(e.p,{children:"经过一系列的数据处理，把参数列表返回出来"}),"\n",(0,r.jsxs)(e.h3,{id:"4函数调用",children:["4、函数调用",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4函数调用",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# parser.py\ndef parse_string(\n    raw_string: Text,\n    variables_mapping: VariablesMapping,\n    functions_mapping: FunctionsMapping,\n) -> Any:\n    """parse string content with variables and functions mapping.\n\n    Args:\n        raw_string: raw string content to be parsed.\n        variables_mapping: variables mapping.\n        functions_mapping: functions mapping.\n\n    Returns:\n        str: parsed string content.\n\n    Examples:\n        >>> raw_string = "abc${add_one($num)}def"\n        >>> variables_mapping = {"num": 3}\n        >>> functions_mapping = {"add_one": lambda x: x + 1}\n        >>> parse_string(raw_string, variables_mapping, functions_mapping)\n            "abc4def"\n\n    """\n    \n'})}),"\n",(0,r.jsx)(e.p,{children:"在这个函数里面主要代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# parser.py\ndef parse_string(\n    raw_string: Text,\n    variables_mapping: VariablesMapping,\n    functions_mapping: FunctionsMapping,\n) -> Any:\n	...\n    while match_start_position < len(raw_string):\n        ...\n        if func_match:\n            func_name = func_match.group(1)\n            func = get_mapping_function(func_name, functions_mapping)\n\n            func_params_str = func_match.group(2)\n            function_meta = parse_function_params(func_params_str)\n            args = function_meta["args"]\n            kwargs = function_meta["kwargs"]\n            parsed_args = parse_data(args, variables_mapping, functions_mapping)\n            parsed_kwargs = parse_data(kwargs, variables_mapping, functions_mapping)\n\n            try:\n                func_eval_value = func(*parsed_args, **parsed_kwargs)\n            except Exception as ex:\n				...\n            ...\n    return parsed_string\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"func"})," 为函数对象，通过 ",(0,r.jsx)(e.code,{children:"parse_data"})," 函数获取到参数 ",(0,r.jsx)(e.code,{children:"parsed_args"})," 和 ",(0,r.jsx)(e.code,{children:"parsed_kwargs"}),"，通过 ",(0,r.jsx)(e.code,{children:"func(*parsed_args, **parsed_kwargs)"})," 调用函数并获取到值；"]}),"\n",(0,r.jsx)(e.p,{children:"最后经过一顿组装返回最终的字符串；"}),"\n",(0,r.jsxs)(e.h3,{id:"5变量获取",children:["5、变量获取",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5变量获取",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"变量获取相对简单，不想函数调用，要考虑函数对象及参数；"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"# parser.py\ndef parse_variables_mapping(\n    variables_mapping: VariablesMapping, functions_mapping: FunctionsMapping = None\n) -> VariablesMapping:\n    ...\n    while len(parsed_variables) != len(variables_mapping):\n        ...\n            try:\n                parsed_value = parse_data(\n                    var_value, parsed_variables, functions_mapping\n                )\n            except exceptions.VariableNotFound:\n                continue\n            ...\n    return parsed_variables\n"})}),"\n",(0,r.jsxs)(e.p,{children:["也是通过 ",(0,r.jsx)(e.code,{children:"parse_data"})," 函数来获取；"]}),"\n",(0,r.jsxs)(e.h3,{id:"6驱动入口",children:["6、驱动入口",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6驱动入口",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'# runner.py\nclass SessionRunner(object):\n	\n    ...\n\n    def __parse_config(self, param: Dict = None) -> None:\n        # parse config variables\n        self.__config.variables.update(self.__session_variables)\n        if param:\n            self.__config.variables.update(param)\n        self.__config.variables = self.parser.parse_variables(self.__config.variables)\n\n        # parse config name\n        self.__config.name = self.parser.parse_data(\n            self.__config.name, self.__config.variables\n        )\n\n        # parse config base url\n        self.__config.base_url = self.parser.parse_data(\n            self.__config.base_url, self.__config.variables\n        )\n        \n    ...\n\n    def test_start(self, param: Dict = None) -> "SessionRunner":\n        """main entrance, discovered by pytest"""\n        ...\n        self.__parse_config(param)\n        ...\n'})}),"\n",(0,r.jsxs)(e.p,{children:["在入口文件 ",(0,r.jsx)(e.code,{children:"runner.py"})," 里面把上面所有的逻辑串起来；"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"test_start"})," 里面调用私有方法 ",(0,r.jsx)(e.code,{children:"__parse_config"}),"，在 ",(0,r.jsx)(e.code,{children:"__parse_config"})," 里面挨个处理前面的逻辑；"]}),"\n",(0,r.jsxs)(e.p,{children:["在 ",(0,r.jsx)(e.code,{children:"step"})," 里面通过："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"runner = HttpRunner().test_start()\n"})}),"\n",(0,r.jsx)(e.p,{children:"进行驱动执行；"})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(t,{...n})}):t(n)}let i=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["program%2Fautotest%2F%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%8A%A8%E5%8C%96%2FHttpRunner-2%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%89%88.md"]={toc:[{text:"一、简介",id:"一简介",depth:2},{text:"二、安装",id:"二安装",depth:2},{text:"三、创建项目",id:"三创建项目",depth:2},{text:"四、目录结构",id:"四目录结构",depth:2},{text:"五、执行用例",id:"五执行用例",depth:2},{text:"六、实例",id:"六实例",depth:2},{text:"1、mock接口",id:"1mock接口",depth:3},{text:"2、写接口用例",id:"2写接口用例",depth:3},{text:"3、执行用例",id:"3执行用例",depth:3},{text:"七、debugtalk.py底层实现原理",id:"七debugtalkpy底层实现原理",depth:2},{text:"1、获取路径",id:"1获取路径",depth:3},{text:"2、原始数据",id:"2原始数据",depth:3},{text:"3、参数解构",id:"3参数解构",depth:3},{text:"4、函数调用",id:"4函数调用",depth:3},{text:"5、变量获取",id:"5变量获取",depth:3},{text:"6、驱动入口",id:"6驱动入口",depth:3}],title:"HttpRunner—2小时入门版",headingTitle:"HttpRunner—2小时入门版",frontmatter:{Author:"mikigo"}}}}]);