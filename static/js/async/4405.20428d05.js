"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["4405"],{8984:function(n,e,i){i.r(e),i.d(e,{default:()=>a});var s=i(2676),l=i(453);function r(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",img:"img"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"pipeline语法介绍",children:["Pipeline语法介绍",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#pipeline语法介绍",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"简介",children:["简介",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"})]}),"\n",(0,s.jsxs)(e.p,{children:["Pipeline 是一种用于定义和自动化软件交付过程的工具，它可以通过代码进行持续集成和持续交付。Pipeline 主要有两种模式：",(0,s.jsx)(e.strong,{children:"Declarative Pipeline"})," 和 ",(0,s.jsx)(e.strong,{children:"Scripted Pipeline"}),"。Declarative Pipeline 提供了一种更简单、结构化的方式来定义构建过程，适合大多数用户；而 Scripted Pipeline 则允许更大的灵活性，采用 Groovy 语言编写，适合需要复杂逻辑的场景"]}),"\n",(0,s.jsxs)(e.h2,{id:"declarative-pipline",children:["Declarative Pipline",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#declarative-pipline",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"demo演示",children:["demo演示",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo演示",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"pipeline {\n    agent { label 'test_XXX' }\n\n    stages {\n        stage('测试阶段1') {\n            steps {\n                echo '安装虚拟机'\n            }\n        }\n        stage('测试阶段2') {\n            steps {\n                echo '功能测试'\n            }\n        }\n    }\n    post {\n        always {\n            echo \"清理环境\"\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"上面是一个简单的流水线，其中包含两个测试阶段，在我们实际工作中可以根据不同的使用场景，设计不同的阶段，每个stage代表一个测试阶段，Jenkins会按照从上到下的顺序依次执行每个stage，当前两个测试阶段执行完成后，最后执行post内操作，以上示例只是为了让大家先简单感受一下Pipeline的玩法，下面会详细介绍Pipeline的重点语法"}),"\n",(0,s.jsxs)(e.h3,{id:"语法讲解",children:["语法讲解",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#语法讲解",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"stages"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"​	含义：包括一个或者多个stage的序列，Pipeline的大部分工作在此执行，必须出现的指令，每个Pipeline代码区间中必须只有一个stages"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"stage"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"​	含义：包含在stages中，Pipeline完成的所有实际工作都需要包含在stage中，必须出现的指令，需要定义stage的名字"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"step"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"​	含义：具体执行步骤，包含stage代码区间中，必须出现的指令"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'stages{\n	stage(\'描述本阶段的任务\') {\n		step{\n			echo "开始下载代码"\n			git "https:XXXXXXX"\n			}\n		}\n}\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"agent"}),"\n",(0,s.jsx)(e.p,{children:"含义：定义Pipeline执行节点，是必须出现的指令"}),"\n",(0,s.jsx)(e.p,{children:"参数："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"any：可以在任意节点上执行Pipeline"}),"\n",(0,s.jsx)(e.li,{children:"none：不配全局agent，每个stage分配自己的agent"}),"\n",(0,s.jsx)(e.li,{children:"label:指定运行节点的label"}),"\n",(0,s.jsxs)(e.li,{children:["node：自定义运行节点配置","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"label：设置运行节点"}),"\n",(0,s.jsx)(e.li,{children:"customWorkspace：指定工作目录"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"docker：控制目标节点上的docker运行相关内容"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"使用node参数指定执行节点和工作目录："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'Pipeline{\n	agent{\n		node{\n		label "myslave"\n		customWorkspace "myWorkspace"\n			}\n		}\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"每个阶段使用不同的节点环境："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"Pipeline {\nagent none // 表示流水线中的所有阶段都不会自动分配代理\n	stages {\n		stage('Build') {\n			agent any // 这个阶段会使用任意可用的代理\n			steps {\n				echo 'Building...'\n				}\n		}\n	stage('Test') {\n		agent none // 这个阶段不会分配任何代理\n		steps {\n        echo 'Testing...'\n			}\n		}\n	stage('Deploy') {\n		agent {\n			label 'my-label' // 这个阶段会在具有特定标签的代理上运行\n		}\n		steps {\n			echo 'Deploying...'\n			}\n		}\n	}\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"environment"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"​	含义：定义全局变量，不是必须出现的指令"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'environment {\nversion = "1070"\nversion_a = "1070a"\n}\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"post"}),"\n",(0,s.jsx)(e.p,{children:"含义：定义Pipeline或者stage运行结束时的操作"}),"\n",(0,s.jsx)(e.p,{children:"参数"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"always：无论Pipeline运行的完成状态如何都会运行"}),"\n",(0,s.jsx)(e.li,{children:"changed：只有当前Pipeline运行的状态与之前完成的Pipeline的状态不同时，才会运行"}),"\n",(0,s.jsx)(e.li,{children:"failure:仅当当前Pipeline处于失败状态时才会运行"}),"\n",(0,s.jsx)(e.li,{children:"success：仅当当前Pipeline处于成功状态时才会运行"}),"\n",(0,s.jsx)(e.li,{children:"unstable：只有当前Pipeline具有不稳定状态才能运行"}),"\n",(0,s.jsx)(e.li,{children:"aborded：只有当前Pipeline处于中止状态时才能运行"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'post {\n     always {\n         echo "总是运行"\n        }\n	success {\n		echo "成功了，运行起来"\n	}\n }\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"options"}),"\n",(0,s.jsx)(e.p,{children:"含义：定义一些Pipeline的特殊属性，不是必须出现的指令"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"buildDiscarder:保留构建的最大个数（页面上可以显示多少次构建）"}),"\n",(0,s.jsx)(e.li,{children:"disableConcurrentBuilds:不允许并行执行Pipeline任务"}),"\n",(0,s.jsx)(e.li,{children:"timeout：Pipeline超时时间"}),"\n",(0,s.jsx)(e.li,{children:"retry:失败后，重试整个Pipeline的次数"}),"\n",(0,s.jsx)(e.li,{children:"timestamps:预定义由Pipeline生成的所有控制台输出时间"}),"\n",(0,s.jsx)(e.li,{children:"skipStagesAfterUnstable:一旦构建状态进入了“Unstable”状态，就跳过后续stage"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"使用示例："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"options {\n    timestamps()     //日志会显示时间  需要安装timestamps插件\n    skipDefaultCheckout()     //删除隐式的checkout scm语句，比如说，流水线中有代码库，他会查看你是否下载，帮你下载，设置后会取消这些操作\n    disableConcurrentBuilds()  //禁止并行\n    timeout(time:1,unit:'HOURS')  //流水线超时时间设置为1h\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"skipStagesAfterUnstable使用示例，此情景会跳过Deploy测试阶段："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"Pipeline {\n	agent any\n    options {\n    skipStagesAfterUnstable() // 启用这个选项\n    }\n	stages {\n        stage('Build') {\n            steps {\n            echo 'Building...'\n                }\n        }\n        stage('Test') {\n            steps {\n                script {\n                // 定义实际的条件，例如：\n                def someCondition = true\n                // 模拟测试不稳定\n                if (someCondition) {\n                currentBuild.result = 'UNSTABLE'\n                	}\n            	}\n        	}\n        }\n        stage('Deploy') {\n            steps {\n            echo 'Deploying...'\n            }\n        }\n	}\n}\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"parameters"}),"\n",(0,s.jsx)(e.p,{children:"含义："}),"\n",(0,s.jsx)(e.p,{children:"定义Pipeline的触发参数，不是必须出现的指令，支持数据类型：booleanParam(布尔),choice（选择）,credentials（证书）,file（文件），text（文本）,password（密码）,run（运行时参数）,string（字符串）"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"定义参数PERSON，触发jenkins工程的时候，需要输入参数的值，才能成功触发工程"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"parameters {\n	string(name:'PERSON',defaultValue:'zuohanxu',description:'左含旭')\n    }\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"triggers"}),"\n",(0,s.jsx)(e.p,{children:"​	含义："}),"\n",(0,s.jsx)(e.p,{children:"​	定义了Pipeline自动触发的方式"}),"\n",(0,s.jsx)(e.p,{children:"​	参数："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"cron：接受一个cron风格的字符串来定义Pipeline触发的常规间隔"}),"\n",(0,s.jsx)(e.li,{children:"pollSCM：接受一个cron风格的字符串来定义jenkins检查SCM源更改的常规间隔，如果存在新的更改，则Pipeline将被重新触发"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"cron demo："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"triggers{\n    cron('* * * * *')\n    }\n"})}),"\n",(0,s.jsx)(e.p,{children:"日志显示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/Pipeline%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D_assets/cron%E6%97%A5%E5%BF%97.png",alt:"cron日志"})}),"\n",(0,s.jsx)(e.p,{children:"pollSCM demo："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"triggers{\npollSCM('H */4 * * 1-5')\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"日志显示："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/Pipeline%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D_assets/pollSCM_log.png",alt:"pollSCM日志"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"parallel"}),"\n",(0,s.jsx)(e.p,{children:"含义："}),"\n",(0,s.jsx)(e.p,{children:"可以让多个stage并行执行"}),"\n",(0,s.jsx)(e.p,{children:"demo："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"pipeline {\n    agent any\n\n    stages {\n        stage('并行测试阶段') {\n            parallel {\n                stage('测试阶段1') {\n                    steps {\n                        echo '安装虚拟机1'\n                    }\n                }\n                stage('测试阶段2') {\n                    steps {\n                        echo '安装虚拟机2'\n                    }\n                }\n            }\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"运行流程："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/Pipeline%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D_assets/%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png",alt:"运行流程"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"scripts-pipeline",children:["Scripts Pipeline",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#scripts-pipeline",children:"#"})]}),"\n",(0,s.jsxs)(e.h3,{id:"demo演示-1",children:["demo演示",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#demo演示-1",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"node {\n    stage('构建') {\n        echo '正在构建项目...'\n        // 这里可以添加构建命令，例如 Maven 或 Gradle\n    }\n    \n    stage('测试') {\n        echo '正在运行测试...'\n        // 这里可以添加测试命令，例如单元测试\n    }\n    \n    stage('部署') {\n        echo '正在部署应用...'\n        // 这里可以添加部署命令\n    }\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"Scripts Pipeline相比Declarative Pipline更加灵活，支持条件判断、循环语句等，下面主要讲解一下重点语句用法："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"try catch语句"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'stage(\'Build\') {\n    node {           //此处没有指定节点，意思是在任何节点运行都可以\n    	echo "this is build stage"\n    }\n}\nstage(\'Test\') {\n	node(\'ubuntu_docker\') {\n    try {\n        echo "执行tyr语句"\n        error "触发异常"\n    }catch (exc) {\n    echo "执行catch语句${exc}"\n    }finally {\n    echo "执行finally语句"\n    	}\n    }\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"流水线可以通过try语句捕捉异常，防止异常退出的情况发生"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"条件语句"}),"\n",(0,s.jsx)(e.p,{children:"demo："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"stage('Test') {\n    node('ubuntu_docker') {\n        if (1 == 1) {\n        echo \"条件成立\"\n        } else {\n        echo \"条件不成立\"\n        }\n    }\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"循环语句"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"for循环"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"node {\n    stage('Loop Example') {\n        for (int i = 1; i <= 5; i++) {\n            echo \"This is iteration number: ${i}\"\n        }\n    }\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"while循环"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"node {\n    stage('While Loop Example') {\n        int count = 0\n        while (count < 5) {\n            count++\n            echo \"This is iteration number: ${count}\"\n        }\n    }\n}\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"each方法循环列表"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"node {\n    stage('Each Loop Example') {\n        def items = ['apple', 'banana', 'cherry']\n        items.each { item ->\n            echo \"Current fruit: ${item}\"\n        }\n    }\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"执行shell"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"书写方式："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:'stage(\'Test\') {\n    node(\'ubuntu_docker\') {\n        def output = sh(script: "cd /home; pwd", returnStdout: true , label:"into home")\n                            echo "Current directory: ${output}"\n    } \n}\n'})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"参数含义："}),"\n",(0,s.jsx)(e.p,{children:"script：执行的 Shell 命令或脚本"}),"\n",(0,s.jsx)(e.p,{children:"returnStdout（可选）：如果设置为 true，命令的标准输出将被捕获并作为字符串返回，而不是直接打印到 Jenkins 日志中"}),"\n",(0,s.jsx)(e.p,{children:"label（可选）：为当前的 Shell 执行步骤提供一个描述性标签"}),"\n",(0,s.jsx)(e.p,{children:"returnStatus：如果设置为 true，则会返回命令的退出状态码，而不是输出"}),"\n",(0,s.jsx)(e.p,{children:"运行日志："}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:"/Pipeline%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D_assets/scrip_sh_log.png",alt:"shell日志"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"declarative-pipline和scripts-pipeline结合使用",children:["Declarative Pipline和Scripts Pipeline结合使用",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#declarative-pipline和scripts-pipeline结合使用",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"实际工作中，流水线的设计大多会将Declarative和Scripts结合起来使用，这样设计的流水线，在保证结构清晰、简单的情况下，还可以灵活的满足多种场景。结合使用的写法也很简单，主体框架采用Declarative的结构书写方式，在需要Scripts语句的时候，只需要把Scripts语句写在script当中即可，下面是一个简单的demo："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-groovy",children:"pipeline {\n    agent any\n\n    stages {\n        stage('Preparation') {\n            steps {\n                script {\n                    echo 'Preparing the environment...'\n                    // 这里可以使用 Scripted Pipeline 的逻辑\n                    def branch = 'main'\n                    echo \"Checking out branch: ${branch}\"\n                }\n            }\n        }\n        \n        stage('Build') {\n            steps {\n                script {\n                    // 使用 Scripted Pipeline 来执行循环\n                    for (int i = 1; i <= 3; i++) {\n                        echo \"Building iteration ${i}...\"\n                    }\n                }\n            }\n        }\n\n        stage('Test') {\n            steps {\n                script {\n                    // 使用 Scripted Pipeline 的条件判断\n                    def testsPassed = true\n                    if (testsPassed) {\n                        echo 'All tests passed.'\n                    } else {\n                        echo 'Some tests failed.'\n                    }\n                }\n            }\n        }\n\n        stage('Deploy') {\n            steps {\n                echo 'Deploying application...'\n                // 可以继续使用 Declarative 的方式\n            }\n        }\n    }\n    \n    post {\n        always {\n            echo 'Cleaning up...'\n        }\n    }\n}\n"})})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(r,{...n})}):r(n)}let a=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2FJenkins%2FPipeline%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D.md"]={toc:[{text:"简介",id:"简介",depth:2},{text:"Declarative Pipline",id:"declarative-pipline",depth:2},{text:"demo演示",id:"demo演示",depth:3},{text:"语法讲解",id:"语法讲解",depth:3},{text:"Scripts Pipeline",id:"scripts-pipeline",depth:2},{text:"demo演示",id:"demo演示-1",depth:3},{text:"Declarative Pipline和Scripts Pipeline结合使用",id:"declarative-pipline和scripts-pipeline结合使用",depth:2}],title:"Pipeline语法介绍",headingTitle:"Pipeline语法介绍",frontmatter:{Author:"zhx"}}}}]);