"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["5168"],{4847:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(2676),a=s(453);function t(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre",h3:"h3",img:"img"},(0,a.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"locust2小时入门版",children:["Locust—2小时入门版",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#locust2小时入门版",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"一简介",children:["一、简介",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一简介",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["性能测试通常指的是 ",(0,r.jsx)(n.code,{children:"API"})," 性能测试，使用 ",(0,r.jsx)(n.code,{children:"JMeter"})," 做的同学会多一点，因为它开源免费，提供了一些插件，只需要在图形化的界面录入一些数据就能很方便的进行接口测试、性能测试，相比于商用软件 ",(0,r.jsx)(n.code,{children:"LoadRunner"}),"更适合普通玩家，所以 ",(0,r.jsx)(n.code,{children:"JMeter"})," 群众基础更好。"]}),"\n",(0,r.jsxs)(n.p,{children:["locust 是近几年才流行起来的，主要是因为需要编码，所以好多同学有点抵触，但其功能完全不输 ",(0,r.jsx)(n.code,{children:"JMeter"})," ；"]}),"\n",(0,r.jsxs)(n.h2,{id:"二安装",children:["二、安装",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二安装",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"pip3 install locust\n"})}),"\n",(0,r.jsx)(n.p,{children:"检查是否安装成功："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"locust -V\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"三用例模板",children:["三、用例模板",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三用例模板",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# template.py\n\nimport random\nfrom locust import TaskSequence, HttpLocust, task, seq_task, between\n\n\n# 定义一个任务类，这个类名称自己随便定义，类继承 TaskSequence 或 TaskSet类\n# 当类里面的任务请求有先后顺序时，继承TaskSequence类， 没有先后顺序，可以使用继承TaskSet类\nclass MyTaskCase(TaskSequence):\n    \n    # 初始化方法，相当于 setup\n    def on_start(self):\n        pass\n\n    # @task \n    # python中的装饰器，告诉下面的方法是一个任务，任务就可以是一个接口请求，\n    # 这个装饰器和下面的方法被复制多次，改动一下，就能写出多个接口\n    # 装饰器后面带上(数字)代表在所有任务中，执行比例\n    # 要用这个装饰器，需要头部引入 从locust中，引入 task\n    @task\n    # 装饰器，定义有执行顺序的任务，扩展中的数字，从小到大，代表先后执行顺序\n    @seq_task(1)  \n    # 一个方法， 方法名称可以自己改\n    def regist(self): \n        # 接口请求的URL地址\n        url = '/erp/regist'\n        # 定义请求头为类变量，这样其他任务也可以调用该变量\n        self.headers = {\"Content-Type\": \"application/json\"} \n        self.user = \"locust_\" + str(random.randint(10000, 100000))\n        self.pwd = '1234567890'\n        # post请求的 请求体\n        data = {\"name\": self.user, \"pwd\": self.pwd}\n        # 使用self.client发起请求，请求的方法根据接口实际选,\n        # catch_response 值为True 允许为失败 ， name 设置任务标签名称   -----可选参数\n        rsp = self.client.post(url, json=data, headers=self.headers, catch_response=True, name='api_regist')\n        if rsp.status_code == 200:\n            rsp.success()\n        else:\n            rsp.failure('regist_ 接口失败！')\n\n    @task \n    # 顺序任务装饰器，说明下面的任务，第二个执行\n    @seq_task(2)  \n    def login(self):\n        url = '/erp/loginIn' \n        data = {\"name\": self.user, \"pwd\": self.pwd}\n        # 使用self.client发起请求，请求的方法 选择post\n        rsp = self.client.post(url, json=data, headers=self.headers, catch_response=True) \n        # 提取响应json 中的信息，定义为 类变量\n        self.token = rsp.json()['token']    \n        if rsp.status_code == 200 and rsp.json()['code'] == \"200\":\n            rsp.success()\n        else:\n            rsp.failure('login_ 接口失败！')\n\n    @task\n    @seq_task(3) \n    def getuser(self):\n        url = '/erp/user'\n        # 引用上一个任务的 类变量值,实现参数关联\n        headers = {\"Token\": self.token}  \n        # 使用self.client发起请求，请求的方法 选择 get\n        rsp = self.client.get(url, headers=headers, catch_response=True)  \n        if rsp.status_code == 200:\n            rsp.success()\n        else:\n            rsp.failure('getuser_ 接口失败！')\n\n    # 结束方法， 相当于teardown\n    def on_stop(self):\n        pass\n\n\n# 定义一个运行类 继承HttpLocust类\nclass UserRun(HttpLocust):\n    # 定义固定的 task_set  指定前面的任务类名称\n    task_set = MyTaskCase\n    # 设置运行过程中间隔时间 需要从 locust 中 引入 between\n    wait_time = between(0.1, 3)  \n"})}),"\n",(0,r.jsx)(n.p,{children:"执行时在终端输入："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"locust -f template.py \n"})}),"\n",(0,r.jsxs)(n.h2,{id:"四简单测试",children:["四、简单测试",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四简单测试",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"1mock接口",children:["1、mock接口",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1mock接口",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["咱们先使用 ",(0,r.jsx)(n.code,{children:"FastAPI"})," 简单 ",(0,r.jsx)(n.code,{children:"Mock"})," 一个接口："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# mock.py\nimport os\n\nimport uvicorn\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get("/items/")\nasync def read_item(name: str = ""):\n    return {"name": name}\n\n\nif __name__ == \'__main__\':\n    uvicorn.run(\n        app="mock:app",\n        host=os.popen("hostname -I").read().split(" ")[0], # 自动获取本机IP\n        port=5000,\n        reload=True\n    )\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"2测试用例",children:["2、测试用例",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2测试用例",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# demo_1.py\n\nfrom locust import HttpUser, task\n\nclass HelloWorldUser(HttpUser):\n    @task\n    def hello_world(self):\n        self.client.get("/items?name=mikigo")\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"五运行",children:["五、运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五运行",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"网页在线运行",children:["网页在线运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#网页在线运行",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"locust -f demo_1.py \n"})}),"\n",(0,r.jsx)(n.p,{children:"终端会提示一个链接，使劲戳他："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"$ locust -f demo_1.py \n[2023-07-13 17:55:51,182] uos-PC/INFO/locust.main: Starting web interface at http://0.0.0.0:8089 \n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"/locust/1.jpg",alt:""})}),"\n",(0,r.jsxs)(n.p,{children:['第1个"',(0,r.jsx)(n.code,{children:"Number of users"}),'" 总共将运行的用户数；']}),"\n",(0,r.jsxs)(n.p,{children:['第2个 "',(0,r.jsx)(n.code,{children:"Spawn rate"}),'" 每秒加载的用户数；']}),"\n",(0,r.jsxs)(n.p,{children:['第3个 "',(0,r.jsx)(n.code,{children:"Host"}),'"，被测接口的域名；咱们 Mock 的接口地址是：',(0,r.jsx)(n.a,{href:"http://10.8.13.224:5000/items?name=mikigo",target:"_blank",rel:"noopener noreferrer",children:"http://10.8.13.224:5000/items?name=mikigo"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"/locust/2.jpg",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"点击【Start swarming】开始测试："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"/locust/3.jpg",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"这玩意儿是一直跑的，不会自己停下来，要停止测试，需要点击右上角【STOP】；"}),"\n",(0,r.jsxs)(n.h3,{id:"命令行运行",children:["命令行运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#命令行运行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"常用的参数"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"locust --headless -f demo_1.py -u 20 -r 2 -t 2m --host=http://10.8.13.224:5000/items?name=mikigo --csv=mikigo\n# --headless 指名用无图形界面模式\n# -u 指定运行的最大用户数，对应图形界面中的 \n# -r 指定每秒生成用户数，对应图形界面中的 Spawn rate\n# -t 指定总共运行时长，因在无图形界面中，没有停止按钮，需要有这个参数才能到时间就停止，不然会一直运行下去，直到终端ctrl+c强行停止\n# --host 被测服务器域名或ip端口地址\n# --csv 输出结果到csv文件的前缀\n"})}),"\n",(0,r.jsxs)(n.p,{children:["终端会以表格的形式刷新数据，在当前目录会生成一些 ",(0,r.jsx)(n.code,{children:"csv"})," 的报告；"]}),"\n",(0,r.jsxs)(n.h3,{id:"分布式运行",children:["分布式运行",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#分布式运行",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"主控机器"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"locust -f demo_1.py --master\n"})}),"\n",(0,r.jsx)(n.p,{children:"助攻机器"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"# 和主控在同一台机器\nlocust -f demo_1.py --worker\n# 和主控在不同一台机器\nlocust -f demo_1.py --worker --master-host=${master_ip} --master-port=${master_port}\n"})}),"\n",(0,r.jsx)(n.p,{children:"助攻机器可以有多个；"}),"\n",(0,r.jsx)(n.p,{children:"主控机器终端输入类似这样："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"Worker uos-PC_4880a337c8ed49769a9995d6a14950af (index 0) reported as ready. 1 workers connected.\n"})}),"\n",(0,r.jsx)(n.p,{children:"就说明呼应上了；"}),"\n",(0,r.jsx)(n.p,{children:"分布式运行同样支持网页运行和命令行运行；"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(t,{...e})}):t(e)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["autotest%2F%E6%80%A7%E8%83%BD%E8%87%AA%E5%8A%A8%E5%8C%96%2FLocust%E2%80%942%E5%B0%8F%E6%97%B6%E5%85%A5%E9%97%A8%E7%89%88.md"]={toc:[{text:"一、简介",id:"一简介",depth:2},{text:"二、安装",id:"二安装",depth:2},{text:"三、用例模板",id:"三用例模板",depth:2},{text:"四、简单测试",id:"四简单测试",depth:2},{text:"1、mock接口",id:"1mock接口",depth:3},{text:"2、测试用例",id:"2测试用例",depth:3},{text:"五、运行",id:"五运行",depth:2},{text:"网页在线运行",id:"网页在线运行",depth:3},{text:"命令行运行",id:"命令行运行",depth:3},{text:"分布式运行",id:"分布式运行",depth:3}],title:"Locust—2小时入门版",headingTitle:"Locust—2小时入门版",frontmatter:{Author:"mikigo"}}}}]);