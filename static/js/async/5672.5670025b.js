"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["5672"],{5157:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var r=s(2676),_=s(453);function l(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",p:"p",ul:"ul",li:"li",strong:"strong",pre:"pre",code:"code",img:"img",h3:"h3",h4:"h4"},(0,_.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"命令行用例转换自动化测试调研",children:["命令行用例转换自动化测试调研",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#命令行用例转换自动化测试调研",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"相关术语",children:["相关术语",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#相关术语",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{align:"center",children:"缩写"}),"\n",(0,r.jsx)(e.th,{align:"center",children:"全称"}),"\n",(0,r.jsx)(e.th,{align:"center",children:"描述"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"SAT"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"Shell Automated Test"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"使用Shell实现的自动化测试"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"问题",children:["问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		目前基于UOS专用设备系统的测试中，包含命令行模式测试和图像化页面测试，在命令行模式对应的用例中，有部分用例执行起来较为简单（操作单一、交互性弱），但是在执行起来却相当繁琐。"}),"\n",(0,r.jsx)(e.p,{children:"​		而且在实际测试过程中需要覆盖多个架构进行测试，重复工作较大，一条用例最多会被执行6遍，详情数据如下："}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{align:"left",children:"问题"}),"\n",(0,r.jsx)(e.th,{align:"left",children:"内容"}),"\n",(0,r.jsx)(e.th,{align:"left",children:"此类用例数量"}),"\n",(0,r.jsx)(e.th,{align:"left",children:"完整用例数量"}),"\n",(0,r.jsx)(e.th,{align:"left",children:"此类用例占比"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"left",children:"执行繁琐"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"执行命令行模式相关用例时，需要在命令行手动执行命令，然后通过命令输出结果与预期结果对比，得出用例执行结论，过程中需要不断的输入——验证——输入——验证......。"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"283"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"517"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"54.73%"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"left",children:"重复工作量大"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"测试过程中需要覆盖架构：AMD（Intel）、MIPS、ARM、SW，除此之外有时还需要验证AMD（兆芯）、虚拟机场景，综上所述，一条相同的用例，在进行全量测试时最少需要重复执行4次，最多需要重复执行6次。"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"1698"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"3102"}),"\n",(0,r.jsx)(e.td,{align:"left",children:"54.73%"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"​		以上表格统计的用例数量并不能代表执行命令的数量，因为每一条用例可能包含多条执行命令，所以执行命令条数是远远大于用例条数的；除了以上目前问题（执行繁琐及重复工作）外，还存在以下影响效率的问题："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"专用设备系统没有图形页面，相对于桌面版裁剪了大部分功能，用例的查看与执行是在不同设备上操作，所以无法粘贴命令，只能手动输入。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"若用例负责人请假/离职，更换测试人员进行测试，因为对用例不熟悉，需要依次查看用例文档预期内容。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"现状",children:["现状",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#现状",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["​		以上指出的问题，解决方案为把这54.73%的用例(后续称这54.73%的用例为：",(0,r.jsx)(e.strong,{children:"A类用例"}),"，另外一部分用例称为：",(0,r.jsx)(e.strong,{children:"B类用例"}),")，从人工执行转换为自动化执行（自动执行命令、自动验证输出结果、自动生成测试报告），这样除了在全量测试时减少工作量，提升测试效率；还能在回归测试、边缘测试时多覆盖一定的测试范围。"]}),"\n",(0,r.jsx)(e.p,{children:"​		在Linux系统上实现自动化，首先想到的是通过Shell实现，把所有用例写到一个脚本中自动执行并判断结果即可，例如："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'#! /bin/bash\n\ncase1=`which bash | grep "/usr/bin/bash"`\nif [ ${case1} ];then\n	echo "case1:pass" >> result.log\nelse\n	echo "case1:fail" >> result.log\nfi\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		执行以上Shell脚本即可完成对该条命令的测试，根据用例内容设计测试命令，并把命令结果赋值给变量，最后通过判断变量的情况得出结论。该方法能实现，但是当命令达到几百条并且后期还会继续增加时，那不管是代码编写还是后期维护都会越来越困难，会产生大量的代码冗余、内容无清晰等问题，所以该方案结论是测试内容少的时候可满足，但无法长远。"}),"\n",(0,r.jsx)(e.p,{children:"​		这样看来我们需要的是一个自动化测试框架，满足自动处理/执行测试用例、自动验证输出结果、自动生成测试报告。就目前常见的自动化测试框架来说均可满足需求，确定了以下2个方案："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"unitest：Python标准库中的单元测试框架，支持批量导入/执行用例、提供断言、初始化环境、环境清理、通过第三方库生成测试报告等。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"自行设计框架：根据目前需求，基于Shell自行编写一套适合项目的自动化测试框架"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"​		Shell框架和Python框架对比，Shell可直接执行系统命令，Python只能通过os、subprocess库来调用linux系统命令，在脚本的编写和调式都不如Shell简洁、方便。使用简单场景【查询音乐应用进程状态】的Shell、Python代码作为对比："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Python"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import subprocess\n\nps_state=subprocess.run('ps aux|grep -v grep|grep -q deepin-music', shell=True).returncode\nprint(ps_state)\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Shell"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"ps aux|grep -v grep|grep -q deepin-music\necho $?\n"})}),"\n",(0,r.jsx)(e.p,{children:"​		通过以上对比可发现，在Linux系统上，实现一个相同的功能，Shell编写的代码要更为直接、简洁，命令越多越复杂这个优势越明显，对于几百条用例编写代码来说更偏向于使用Shell。"}),"\n",(0,r.jsx)(e.p,{children:"​		除此之外Python通过第三方库生成的测试报告格式为HTML，但是针对当前项目中的裁剪系统来说，不带GUI页面所以并不支持查看HTML的文件；Shell框架生成的测试报告不带图形化内容，可直接在被测系统上直观的看到测试结果并进行验证，所以对查看测试结果来说Shell框架更适合当前项目。"}),"\n",(0,r.jsx)(e.p,{children:"​		该类测试需要的测试框架不需要很复杂，轻量级的即可，通过自行设计能更自由，更贴合项目，所以最终选定通过Shell自行设计自动化测试框架方案。"}),"\n",(0,r.jsx)(e.p,{children:"​"}),"\n",(0,r.jsxs)(e.h2,{id:"技术方案",children:["技术方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#技术方案",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["​		通过Shell实现设计自动化测试框架，命名为",(0,r.jsx)(e.code,{children:"SAT"}),"，通过",(0,r.jsx)(e.code,{children:"SAT"}),"主要实现",(0,r.jsx)(e.strong,{children:"现状"}),"部分所描述的需求：自动处理/执行测试用例、自动验证输出结果、自动生成测试报告。"]}),"\n",(0,r.jsxs)(e.p,{children:["​		",(0,r.jsx)(e.code,{children:"SAT"}),"自动化测试框架运行流程图如下："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E5%AF%B9PMS%E7%94%A8%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E7%A8%8BCSV%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A_assets//%E6%B5%81%E7%A8%8B%E5%9B%BE.png",alt:"流程图"})}),"\n",(0,r.jsxs)(e.h3,{id:"整体设计",children:["整体设计",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#整体设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["​		",(0,r.jsx)(e.code,{children:"SAT"}),"总体可以划分为下面几个模块："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例模块（case）：存放转换为自动化测试用例的代码，最小单位为函数，该框架支持多个用例模块文件。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"方法封装模块（method）：存放一些公用方法函数，比如：断言、测试报告等。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"启动测试模块（run_repor）：存放启动测试的主代码，对用例模块文件进行批量处理并生成测试报告。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"SAT目录结构如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:"   SAT					      #主目录\n\xa0\xa0 ├── case                      # 存放用例模块的目录\n\xa0\xa0 │\xa0\xa0 ├── case_a.sh        	 # 测试人员A用例文件\n   │\xa0\xa0 ├── case_b.sh  			 # 测试人员B用例文件\n\xa0\xa0 │\xa0\xa0 └── ...\n\xa0\xa0 ├── method                    # 存放方法封装模块的目录\n\xa0\xa0 │\xa0\xa0 ├── assertion.sh				# 断言函数封装模块文件\n\xa0\xa0 │\xa0\xa0 └── other.sh					# 其他函数封装模块文件\n\xa0\xa0 ├── report					 # 存放测试报告的目录\n\xa0\xa0 │\xa0\xa0 ├── report_0817231130		# 测试报告文件\n\xa0\xa0 │\xa0\xa0 └── report_0819115441\n\xa0\xa0 └── run_report.sh			 # 启动测试模块文件\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"用例模块case",children:["用例模块（case）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#用例模块case",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		实际项目中每个人负责的模块与用例不同，所以自动化测试用例需要自己编写负责部分，不像其他模块中的代码都是公用的，那么在编写格式上需要做统一的约定。格式统一之后，每人完成自己部分的用例文件，在启动测试时只要汇总全部用例模块文件，即可完成所有人的测试用例执行："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例模块文件命名统一，测试人员A、B的用例模块文件：case_a.sh、case_b.sh。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试用例最小单位统一：每一条测试用例为一条函数，通过函数来管理用例。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例函数命名统一，测试人员A的第1、2条用例：test_a1(){}、test_a2(){}。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例函数元素统一，需要包含变量：title、case_id、断言函数。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"方法封装模块method",children:["方法封装模块（method）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法封装模块method",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该模块主要用于存放公共方法函数，其他模块直接调用即可，使代码更为清晰简洁，并减少冗余。封装的函数主要实现以下功能："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例断言：判断用例执行结果与预期是否一致，给出对应输出结果。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例处理：批量处理不同的用例模块文件：执行不同的用例模块文件，输出用例执行结果。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"用例统计：统计用例执行的数据：统计执行用例数量、通过用例数量、失败用例数量、失败用例编号。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试报告：结合以上全部内容输出本地文档，方便测试结果归档保存。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"启动测试模块run_repor",children:["启动测试模块（run_repor）",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#启动测试模块run_repor",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该模块为执行测试的主模块，主要是对测试开始前环境做初始化并运行测试，主要包含："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"模块初始化：导入方法模块；根据对用例模块文件的分析，导入对应的模块文件。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"变量初始化：针对一些数据统计相关的函数做初始化赋值：用例数量、用例通过/失败数量、定义数组变量等。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"运行测试：调用测试执行函数、测试报告生成函数、提示用户测试报告生成路径。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"关键技术",children:["关键技术",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#关键技术",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		这里主要选取部分关键功能的设计与实现做说明："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试用例"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"初始化"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"断言"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"执行测试"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试报告"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"测试用例文件功能",children:["测试用例文件功能",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试用例文件功能",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		测试用例文件为管理用户用例的最小单位，每次测试至少包含1份测试用例文件，即可开始正常测试。可放入的测试文件数量无上限，可无限累加。"}),"\n",(0,r.jsx)(e.p,{children:'​		查看测试人员A的用例模块文件 "case_a.sh" 部分内容：'}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'#! /bin/bash\n# 文件：case_a.sh\n# 说明：基础镜像自动化测试用例\n# 作者：黄海针\n# 日期：2020/08/16\n\n\n# 测试人员A的第一条用例\ntest_a1(){\n	\n    title="检查内核启动信息"   # 用例标题\n	case_id=12170			# 用例编号\n    a="error|fail|warning|call\\ trace"  # 用例执行命令结果\n    b=`sudo dmesg`						# 用例预期结果\n    assertNoIn "${a}" "${b}"  			# 断言比较用例执行情况，若b中不包含a则通过\n\n}\n\n# 测试人员A的第二条用例\ntest_a2(){\n\n	pass\n\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		通过以上代码可看出，用例函数中包含："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"执行用例信息：用例标题、用例编号"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"命令执行结果"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"命令执行预期结果"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"断言判断结果"}),"\n",(0,r.jsxs)(e.p,{children:["完成该条用例的测试后，针对用例末尾的",(0,r.jsx)(e.code,{children:"assert"}),"类断言函数内部，做了特殊处理，可以收集以上所有数据为最终的测试报告提供数据支撑。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"初始化功能",children:["初始化功能",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初始化功能",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该功能是为后续测试提供良好的运行环境，以下为初始化函数代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'# 初始化函数\nsetup(){\n\n	if [ "`whoami`" != "root" ]\n	then\n		read -p "请以root用户运行该脚本，点击Enter退出" end\n		exit\n	fi\n	source ./method/assertion.sh   # 导入模块\n	source ./method/other.sh\n	\n	# 变量初始化\n	fail=0\n	pass=0\n	total=0\n	declare -a fail_id\n	user_list=(a b c) # 测试用户组：a=黄海针 b=禄烨 c=蔡恒强\n	\n    # ----------独立区域-----------\n	# 黄海针环境初始化\n	setup_a\n	\n	# 蔡恒强环境初始化\n	# 暂无\n\n	# 禄烨环境初始化\n	# 暂无\n	# ----------------------------\n	\n	# 用例导入\n	for i in ${user_list[*]};do\n		if test -f ${PWD}/case/case_${i}.sh\n		then\n			source ${PWD}/case/case_${i}.sh\n			eval num_${i}="`cat ${PWD}/case/case_${i}.sh|grep ^test_${i}|wc -l`"\n		else\n			eval num_${i}=0\n		fi\n	done\n\n}\n\n# 环境清理函数\nteardown(){\n\n    # ----------独立区域-----------\n	# 黄海针环境清理\n	teardown_a\n	\n	# 蔡恒强环境清理\n	# 暂无\n\n	# 禄烨环境清理\n	# 暂无\n	# ----------------------------\n\n	# 用例执行情况：整体返回值\n	if [ "${fail}" == "0" ];then\n		exit 0\n	else\n		exit 1\n	fi\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		通过代码分析，初始化/清理环境函数设计内容及流程："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试开始前执行初始化函数，为后续测试提供环境支持"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["公共区域：针对框架本身的初始化","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"判断用户执行测试时是否是root用户，因为部分系统命令需要root权限，若非root用户则提示用户并退出"}),"\n",(0,r.jsx)(e.li,{children:"导入公共函数文件，提供公共函数的调用"}),"\n",(0,r.jsx)(e.li,{children:"初始化变量（变量赋值、定义变量类型），为最终的测试报告提供数据支撑"}),"\n",(0,r.jsx)(e.li,{children:"扫描测试用例文件，收集数据（包含多少份文件、每份文件包含多少条用例），为最终的测试报告提供数据支撑"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.li,{children:"独立区域：针对各测试人员，存放各自独立维护的初始化函数（比如测试人员a的，初始化函数：setup_a）"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试结束后执行环境清理函数"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"公共区域：针对框架本身的环境清理"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"清理/释放测试过程中生成的垃圾文件或资源占用（该内容暂时缺失，因示例中用例暂未涉及）"}),"\n",(0,r.jsx)(e.li,{children:"根据用例执行情况返回状态：用例均为pass返回0，用例存在fail返回1，后期可配合CI/CD使用"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"独立区域：针对各测试人员，存放各自独立维护的清理函数（比如测试人员a的，环境清理函数：teardown_a）"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"断言功能",children:["断言功能",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#断言功能",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该功能实现的是在每条用例执行之后，对用例执行结果与预期结果对比，判断用例执行结果（通过/失败），并且对结果进行输出与数据收集。"}),"\n",(0,r.jsx)(e.p,{children:"​		断言对比的方法多种多样，这里拿部分举例，详情见下方代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'# assertEqual ${1}等于${2}则为true\nassertEqual(){\n\n	if [ "${1}" = "${2}" ]\n    then\n        r="pass"\n    else\n        r="fail"\n		fail_id[${fail}]=${case_id} # 处理失败用例\n    fi\n	case_pf # 数据处理函数调用\n	\n}\n\n# assertNoIn ${1}不在${2}中则为true\nassertNoIn(){\n\n    result=`echo "${2}"|grep -E "${1}"`\n    if [ "${result}" ]\n    then\n        r="fail"\n		fail_id[${fail}]=${case_id}\n    else\n        r="pass"\n    fi\n	case_pf\n	\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		通过代码分析，初始化设计内容及流程："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"通过判断用例的执行结果与预期结果是否一致"}),"\n",(0,r.jsx)(e.li,{children:"判断输出结果，通过输出pass，失败输出fail（如底部截图）"}),"\n",(0,r.jsx)(e.li,{children:"针对fail的用例id至数组变量，便于在拿到测试报告后验证复盘"}),"\n",(0,r.jsxs)(e.li,{children:["代码末尾的",(0,r.jsx)(e.code,{children:"case_pf"}),"函数针对以上所有数据做了数据处理与收集（递增通过/失败/执行用例数量），为最终的测试报告提供数据支撑"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E5%AF%B9PMS%E7%94%A8%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E7%A8%8BCSV%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A_assets//3.png",alt:"3"})}),"\n",(0,r.jsxs)(e.h4,{id:"测试执行功能",children:["测试执行功能",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试执行功能",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该功能主要是实现不同用例模块中，用例的批量执行："}),"\n",(0,r.jsx)(e.p,{children:"​		具体代码如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'# 执行测试\ntest_start(){\n\n	t_start=$(date +"%m%d%H%M%S")\n	report="report_${t_start}" && report_path=./report/${report} && touch ${report_path}  # 初始化测试报告文件\n	echo "_____________________________________________________________________________" >>  ${report_path} && cat ${report_path}\n	echo "" >>  ${report_path} && cat ${report_path}| tail -1\n	echo " # 测试开始 #" >>  ${report_path} && cat ${report_path}| tail -1\n	echo " # 测试人员A：本轮测试，用例数量：${num_a}条 #" >>  ${report_path} && cat ${report_path}| tail -1\n	echo " # 测试人员B：本轮测试，用例数量：${num_b}条 #" >>  ${report_path} && cat ${report_path}| tail -1\n	echo " # 测试人员C：本轮测试，用例数量：${num_c}条 #" >>  ${report_path} && cat ${report_path}| tail -1\n	echo "_____________________________________________________________________________" >>  ${report_path} && cat ${report_path}| tail -1\n	echo "" >>  ${report_path} && cat ${report_path}| tail -1\n	printf "%-20s %-20s%20s\\n" 用例ID 执行结果 用例标题 >> ${report_path} && cat ${report_path}| tail -1\n\n	if [ "${num_a}" != "0" ]\n	then\n		for i in `seq 1 ${num_a}`  # 批量执行测试人员A用例\n		do\n			test_a${i}\n			test_result;sleep 1\n		done\n	fi\n	\n	if [ "${num_b}" != "0" ]\n	then\n		for i in `seq 1 ${num_b}`  # 批量执行测试人员B用例\n		do\n			test_b${i}\n			test_result;sleep 1\n		done\n	fi\n	\n	if [ "${num_c}" != "0" ]\n	then\n		for i in `seq 1 ${num_c}`  # 批量执行测试人员C用例\n		do\n			test_c${i}\n			test_result;sleep 1\n		done\n	fi\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		通过代码可看出，这里除了实现用例的批量执行外，还包含了一些其他设计："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"获取测试开始时间"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"初始化测试报告文件（创建、命名、赋值路径）"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"针对测试结果输出做了双向处理：输出至终端、输出至本地测试报告文件"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"针对测试结果的输出样式做了排版，使之更为美观"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"展示即将测试的用例数据（如底部截图）"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"依次执行每个测试文件中的用例"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["执行用例中",(0,r.jsx)(e.code,{children:"test_result"}),"函数是处理用例执行结果，使之格式化输出"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E5%AF%B9PMS%E7%94%A8%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E7%A8%8BCSV%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A_assets//1.png",alt:"1"})}),"\n",(0,r.jsxs)(e.h4,{id:"测试报告功能",children:["测试报告功能",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#测试报告功能",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"​		该功能主要实现测试结果的展示，通过分析测试结果获取失败用例信息，验证并提交Bug。同时还有一个重要作用是针对这次测试结果做归档，便于在不同时间查看本次测试结果，具体实现代码如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-shell",children:'# 测试报告统计通过、失败用例数量\ncase_pf(){\n\n	if [ "${r}" == "pass" ]\n	then\n		let pass+=1\n	elif [ "${r}" == "fail" ]\n	then\n		let fail+=1\n	fi\n	let total+=1\n\n}\n\n# 输出用例结果,并对结果进行格式化排版\ntest_result(){\n\n	printf "%-20s %-20s %-20s\\n" ${case_id} ${r} ${title} >> ${report_path} && cat ${report_path}| tail -1\n\n}\n\n# 测试报告结束\ntest_report(){\n	t_end=$(date +"%m%d%H%M%S")  # 获取测试结束时间\n	echo "_____________________________________________________________________________" >>  ${report_path} && cat ${report_path}| tail -1\n	echo "" >>  ${report_path} && cat ${report_path}| tail -1\n	echo "测试开始时间：${t_start}" >> ${report_path}    # 依次输出各关键信息\n	echo "测试结束时间：${t_end}" >> ${report_path}	\n	echo "测试电脑架构：`uname -m`" >> ${report_path}\n	echo "执行用例合计：${total}" >> ${report_path}\n	echo "用例通过数量：${pass}" >> ${report_path}\n	echo "用例失败数量：${fail}" >> ${report_path}\n	echo "失败用例ID：${fail_id[*]}" >> ${report_path}\n	cat ${report_path} | tail -7\n	echo "_____________________________________________________________________________" >>  ${report_path} && cat ${report_path}| tail -1\n\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"​		通过分析代码，该功能工作流程为："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["通过辅助函数",(0,r.jsx)(e.code,{children:"case_pf"}),"、",(0,r.jsx)(e.code,{children:"test_result"}),"分散在测试过程中关键位置，收集测试过程中产生的关键数据"]}),"\n",(0,r.jsx)(e.li,{children:"获取测试结束时间"}),"\n",(0,r.jsx)(e.li,{children:"通过测试过程中收集到的数据，汇总整理成结果呈现给用户（如底部截图）"}),"\n",(0,r.jsx)(e.li,{children:"测试结果同样双向输出至：终端、本地测试报告文件"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E5%AF%B9PMS%E7%94%A8%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E7%A8%8BCSV%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A_assets//report.png",alt:"report"})}),"\n",(0,r.jsxs)(e.h2,{id:"实验验证",children:["实验验证",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实验验证",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"现状与方案初步对比",children:["现状与方案初步对比",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#现状与方案初步对比",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"手工执行模拟："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["执行步骤1：命令行中输入命令",(0,r.jsx)(e.code,{children:"touch /opt/test2.txt"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤1：查看步骤1输出结果，验证结果与用例中预期是否一致"}),"\n",(0,r.jsxs)(e.li,{children:["执行步骤2：命令行中输入命令",(0,r.jsx)(e.code,{children:"stat /opt/test2.txt"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤2：查看步骤2输出结果，验证结果与用例中预期是否一致"}),"\n",(0,r.jsxs)(e.li,{children:["执行步骤3：命令行中输入命令",(0,r.jsx)(e.code,{children:"cat /opt/test2.txt"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤3：查看步骤3输出结果，验证结果与用例中预期是否一致"}),"\n",(0,r.jsxs)(e.li,{children:["执行步骤4：命令行中输入命令",(0,r.jsx)(e.code,{children:"ls -l"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤4：查看步骤3输出结果，验证结果与用例中预期是否一致"}),"\n",(0,r.jsxs)(e.li,{children:["执行步骤5：命令行中输入命令",(0,r.jsx)(e.code,{children:"touch /opt/test2.txt"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤5：查看步骤3输出结果，验证结果与用例中预期是否一致"}),"\n",(0,r.jsxs)(e.li,{children:["执行步骤6：命令行中输入命令",(0,r.jsx)(e.code,{children:"ls -l"})]}),"\n",(0,r.jsx)(e.li,{children:"验证步骤6：查看步骤3输出结果，验证结果与用例中预期是否一致"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"通过手工执行以上用例，大致估算完成每个步骤（输入命令、验证结果、用户思考）的耗时为10秒，那么执行完这条用例需要的耗时为==60==秒。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"自动化执行模拟"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E5%AF%B9PMS%E7%94%A8%E4%BE%8B%E6%95%B0%E6%8D%AE%E6%A3%80%E6%9F%A5%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E7%A8%8BCSV%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E6%B3%95%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A_assets//%E8%80%97%E6%97%B6%E8%AE%A1%E7%AE%97.png",alt:"耗时计算"})}),"\n",(0,r.jsx)(e.p,{children:"​		通过上面的例子可看出，测试人员手工执行耗时==60秒==的用例，若通过自动化执行该条用例，耗时只需要==6豪秒==（后续按0.01秒算），A类用例有283条，假设每条用例的平均耗时为60秒，那么执行耗时对比如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"手动执行耗时：283*60=16980秒\n自动化执行耗时：283*0.01=2.83秒\n"})}),"\n",(0,r.jsx)(e.p,{children:"​		通过差异数据对比，可看出A类用例从手工转化为自动化后可大量提升执行效率，相比手动执行耗时的==16980秒==，自动化执行耗时的==2.83秒==可忽略不计。"}),"\n",(0,r.jsx)(e.p,{children:"​		完整的全量测试流程中耗时分布大致为："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"执行全测试用例：占比60%（按平时测试经验，A类用例与B类用例，执行耗时占比大致为1:4）"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"分析失败用例，提交Bug单：占比15%"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"验证异常情况:5%"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"发散交互性测试:10%"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"回归Bug，针对Bug进行边缘测试，处理Bug单:10%"}),"\n",(0,r.jsx)(e.p,{children:"​	计算效率提升率："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"A类用例与B类用例耗时比例*全测试用例耗时占比 = 效率提升率\n\n实际计算：\n（1/4）*0.6 = 15%\n"})}),"\n",(0,r.jsx)(e.p,{children:"结合以上数据，可得出结论实现自动化技术后，每次全量测试，==A类用例部分==执行耗时可比之前手工测试提升效率==15%==，且能够较好解决当前面临的问题。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"模拟一次完整测试",children:["模拟一次完整测试",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模拟一次完整测试",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["​		为了演示",(0,r.jsx)(e.code,{children:"SAT"}),"的工作流程，这里拿一个实际场景举例，本次测试需要自动化执行：测试人员A的用例5条、测试人员B的用例1条，无需执行测试人员C的用例："]}),"\n",(0,r.jsxs)(e.p,{children:["​		",(0,r.jsx)(e.strong,{children:"执行流程如下："})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["收集测试人员A、测试人员B最新的测试用例文件，放入目录",(0,r.jsx)(e.code,{children:"SAT/case/"}),"下"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:["SAT目录下启动终端，运行命令",(0,r.jsx)(e.code,{children:"su"}),"进入Root"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"因部分命令需要root权限，使用sudo+命令需要提示用户输入密码，不友好。"}),"\n",(0,r.jsxs)(e.li,{children:["若用户使用普通用户权限运行，则给出对应提示：",(0,r.jsx)(e.code,{children:"请已root用户运行该脚本，点击Enter退出"}),"，并关闭。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"初始化环境：导入依赖文件、扫描测试用例文件并分析数据、变量初始化赋值/定义"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"终端输出即将测试的内容"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"开始测试并输出每条测试用例的执行结果"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"所有用例执行完毕，整理测试过程中获取的数据"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"生成测试报告：测试起止时间、电脑架构、执行用例数量、通过/失败用例数量、失败用例编号、本地测试报告存放路径"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"根据测试报告中失败用例编号，验证复盘并提交BUG单"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"测试完成"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["​		",(0,r.jsx)(e.strong,{children:"输出结果如下："})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"_____________________________________________________________________________\n\n # 测试开始 #\n # 测试人员A：本轮测试，用例数量：5条 #\n # 测试人员B：本轮测试，用例数量：1条 #\n # 测试人员C：本轮测试，用例数量：0条 #\n_____________________________________________________________________________\n\n用例ID              执行结果                用例标题\n121772               pass                 检查内核信息与版本号\n12170                fail                 检查内核启动信息\n121769               pass                 验证perl环境    \n121768               pass                 验证python环境  \n121766               pass                 验证系统预装软件包状态\n12119                fail                 创建test文件夹 \n_____________________________________________________________________________\n\n测试开始时间：0818102422\n测试结束时间：0818102428\n测试电脑架构：x86_64\n执行用例合计：6\n用例通过数量：5\n用例失败数量：2\n失败用例ID：12170 12119\n_____________________________________________________________________________\n\n#  测试完毕，测试报告生成在'./report'目录，点击Enter退出！ #\n\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"依赖库相关信息",children:["依赖库相关信息",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#依赖库相关信息",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{align:"center",children:"库名称"}),"\n",(0,r.jsx)(e.th,{align:"center",children:"版本号"}),"\n",(0,r.jsx)(e.th,{align:"center",children:"描述"}),"\n",(0,r.jsx)(e.th,{align:"center",children:"所使用开源协议"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"暂无"}),"\n",(0,r.jsx)(e.td,{align:"center"}),"\n",(0,r.jsx)(e.td,{align:"center"}),"\n",(0,r.jsx)(e.td,{align:"center"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"实验代码存放地址",children:["实验代码存放地址",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#实验代码存放地址",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://gitlabcd.uniontech.com/ut000827/sat",target:"_blank",rel:"noopener noreferrer",children:"gitlab"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"小结",children:["小结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小结",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["​		",(0,r.jsx)(e.code,{children:"SAT"}),"实现的自动化测试，通过",(0,r.jsx)(e.strong,{children:"实验验证"}),"部分得出的结论，可看出每次全量测试，A类用例部分执行部分效率可提高15%。而且每次回归测试时，除了Bug回归和边缘测试，也可以自动化执行一次A类用例，就用例覆盖面来说提升了54.73%。同时解决了当前所面临的问题："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"手工测试时针对A类用例时，繁琐的输入、验证"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"覆盖多个架构测试时，大量的重复性工作"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["​		除此之外",(0,r.jsx)(e.code,{children:"SAT"}),"是自行设计的，有较高的扩展性，可根据后续项目的变动对框架内容作出对应调整（优化、新增功能），而且框架是通用的，不同项目间也可以同时使用，只要按照约定编写测试用例代码，把用例文件放在在",(0,r.jsx)(e.code,{children:"SAT/case/"}),"目录下，即可运行测试。"]}),"\n",(0,r.jsxs)(e.p,{children:["​		再往后说，随着",(0,r.jsx)(e.code,{children:"SAT"}),"内容越来越丰富，创新性越来越多时，可把该方案转换为对应的创新性发明专利。"]}),"\n",(0,r.jsxs)(e.h2,{id:"参考资料",children:["参考资料",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#参考资料",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"http://manual.51yip.com/shell/",target:"_blank",rel:"noopener noreferrer",children:"Linux Shell编程"})}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.a,{href:"https://baike.baidu.com/item/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6/6170164?fr=aladdin",target:"_blank",rel:"noopener noreferrer",children:"自动化测试框架"})}),"\n"]}),"\n"]})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,_.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let h=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["tech_doc%2F%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%2F%E3%80%8A%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%94%A8%E4%BE%8B%E8%BD%AC%E6%8D%A2%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E3%80%8B%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A.md"]={toc:[{text:"相关术语",id:"相关术语",depth:2},{text:"问题",id:"问题",depth:2},{text:"现状",id:"现状",depth:2},{text:"技术方案",id:"技术方案",depth:2},{text:"整体设计",id:"整体设计",depth:3},{text:"用例模块（case）",id:"用例模块case",depth:4},{text:"方法封装模块（method）",id:"方法封装模块method",depth:4},{text:"启动测试模块（run_repor）",id:"启动测试模块run_repor",depth:4},{text:"关键技术",id:"关键技术",depth:3},{text:"测试用例文件功能",id:"测试用例文件功能",depth:4},{text:"初始化功能",id:"初始化功能",depth:4},{text:"断言功能",id:"断言功能",depth:4},{text:"测试执行功能",id:"测试执行功能",depth:4},{text:"测试报告功能",id:"测试报告功能",depth:4},{text:"实验验证",id:"实验验证",depth:2},{text:"现状与方案初步对比",id:"现状与方案初步对比",depth:3},{text:"模拟一次完整测试",id:"模拟一次完整测试",depth:3},{text:"依赖库相关信息",id:"依赖库相关信息",depth:3},{text:"实验代码存放地址",id:"实验代码存放地址",depth:3},{text:"小结",id:"小结",depth:2},{text:"参考资料",id:"参考资料",depth:2}],title:"命令行用例转换自动化测试调研",headingTitle:"命令行用例转换自动化测试调研",frontmatter:{Author:"海针"}}}}]);