"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["7255"],{1191:function(e,n,d){d.r(n),d.d(n,{default:()=>s});var r=d(2676),c=d(453);function i(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",h3:"h3",ul:"ul",li:"li",h4:"h4",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",hr:"hr",h5:"h5",img:"img",pre:"pre",ol:"ol"},(0,c.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"域管自动化测试技术调研",children:["域管自动化测试技术调研",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#域管自动化测试技术调研",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"现状问题",children:["现状问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#现状问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["域管产品主要分为服务端和客户端，服务端为一个后台服务 ",(0,r.jsx)(n.code,{children:"Web"})," 平台系统，客户端为分布的 ",(0,r.jsx)(n.code,{children:"UOS"})," 机器。"]}),"\n",(0,r.jsx)(n.p,{children:"域管测试用例中，大量的用例会涉及到服务端和客户端协同操作。"}),"\n",(0,r.jsxs)(n.h3,{id:"服务端方面",children:["服务端方面",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#服务端方面",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["现有域管 ",(0,r.jsx)(n.code,{children:"AT"})," 主要实现为单接口自动化测试，这类自动化测试相对简单，主要校验接口的入参和返回，但较多业务场景是复合接口的，由于没有可用的 ",(0,r.jsx)(n.code,{children:"API"})," 接口文档，导致很多场景没办法做接口自动化。"]}),"\n",(0,r.jsxs)(n.p,{children:["因此经过评估，服务端复合接口场景的测试，将基于 ",(0,r.jsx)(n.code,{children:"Web UI"})," 自动化实现。"]}),"\n",(0,r.jsxs)(n.h3,{id:"客户端方面",children:["客户端方面",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#客户端方面",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["客户端为分布式的安装 ",(0,r.jsx)(n.code,{children:"UOS"})," 系统的机器，现有的域管 ",(0,r.jsx)(n.code,{children:"AT"})," 只能通过 ",(0,r.jsx)(n.code,{children:"SSH"})," 的方式控制客户端做一些简单的命令行操作，比较局限，无法实现控制客户端做一些复杂的 ",(0,r.jsx)(n.code,{children:"UI"})," 功能上的操作。"]}),"\n",(0,r.jsxs)(n.h2,{id:"要实现的效果",children:["要实现的效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#要实现的效果",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"基于以上现有问题，域管自动化测试我们希望最终实现的效果是："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["能控制服务端 ",(0,r.jsx)(n.code,{children:"Web"})," 平台做复杂的 ",(0,r.jsx)(n.code,{children:"UI"})," 功能操作，最好能直接驱动系统自带的浏览器进行测试；"]}),"\n",(0,r.jsxs)(n.li,{children:["能远程控制客户端，既能做简单的命令行的操作，也能做复杂的 ",(0,r.jsx)(n.code,{children:"UI"})," 功能操作。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"技术方案",children:["技术方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#技术方案",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["域管用例涉及服务端和客户端穿插操作，底层功能实现大体也会分为两部分：",(0,r.jsx)(n.code,{children:"Server（服务端）"}),"、",(0,r.jsx)(n.code,{children:"Client（客户端）"}),"。"]}),"\n",(0,r.jsxs)(n.h3,{id:"server服务端",children:["Server（服务端）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#server服务端",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["基于 ",(0,r.jsx)(n.code,{children:"Web UI"})," 自动化测试，控制浏览器进行用例执行。",(0,r.jsx)(n.code,{children:"YouQu"})," 目前还没有接入 ",(0,r.jsx)(n.code,{children:"Web UI"})," 测试功能，要接入此功能需要先对工具进行选型。"]}),"\n",(0,r.jsxs)(n.h4,{id:"工具调研",children:["工具调研",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#工具调研",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["市面上耳熟能详的可用于 ",(0,r.jsx)(n.code,{children:"Web UI"})," 自动化测试工具：",(0,r.jsx)(n.code,{children:"Selenium"}),"、",(0,r.jsx)(n.code,{children:"Cypress"}),"、",(0,r.jsx)(n.code,{children:"Puppeteer"}),"、",(0,r.jsx)(n.code,{children:"Playwright"}),"；"]}),"\n",(0,r.jsx)(n.p,{children:"咱们先初步排除掉一些明显不用的："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Cypress"}),"，只支持 ",(0,r.jsx)(n.code,{children:"JavaScript"}),"，而我们自动化人员大多使用 ",(0,r.jsx)(n.code,{children:"Python"})," 对 ",(0,r.jsx)(n.code,{children:" JavaScript"})," 不熟悉，排除。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Puppeteer"}),"，只支持谷歌浏览器，格局没打开，官方不支持 ",(0,r.jsx)(n.code,{children:"Python"}),"，排除。"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["剩下 ",(0,r.jsx)(n.code,{children:"Selenium"}),"、",(0,r.jsx)(n.code,{children:"Playwright"}),"，我们从一些方面做对比："]}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{align:"left",children:"对比指标"}),"\n",(0,r.jsx)(n.th,{align:"center",children:"Selenium"}),"\n",(0,r.jsx)(n.th,{align:"center",children:"Playwright"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"环境安装难度"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"运行速度"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"元素等待"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"智能定位"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"稳定性"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"文档"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{align:"left",children:"接口测试"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✗"}),"\n",(0,r.jsx)(n.td,{align:"center",children:"✔"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"总结："}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"Playwright"})," 作为一个比较新的工具，在文档方便确实没有老牌的 ",(0,r.jsx)(n.code,{children:"Selenium"})," 完善，特别是一些示例、方法的使用说明，都还不够好，甚至有些就没有说明，但基本的使用该有的都有。"]}),"\n",(0,r.jsxs)(n.p,{children:["除了文档方面，",(0,r.jsx)(n.code,{children:"Playwright"})," 几乎在各方面碾压 ",(0,r.jsx)(n.code,{children:"Selenium"}),"，很明显 ",(0,r.jsx)(n.code,{children:"Playwright"})," 以绝对优势获胜。"]}),"\n",(0,r.jsxs)(n.h4,{id:"设计思路",children:["设计思路",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计思路",children:"#"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h5,{id:"浏览器对象",children:["浏览器对象",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器对象",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"YouQu"})," 框架提供灵活可配置的浏览器对象。"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["提供一个全局默认的对象：",(0,r.jsx)(n.code,{children:"page"}),"，默认使用系统自带的浏览器进行测试，如果需要指定其他第三方的浏览器，提供配置项可以指定浏览器对应的路径。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["还需要提供一个对象：",(0,r.jsx)(n.code,{children:"native_page"}),"，它使用 ",(0,r.jsx)(n.code,{children:"Playwright"})," 最新的 ",(0,r.jsx)(n.code,{children:"Chromium"})," 浏览器进行测试。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"方法层",children:["方法层",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法层",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["方法层按照 ",(0,r.jsx)(n.a,{href:"http://youqu.uniontech.com/docs/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%8A%80%E6%9C%AF/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%80%9D%E6%83%B3%E7%90%86%E5%BF%B5/PageObjects.html",target:"_blank",rel:"noopener noreferrer",children:"PO"})," 设计思想对域管 Web 平台进行封装。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"/%E5%9F%9F%E7%AE%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94_asset/1.png",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"目录结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"server\n├── __init__.py\n├── pages\n│\xa0\xa0 ├── _base_page.py  # 基类\n│\xa0\xa0 ├── home_page.py   # 首页类\n│\xa0\xa0 ├── audit_page.py  # 审计页面类\n│\xa0\xa0 ├── ...            # 其他页面类\n│\xa0\xa0 └── __init__.py\n└── udcp_page.py       # 方法层统一出口\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"基类负责处理通用页面行为；"}),"\n",(0,r.jsx)(n.li,{children:"首页、终端、审计等其他页面类，封装各自页面的元素定位和操作方法；"}),"\n",(0,r.jsx)(n.li,{children:"方法唯一出口用于集成所有的页面类，统一出口提供给上层用例调用。"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"断言方法",children:["断言方法",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#断言方法",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"YouQu"})," 框架统一提供断言语句，以保持统一的断言语句风格。"]}),"\n",(0,r.jsxs)(n.h3,{id:"client客户端",children:["Client（客户端）",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#client客户端",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["客户端要求能远程控制客户端，既能做简单的命令行的操作，也能做复杂的 ",(0,r.jsx)(n.code,{children:"UI"})," 功能操作。"]}),"\n",(0,r.jsxs)(n.h4,{id:"设计思路-1",children:["设计思路",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#设计思路-1",children:"#"})]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)(n.h5,{id:"通讯协议",children:["通讯协议",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通讯协议",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"域管客户端部署 YouQu 框架环境，并将 YouQu 框架底层能力注册到 RPC 服务，自动化用例执行端作为 RPC 客户端，在自动化用例执行过程中即可通过 RPC 协议远程调用域管客户端进行操作。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://pic.imgdb.cn/item/64f054c3661c6c8e54ff47b5.png",alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["注意，这里的域管客户端是作为 ",(0,r.jsx)(n.code,{children:"RPC"})," 的服务端，而域管的服务端是自动化脚本执行端，是作为 ",(0,r.jsx)(n.code,{children:"RPC"})," 的客户端。"]}),"\n",(0,r.jsxs)(n.h5,{id:"方法层-1",children:["方法层",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#方法层-1",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"域管客户端的操作有特殊性，其在客户端的操作大多是针对有些应用的，比如打开、关闭某个应用，不像应用的操作对象一般就是应用本身。"}),"\n",(0,r.jsx)(n.p,{children:"因此，域管客户端方法层设计和应用的方法层设计也有区别，需要因地制宜。"}),"\n",(0,r.jsx)(n.p,{children:"目录结构："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-shell",children:"client\n├── __init__.py\n├── udcp_widget.py                 # 方法层统一出口\n└── widget\n    ├── base_widget.py             # 基类\n    ├── dde_dock_widget.py         # 任务栏的操作\n    ├── dde_file_manager_widget.py # 文管的操作\n    ├── deepin_music_widget.py     # 音乐的操作\n    ├── ....                       # 其他应用\n    └── __init__.py\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"基类处理一些通用的操作行为；"}),"\n",(0,r.jsx)(n.li,{children:"以应用维度划分方法类，对哪个应用的操作就封装到对应的应用类里面；"}),"\n",(0,r.jsx)(n.li,{children:"方法层统一出口继承所有的应用类操作，统一出口提供给上层用例调用。"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"客户端信息",children:["客户端信息",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#客户端信息",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["客户端信息支持命令行入参或配置文件传入远程机器的 ",(0,r.jsx)(n.code,{children:"user"}),"、",(0,r.jsx)(n.code,{children:"ip"}),"、",(0,r.jsx)(n.code,{children:"password"})," 信息；"]}),"\n",(0,r.jsxs)(n.p,{children:["用例中通过框架提供的 ",(0,r.jsx)(n.code,{children:"fixture"})," 对象：",(0,r.jsx)(n.code,{children:"slaves"})," 获取数据，供用例层使用。"]}),"\n",(0,r.jsxs)(n.h3,{id:"隐藏的宝石",children:["隐藏的宝石",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#隐藏的宝石",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"1rpc-服务注册的问题",children:["（1）RPC 服务注册的问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1rpc-服务注册的问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["常规的 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务注册只能按照函数一个个显示的注册，也就是说如果要将 ",(0,r.jsx)(n.code,{children:"YouQu"})," 所有底层能力全部释放出来，需要将 ",(0,r.jsx)(n.code,{children:"YouQu"})," 所有提供的方法单独做封装，然后逐个注册进 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务。"]}),"\n",(0,r.jsx)(n.p,{children:"这也是业内常用的方案，但是，这样功能很不好。"}),"\n",(0,r.jsxs)(n.p,{children:["因为 ",(0,r.jsx)(n.code,{children:"YouQu"})," 底层代码全是面向对象（基于类）的编程，如果全部单独封装成函数，是一个非常巨大的工作量，而且在后续底层新增修改功能后，又要对注册到 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务里面的代码进行修改；"]}),"\n",(0,r.jsxs)(n.p,{children:["所以我们不想要这样的 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务功能，而是希望利用好 ",(0,r.jsx)(n.code,{children:"YouQu"})," 优秀的框架设计，能通过将 ",(0,r.jsx)(n.code,{children:"YouQu"})," 底层统一的功能出口 ",(0,r.jsx)(n.code,{children:"src.Src"})," 一次性注册到 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务里面，这样后续 ",(0,r.jsx)(n.code,{children:"YouQu"})," 框架在迭代可以随意新增或修改，远程控制 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务也不用做任何修改。"]}),"\n",(0,r.jsxs)(n.h5,{id:"解决方案",children:["解决方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决方案",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["使用 ",(0,r.jsx)(n.code,{children:"zerorpc"})," 实现 ",(0,r.jsx)(n.code,{children:"RPC"})," ，将 ",(0,r.jsx)(n.code,{children:"YouQu"})," 的 ",(0,r.jsx)(n.code,{children:"Src"})," 对象注册到 ",(0,r.jsx)(n.code,{children:"zerorpc"})," 的服务 ",(0,r.jsx)(n.code,{children:"API"}),"  ",(0,r.jsx)(n.code,{children:"zeroservices"})," 里面，提供 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务。"]}),"\n",(0,r.jsxs)(n.p,{children:["从而实现零注册及维护量的 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务。"]}),"\n",(0,r.jsxs)(n.h4,{id:"2代码补全的问题",children:["（2）代码补全的问题",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2代码补全的问题",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["域管客户端基于 ",(0,r.jsx)(n.code,{children:"RPC"})," 实现的思路存在一个使用体验的问题，就是编写操作方法调用远程函数，在编辑器里面无法做代码补全，也不能追踪代码，使用者必须完整输入要调用的方法名称。"]}),"\n",(0,r.jsx)(n.p,{children:"这对于开发者来说就是，也不是不能用，但是差点儿意思。"}),"\n",(0,r.jsx)(n.p,{children:"因此，我们希望远程控制也能实现编辑器代码补全、代码追踪。"}),"\n",(0,r.jsxs)(n.h5,{id:"解决方案-1",children:["解决方案",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决方案-1",children:"#"})]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"远程对象返回进行类型注解，解决通过远程对象调用远程方法时可以进行代码补全和代码追踪；"}),"\n",(0,r.jsx)(n.li,{children:"远程方法类里面将 YouQu 各底层类继承过来，通过属性拦截器进行特殊处理，先将方法从父类中移除，然后将方法调用传递给远程 RPC 对象，使得方法层在编写方法时，可以直接调用本地方法，但实际通过属性拦截器转换到远程对象进行调用，从而实现和本地调用相同编程体验，调用逻辑、代码维护也更加优雅简介。"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["基于以上的实现思路，我们可以实现域管自动化测试的目标。通过使用 ",(0,r.jsx)(n.code,{children:"Playwright"})," 实现服务端的 ",(0,r.jsx)(n.code,{children:"Web UI"})," 自动化测试，以及通过 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务实现客户端的远程控制，我们能够有效地模拟服务端和客户端之间的交互。"]}),"\n",(0,r.jsxs)(n.p,{children:["对于服务端，通过 ",(0,r.jsx)(n.code,{children:"YouQu"})," 框架提供的浏览器对象和方法层设计，我们可以实现对 ",(0,r.jsx)(n.code,{children:"Web"})," 平台复杂 ",(0,r.jsx)(n.code,{children:"UI"})," 功能的自动化操作。 虽然 ",(0,r.jsx)(n.code,{children:"Playwright"})," 在自动化测试圈内知名度还不高，但我们相信未来它一定能站在领域的山顶，因此我们大胆使用它，押注未来。"]}),"\n",(0,r.jsxs)(n.p,{children:["对于客户端，通过 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务的部署和远程控制，我们可以实现对远程 ",(0,r.jsx)(n.code,{children:"UOS"})," 机器上应用的自动化操作。通过应用维度的方法层设计，我们可以灵活地处理不同应用的操作，满足复杂 ",(0,r.jsx)(n.code,{children:"UI"})," 功能测试的需求。此外，通过命令行或配置文件传入客户端信息，我们可以方便地管理远程机器的测试环境。"]}),"\n",(0,r.jsxs)(n.p,{children:["虽然目前存在 ",(0,r.jsx)(n.code,{children:"RPC"})," 服务注册和代码补全的问题，但这并不影响我们基于现有思路实现域管自动化测试的目标。在后续的迭代中，我们将逐步解决这些问题，进一步提升自动化测试的体验和效果。"]}),"\n",(0,r.jsx)(n.p,{children:"总之，通过以上的实现思路，我们可以信心满满地推进域管自动化测试的工作，提高测试效率，降低人力成本，为域管产品的质量和稳定性提供有力保障。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(i,{...e})}):i(e)}let s=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["tech_doc%2F%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%2F%E5%9F%9F%E7%AE%A1%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94.md"]={toc:[{text:"现状问题",id:"现状问题",depth:2},{text:"服务端方面",id:"服务端方面",depth:3},{text:"客户端方面",id:"客户端方面",depth:3},{text:"要实现的效果",id:"要实现的效果",depth:2},{text:"技术方案",id:"技术方案",depth:2},{text:"Server（服务端）",id:"server服务端",depth:3},{text:"工具调研",id:"工具调研",depth:4},{text:"设计思路",id:"设计思路",depth:4},{text:"Client（客户端）",id:"client客户端",depth:3},{text:"设计思路",id:"设计思路-1",depth:4},{text:"隐藏的宝石",id:"隐藏的宝石",depth:3},{text:"（1）RPC 服务注册的问题",id:"1rpc-服务注册的问题",depth:4},{text:"（2）代码补全的问题",id:"2代码补全的问题",depth:4},{text:"总结",id:"总结",depth:2}],title:"域管自动化测试技术调研",headingTitle:"域管自动化测试技术调研",frontmatter:{Author:"mikigo"}}}}]);