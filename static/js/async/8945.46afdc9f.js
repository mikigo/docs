"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["8945"],{9378:function(n,e,s){s.r(e),s.d(e,{default:()=>h});var r=s(2676),i=s(453);function l(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",p:"p",h3:"h3",h4:"h4",pre:"pre",code:"code",img:"img",em:"em",hr:"hr",ol:"ol",li:"li"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"一种针对linux系统异常命令的测试方法技术交底书",children:["一种针对Linux系统异常命令的测试方法技术交底书",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#一种针对linux系统异常命令的测试方法技术交底书",children:"#"})]}),"\n",(0,r.jsxs)(e.h2,{id:"0缩略语和关键术语定义",children:[(0,r.jsx)(e.strong,{children:"0、缩略语和关键术语定义"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#0缩略语和关键术语定义",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{align:"center"}),"\n",(0,r.jsx)(e.th,{align:"center"}),"\n",(0,r.jsx)(e.th,{align:"center"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:(0,r.jsx)(e.strong,{children:"术语"})}),"\n",(0,r.jsx)(e.td,{align:"center",children:(0,r.jsx)(e.strong,{children:"全称"})}),"\n",(0,r.jsx)(e.td,{align:"center",children:(0,r.jsx)(e.strong,{children:"解释"})}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"Linux"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"GNU/Linux"}),"\n",(0,r.jsxs)(e.td,{align:"center",children:["一种免费使用和自由传播的",(0,r.jsx)(e.a,{href:"https://baike.baidu.com/item/%E7%B1%BBUNIX/9032872",target:"_blank",rel:"noopener noreferrer",children:"类UNIX"}),"操作系统。"]}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"Shell"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"Shell"}),"\n",(0,r.jsxs)(e.td,{align:"center",children:["传统意义上的Shell指的是命令行式的Shell，是操作系统最外面的一层，提供了你与操作系统之间通讯的方式，同时它又是一种",(0,r.jsx)(e.a,{href:"https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80",target:"_blank",rel:"noopener noreferrer",children:"程序设计语言"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"自动化测试框架"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"/"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{align:"center",children:"Shell状态码"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"/"}),"\n",(0,r.jsx)(e.td,{align:"center",children:"执行命令的退出状态码，可体现Shell命令执行情况。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术",children:[(0,r.jsx)(e.strong,{children:"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"在基于Linux操作系统的自动化测试中，需要使用各种Shell命令对系统进行操作并测试系统响应是否符合预期。这些命令往往都可以通过自动化测试完成，通过自动化测试框架执行转换好的测试用例，以此完成测试。"}),"\n",(0,r.jsx)(e.p,{children:"例如目前较为流行的测试框架： shUnit2 、bats 均可胜任该工作。针对 Linux 系统执行 Shell 命令后，都会有对应的返回状态码，执行成功为0，执行失败为非0。所以针对 Shell 命令的测试中，状态码在自动化测试框架中运用比较频繁，主要用于自动化测试用例的断言，例如判断执行的 Shell 命令，是否符合预期。"}),"\n",(0,r.jsx)(e.p,{children:"状态码详情可参考："}),"\n",(0,r.jsx)(e.p,{children:"表1 Shell 状态码对应详情"}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{}),"\n",(0,r.jsx)(e.th,{}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"状态码"}),"\n",(0,r.jsx)(e.td,{children:"对应情况"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"0"}),"\n",(0,r.jsx)(e.td,{children:"命令成功结束"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"1"}),"\n",(0,r.jsx)(e.td,{children:"通用未知错误"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"2"}),"\n",(0,r.jsx)(e.td,{children:"误用Shell命令"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"126"}),"\n",(0,r.jsx)(e.td,{children:"命令不可执行"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"127"}),"\n",(0,r.jsx)(e.td,{children:"没找到命令"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"128"}),"\n",(0,r.jsx)(e.td,{children:"无效退出参数"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"128+x"}),"\n",(0,r.jsx)(e.td,{children:"Linux信号x的严重错误"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"130"}),"\n",(0,r.jsx)(e.td,{children:"Linux信号2的严重错误，即命令通过SIGINT（Ctrl＋Ｃ）终止"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:"255"}),"\n",(0,r.jsx)(e.td,{children:"退出状态码越界"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"11与本发明相关的现有技术",children:[(0,r.jsx)(e.strong,{children:"1.1、与本发明相关的现有技术"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11与本发明相关的现有技术",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"111现有技术的技术方案",children:[(0,r.jsx)(e.strong,{children:"1.1.1、现有技术的技术方案"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#111现有技术的技术方案",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为了更好的说明，此时使用 Shell脚本模拟一个简单的测试场景："}),"\n",(0,r.jsx)(e.p,{children:"l 步骤：向文件testfile1插入内容“True”"}),"\n",(0,r.jsx)(e.p,{children:"l 预期1：文件testfile1中包含关键字“True”"}),"\n",(0,r.jsx)(e.p,{children:"l 预期2：文件testfile1中不包含关键字“False”"}),"\n",(0,r.jsx)(e.p,{children:"l 测试脚本内容如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#! /bin/bash \necho True> testfile1\n\necho "【场景1】grep筛选到关键字True，输出结果："\ncat testfile1 | grep True; echo -e "\\n命令执行状态：$?"\necho "___________________"\n\necho "【场景2】grep未筛选到关键字False，输出结果："\ncat testfile1 | grep False; echo -e "\\n命令执行状态：$?"\necho "___________________"\n\necho "【场景3】grep筛选关键字Fasle时文件名称输入错误，输出结果："\ncat testfile2 | grep False; echo -e "\\n命令执行状态：$?"\necho "___________________"\n'})}),"\n",(0,r.jsx)(e.p,{children:"执行以上脚本结果如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"【场景1】grep筛选到关键字，输出结果：\nTrue\n\n命令执行状态码：0\n___________________\n【场景2】grep未筛选到关键字，输出结果：\n\n命令执行状态码：1\n___________________\n【场景3】模拟场景2日志名称错误报错，输出结果：\ncat: testfile2: 没有那个文件或目录\n\n命令执行状态码：1\n"})}),"\n",(0,r.jsx)(e.p,{children:"通过以上脚本【场景1】和【场景2】命令执行结果，可以看出当工具“grep”筛选到关键字返回0，未筛选到关键字会返回1，哪怕命令是成功结束的，说明“grep”会改变系统状态码。通过【场景3】可看到命令执行失败（日志文件缺失），但最终返回状态码1，与【场景2】结果一致。"}),"\n",(0,r.jsx)(e.p,{children:"如果后续针对该场景做测试，预期结果断言为非0通过，那么【场景3】执行了错误的命令，从返回结果来看也是符合预期的，测试结果为通过。其实【场景3】最终状态码返回值与命令中包含管道“|”也存在关系，管道会对最终状态码产生影响，与“grep”都存在时，会产生双重干扰，下面用纯管道命令举例。"}),"\n",(0,r.jsx)(e.p,{children:"例如在一条测试用例中，包含以下操作步骤："}),"\n",(0,r.jsx)(e.p,{children:"l 步骤：打印文件testfile1内容，同时把内容“True”替换为“False”展示"}),"\n",(0,r.jsx)(e.p,{children:"l 测试脚本内容如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#! /bin/bash \necho True> testfile1\n\necho "【场景4】打印文件内容，并进行了数据处理，输出结果："\ncat testfile1 | sed ‘s/True/False/g’; echo -e "\\n命令执行状态：$?"\necho "___________________"\n\necho "【场景5】打印文件内容，并进行了数据处理，但文件名输入错误，输出结果："\ncat testfile2 | sed ‘s/True/False/g’; echo -e "\\n命令执行状态：$?"\necho "___________________"\n\nrm -f testfile1\n'})}),"\n",(0,r.jsx)(e.p,{children:"执行以上脚本结果如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"【场景4】打印文件内容，并进行了数据处理，输出结果：\nFalse\n命令执行状态码：0\n\n___________________\n【场景5】模拟场景4文件名称错误，输出结果：\ncat: testfile2: 没有那个文件或目录\n\n命令执行状态码：0\n"})}),"\n",(0,r.jsx)(e.p,{children:"通过【场景4】和【场景5】可以看出，当命令中包含管道“|”，状态码的返回值是以最后一个命令的返回值为准，即使管道前的命令状态码非0。所以从状态码来看，是无法识别出命令异常的，之前提到的【场景3】同理。"}),"\n",(0,r.jsx)(e.p,{children:"上述举例的情况，在实际工作中出现概率是很大的，除了人为原因代码编写错误或经验不足以外，例如依赖的工具更新/需求变更，导致命令/参数发生变化，同样会导致正常命令变为异常命令。问题看似不大，却存在巨大的质量风险，因为你不知道执行通过的用例中，有一条已经无效了，用例体量大的话，日积月累下甚至会出现很多此类情况。针对此类问题，在人工测试时很容易发现，但是在自动化测试时，市面上现有的测试框架并不能很好的发现此类问题。"}),"\n",(0,r.jsxs)(e.h3,{id:"112现有技术的缺点",children:[(0,r.jsx)(e.strong,{children:"1.1.2、现有技术的缺点"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#112现有技术的缺点",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsxs)(e.strong,{children:["1.1.2.1、",(0,r.jsx)(e.strong,{children:"shUnit2测试框架"})]})}),"\n",(0,r.jsx)(e.p,{children:"使用目前较为流行的Shell开源测试框架 shUnit2 对1.1.1章节脚本中包含的命令进行测试，测试用例如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#! /bin/sh\n# file: examples/equality_test.sh\n\noneTimeSetUp() {\n  echo True > testfile1\n}\n\n# 用例1\ntest1() {\n  assertTrue "cat testfile1 | grep True"\n}\n\n# 用例2\ntest2() {\n  assertFalse "cat testfile1 | grep False"\n}\n\n# 用例3\ntest3() {\n  assertFalse "cat testfile2 | grep False"\n}\n\n# 用例4\ntest4() {\n  assertTrue "cat testfile1 | sed ‘s/True/False/g’"\n}\n\n# 用例5\ntest5() {\n  assertTrue "cat testfile2 | sed ‘s/True/False/g’"\n}\n\n\noneTimeTearDown() {\n\n  rm -f testfile1\n}\n\n# Load and run shUnit2.\n. ../shunit2\n'})}),"\n",(0,r.jsx)(e.p,{children:"执行以上测试结果如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"test1\ntest2\ntest3\ntest4\ntest5\n\nRan 5 tests.\n\nOK\n"})}),"\n",(0,r.jsx)(e.p,{children:"通过以上执行结果可以看到5条用例全部执行通过。但是【用例3】和【用例5】的执行结果是错误的，因为testfile2这个目录并不存在，这是一条异常命令，但用例的测试结果却是通过，这显然是一个无效测试。"}),"\n",(0,r.jsx)(e.p,{children:"**1.1.2.2、**bats 测试框架"}),"\n",(0,r.jsx)(e.p,{children:"使用另外一个热门 Shell 测试框架 bats 进行测试："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#!/usr/bin/env bats\n\nsetup(){\n  echo True > testfile1\n}\n\n# 用例1\n@test "test1" {\n  run cat testfile1 | grep True\n  [ $status -eq 0  ]\n}\n\n# 用例2\n@test "test2" {\n  run cat testfile1 | grep False\n  [ $status -ne 0  ]\n}\n\n# 用例3\n@test "test3" {\n  run cat testfile2 | grep False\n  [ $status -ne 0  ]\n}\n\n# 用例4\n@test "test4" {\n  run cat testfile1 | sed ‘s/True/False/g’\n  [ $status -ne 0  ]\n}\n\n# 用例5\n@test "test5" {\n  run cat testfile2 | sed ‘s/True/False/g’\n  [ $status -ne 0  ]\n}\n\nteardown(){\n  \n  rm -f testfile1\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"执行测试结果如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:" ✗ test1                                                                                                                                   \n   (in test file test1.bats, line 11)                                                                                                          \n     `run cat testfile1 | grep True' failed                                                                                                    \n ✗ test2                                                                                                                                 \n   (in test file test1.bats, line 18)                                                                                                          \n     `run cat testfile1 | grep False' failed                                                                                                   \n ✗ test3                                                                                                                                 \n   (in test file test1.bats, line 25)                                                                                                          \n     `run cat testfile2 | grep False' failed                                                                                                   \n ✗ test4                                                                                                                                \n   (in test file test1.bats, line 32)                                                                                                          \n     `[ $status -eq 0  ]' failed with status 2                                                                                                                                                                 \n ✗ test5                                                                                                                                \n   (in test file test1.bats, line 38)                                                                                                          \n     `[ $status -eq 0  ]' failed with status 2                                                                                                  \n                                                                                                                                   \n5tests, 5 failures \n"})}),"\n",(0,r.jsx)(e.p,{children:"可以看到所有测试命令的结果均为失败，很明显测试命令中包含管道时，会影响框架对测试结果的判断，这里就限制了很多测试场景了，部分用例将命令状换后去掉管道再进行测试（用例4、用例5主要描述管道问题，由于无法使用，这里直接去掉）："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#!/usr/bin/env bats\n\nsetup(){\n  echo True > testfile1\n}\n\n# 用例1\n@test "test1" {\n  run grep True testfile1\n  [ $status -eq 0  ]\n}\n\n# 用例2\n@test "test2" {\n  run grep False testfile1\n  [ $status -ne 0  ]\n}\n\n# 用例3\n@test "test3" {\n  run grep False testfile2\n  [ $status -ne 0  ]\n}\n\nteardown(){  \n  rm -f testfile1\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"运行结果如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:" ✓ test1\n ✓ test2\n ✓ test3\n\n3 tests, 0 failures \n"})}),"\n",(0,r.jsx)(e.p,{children:"现在可以测试成功了，但是和 shUnit2 测试框架一样，用例3的测试结果同样是错误的，未识别出异常命令。而且该框架测试场景也存在一定限制，在实际测试中使用管道的场景还是很多，比如数据的多重处理、需要人机交互的命令等，所以无法满足目前测试场景中复杂的变化。"}),"\n",(0,r.jsxs)(e.h2,{id:"2本发明技术方案的详细阐述",children:[(0,r.jsx)(e.strong,{children:"2、本发明技术方案的详细阐述"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2本发明技术方案的详细阐述",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"21本发明所要解决的技术问题",children:[(0,r.jsx)(e.strong,{children:"2.1、本发明所要解决的技术问题"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#21本发明所要解决的技术问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"针对Linux系统Shell命令的测试中，为了解决上述技术问题，本发明提供了一种在自动化测试框架中执行测试命令的算法。经过该设计方法来执行测试命令，命令会在方法内部进行大量逻辑处理，重新制定状态码，快速识别异常命令并对异常命令的测试提供支撑，保留最大测试场景支持的同时，最终还能提供准确、可靠的测试结果。"}),"\n",(0,r.jsxs)(e.h3,{id:"22本发明提供的完整技术方案",children:[(0,r.jsx)(e.strong,{children:"2.2、本发明提供的完整技术方案"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#22本发明提供的完整技术方案",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"方案流程："})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpseSjIhI.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图1 运行逻辑主流程"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpsWe2fyF.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图2 运行逻辑子流程1"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpsGsUQOC.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图3 运行逻辑子流程2"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpsOE8r5z.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图4 运行逻辑子流程3"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpsQBi6lx.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图5 运行逻辑子流程4"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"准备工作："})}),"\n",(0,r.jsx)(e.p,{children:"针对需要测试的Linux命令的测试，需要给其命令类型定位，并给予标记，例如定义变量`case_type=True/False`。实现方式可以在调用执行命令的方法时传入参数，也可以在测试用例编写时直接定义等。类型设计定义为两大类型："}),"\n",(0,r.jsx)(e.p,{children:"(1) 正确命令：系统执行成功，状态码返回0的命令。"}),"\n",(0,r.jsx)(e.p,{children:"(2) 异常命令：系统执行失败，状态码返回非0的命令。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：定义这个两个类型的原因，是为了满足我们日常测试中更丰富的测试场景，例如我们会针对异常命令进行测试，虽然命令报错了，但是这正是我们想要达到的预期，同时会需要对错误输出的文案内容做进一步测试。所以当该命令被定义为`异常命令`后，执行命令最终报错，在测试眼里反而是“执行成功”，反之如果执行成功，那么其实是“执行失败”。以上只是在测试场景较为简单时适用，除此之外还有一些更复杂的场景，有不同的处理逻辑，后续会有说明。"})}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"方案详情："})}),"\n",(0,r.jsx)(e.p,{children:"往往一条测试用例中会存在多个执行命令，这里仅用执行一条命令的流程举例，后续说明当出现多条命令时如何处理，单命令处理流程如下："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"在执行一条Linux命令前，先对命令进行解析，判断命令的组成内容，这里定义为4大场景："}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"(1) 【场景1】命令中不包含`管道`与`grep`命令。"}),"\n",(0,r.jsx)(e.p,{children:"(2) 【场景2】命令中不包含`管道`，但包含`grep`命令。"}),"\n",(0,r.jsx)(e.p,{children:"(3) 【场景3】命令中包含`管道`，但不包含`grep`命令。"}),"\n",(0,r.jsx)(e.p,{children:"(4) 【场景4】命令中包含`管道`与`grep`命令。"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"根据解析后的命令分类进行不同处理："}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"(1) 【场景1】如“图2 运行逻辑子流程1”中所示，处理流程为："}),"\n",(0,r.jsx)(e.p,{children:"① 执行测试命令。"}),"\n",(0,r.jsx)(e.p,{children:"② 判断其状态码是否为0。"}),"\n",(0,r.jsx)(e.p,{children:"1) 状态码为0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"2) 状态码非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 正确命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 异常命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"③ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。"}),"\n",(0,r.jsx)(e.p,{children:"④ 流程结束。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：这个场景是最常见与普通的场景，针对市面上现有的处理方法来说，新增的是搭配`命令类型`使用的部分，对异常命令测试的执行结果状态码做了新的定义，使测试场景更为丰富和灵活。"})}),"\n",(0,r.jsx)(e.p,{children:"(2) 【场景2】如“图3 运行逻辑子流程2”中所示，处理流程为："}),"\n",(0,r.jsx)(e.p,{children:"① 执行测试命令。"}),"\n",(0,r.jsx)(e.p,{children:"② 判断其状态码是否为0。"}),"\n",(0,r.jsx)(e.p,{children:"1) 状态码为0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"2) 状态码非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 类型为正确命令，继续判断输出内容是否为空："}),"\n",(0,r.jsx)(e.p,{children:"a) 空：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"b) 非空：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 类型为异常命令，继续判断输出内容是否为空："}),"\n",(0,r.jsx)(e.p,{children:"a) 空：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b) 非空：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"③ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。"}),"\n",(0,r.jsx)(e.p,{children:"④ 流程结束。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：这里利用了`grep`命令的特性，当未筛选到关键字返回状态码非0，且标准输出不会存在内容，如果有输出内容则说明是错误输出，是命令执行的报错信息。"})}),"\n",(0,r.jsx)(e.p,{children:"(3) 【场景3】如“图4 运行逻辑子流程3”中所示，处理流程为："}),"\n",(0,r.jsx)(e.p,{children:"① 在执行测试命令前，引入命令`set`，并配置参数`-o pipefail`。"}),"\n",(0,r.jsx)(e.p,{children:"② 执行测试命令。"}),"\n",(0,r.jsx)(e.p,{children:"③ 判断其状态码是否为0。"}),"\n",(0,r.jsx)(e.p,{children:"1) 状态码为0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"2) 状态码非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a. 正确命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b. 异常命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"④ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。"}),"\n",(0,r.jsx)(e.p,{children:"⑤ 再次调用命令`set`，并配置参数`+o pipefail`，恢复默认状态，避免对后续用例造成影响。"}),"\n",(0,r.jsx)(e.p,{children:"⑥ 流程结束。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：这里运用`set`命令达到的效果是重组状态码，无论命令中有多少管道，只要有一条命令返回状态码非0，则最终状态码也返回非0；反之均为0时，最终状态码为0。这里避免了管道中存在命令报错，但最终状态码为0的情况，解决了管道中命令出现异常后带来的风险。"})}),"\n",(0,r.jsx)(e.p,{children:"(4) 【场景3】如“图5 运行逻辑子流程4”中所示，处理流程为："}),"\n",(0,r.jsx)(e.p,{children:"① 在执行测试命令前，引入命令`set`，并配置参数`-o pipefail`。"}),"\n",(0,r.jsx)(e.p,{children:"② 执行测试命令。"}),"\n",(0,r.jsx)(e.p,{children:"③ 判断存在的`grep`命令是否在管道最后："}),"\n",(0,r.jsx)(e.p,{children:"1) `grep`命令不在管道最后："}),"\n",(0,r.jsx)(e.p,{children:"a. 判断其状态码是否为0："}),"\n",(0,r.jsx)(e.p,{children:"a) 状态码为0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"i. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"ii. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b) 状态码非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"i. 正确命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"ii. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：命令中包含管道和`grep`命令，情况变的复杂，之前的处理都不再适用，这个场景下对管道的定义是各命令的处理具备连续性，若`grep`命令未筛选到结果，后续的命令处理均无意义，所以这类情况无论命令类型为正确/异常，最终状态定义为错误，状态码直接判断为1。"})}),"\n",(0,r.jsx)(e.p,{children:"2) `grep` 命令在管道最后，继续判断管道除最后一个命令以外的状态码是否都为0："}),"\n",(0,r.jsx)(e.p,{children:"a. 状态码存在非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"a) 正确命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b) 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：原理同上个注释，命令中包含管道，代表各命令的处理具备连续性，若中间部分命令报错，那后续的命令处理均无意义，所以这类情况无论命令类型为正确/异常，最终状态定义为错误，状态码直接判断为1。"})}),"\n",(0,r.jsx)(e.p,{children:"b. 状态码均为0，继续判断命令最终状态码："}),"\n",(0,r.jsx)(e.p,{children:"a) 状态码为0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"i. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"ii. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:"b) 状态码非0，继续判断命令类型："}),"\n",(0,r.jsx)(e.p,{children:"i. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。"}),"\n",(0,r.jsx)(e.p,{children:"ii. 异常命令：返回状态码1，表示这是一条报错的异常命令。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：流程走到这一步说明，`grep`命令之前的所有命令均执行成功，所以此时执行`grep`命令不管是否筛选出关键字，命令都算是执行成功，这里必然是正确命令，不会出现异常命令的情况，如果命令类型为异常命令则为类型设置错误，需要修改。"})}),"\n",(0,r.jsx)(e.p,{children:"④ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。"}),"\n",(0,r.jsx)(e.p,{children:"⑤ 再次调用命令`set`，并配置参数`+o pipefail`，恢复默认状态，避免对后续用例造成影响。"}),"\n",(0,r.jsx)(e.p,{children:"⑥ 流程结束。"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.em,{children:"注：相对于之前的场景，该场景最为复杂，融合了所有变量，并对其做了新的定义。其中判断存在的`grep`命令是否在管道最后的意义在于，若使用了管道说明每一个命令都是有意义的，如果还没进行到最后一个命令就出现了报错，或者是`grep`命令未筛选到关键字的情况，那后续的所有命令都毫无意义，这里将这种情况定义为异常，在上面的注释中也有说明。"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"根据以上子流程中返回的全新状态码与输出内容，配合断言做进一步测试。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"根据断言结果返回测试结果，若存在一条测试用例包含多条测试命令的情况，结合重新定义的状态码进行判断："}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"(1) 所有命令返回的状态码均为0，根据断言得出测试结果："}),"\n",(0,r.jsx)(e.p,{children:"① 每一条用例中，所有断言均通过则用例通过，状态标记为`pass`。"}),"\n",(0,r.jsx)(e.p,{children:"② 每一条用例中，存在一个断言不通过，则用例不通过，状态标记为`fail`。"}),"\n",(0,r.jsx)(e.p,{children:"(2) 若有其中一条命令返回的状态码非0，则该条用例状态为`error`。"}),"\n",(0,r.jsxs)(e.ol,{start:"4",children:["\n",(0,r.jsx)(e.li,{children:"单条用例测试流程完毕。__"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"_ _"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"实验验证："})}),"\n",(0,r.jsx)(e.p,{children:"最后依然采用1.1.2章节的测试点进行实际验证，代码如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:'#! /bin/bash\n\necho True > testfile1\n	\ntest1 () {\n  ......     # 省略部分为定义的用例标题、编号等\n  quiet "cat testfile1 | grep True" "true" # 测试命令后传入参数"true/false"代表命令类型\n  Com1="${quiet_s}" # 重新定义的状态码\n  Com2="${quiet_r}" # 输出内容\n\n  Exp1="0"\n  Exp2="True"\n  assertEqual "${Com1}" "${Exp1}"\n  assertIn "${Exp2}" "${Com2}"\n}\n\ntest2() {\n  ......\n  quiet "cat testfile1 | grep False" "false"\n  Com1="${quiet_s}"\n  Com2="${quiet_r}"\n\n  Exp1="0"\n  Exp2=""\n  assertEqual "${Com1}" "${Exp1}"\n  assertEqual "${Exp2}" "${Com2}"\n}\n\ntest3 () {\n  ......\n  quiet "cat testfile2 | grep False" "true"\n  Com="${quiet_s}"\n\n  Exp1="0"\n  Exp2=""\n  assertEqual "${Com1}" "${Exp1}"\n  assertEqual "${Exp2}" "${Com2}"\n\n}\n\ntest4 () {\n  ......\n  quiet "cat testfile1 | sed \'s/True/False/g\'" "true"\n  Com="${quiet_r}"\n  Exp="False"\n  assertEqual "${Com}" "${Exp}"\n}\n\ntest5 () {\n  ......\n  quiet "cat testfile2 | sed \'s/True/False/g\'" "true"\n  Com="${quiet_r}"\n  Exp="False"\n  assertEqual "${Com}" "${Exp}"\n}\n\nrm -f testfile1\n'})}),"\n",(0,r.jsx)(e.p,{children:"测试结果如下："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:"/%E4%B8%80%E7%A7%8D%E9%92%88Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6_assets/wpsLQg4Cu.jpg",alt:""})}),"\n",(0,r.jsx)(e.p,{children:"图6 实际验证结果"}),"\n",(0,r.jsx)(e.p,{children:"可以看到在1.1.2章节中测试无效的测试点，根据这套处理逻辑执行之后，能明显的识别出异常，规避了异常用例的测试结果为`pass`的问题。这里新增用例状态为`error`，快速的识别出了用例代码质量风险，代表用例中存在测试命令异常，该条用例需要重点检查，是测试环境变化导致，还是需求变更导致命令变化等。"}),"\n",(0,r.jsxs)(e.h3,{id:"23本发明技术方案带来的有益效果",children:[(0,r.jsx)(e.strong,{children:"2.3、本发明技术方案带来的有益效果"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#23本发明技术方案带来的有益效果",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上述设计的执行Shell算法，运用在自动化测试框架中后："}),"\n",(0,r.jsx)(e.p,{children:"(1) 测试结果更准确，降低质量风险。"}),"\n",(0,r.jsx)(e.p,{children:"(2) 能更好的识别测试命令的有效性，快速发现异常的命令，提升分析效率。"}),"\n",(0,r.jsx)(e.p,{children:"(3) 支持并扩展异常命令测试场景，满足更多的测试场景变化。"}),"\n",(0,r.jsxs)(e.h3,{id:"24针对上述技术方案是否还有替代方案同样能完成发明目的",children:[(0,r.jsx)(e.strong,{children:"2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#24针对上述技术方案是否还有替代方案同样能完成发明目的",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"无"}),"\n",(0,r.jsxs)(e.h2,{id:"3本发明的技术关键点和欲保护点是什么",children:[(0,r.jsx)(e.strong,{children:"3、本发明的技术关键点和欲保护点是什么"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3本发明的技术关键点和欲保护点是什么",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本发明的技术关键点和欲保护点是2.2章节中所阐述，设计的执行Shell测试命令的一整算法，可复用在任何Shell自动化测试框架中，达到2.3章节提到的效果："}),"\n",(0,r.jsx)(e.p,{children:"(1) 主流程：结合事先定义的命令类型，配合解析命令后得出的四大场景，给予不同子流程算法。"}),"\n",(0,r.jsx)(e.p,{children:"(2) 子流程1：针对场景1设计的算法。"}),"\n",(0,r.jsx)(e.p,{children:"(3) 子流程2：针对场景2设计的算法。"}),"\n",(0,r.jsx)(e.p,{children:"(4) 子流程3：针对场景3设计的算法。"}),"\n",(0,r.jsx)(e.p,{children:"(5) 子流程4：针对场景4设计的算法。"}),"\n",(0,r.jsx)(e.p,{children:"(6) 结合主流程和子流程算法，得出全新的状态码用于对测试结果的支撑，达到2.3章节提到的目的。"}),"\n",(0,r.jsxs)(e.h2,{id:"4附件",children:[(0,r.jsx)(e.strong,{children:"4、附件："}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4附件",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"参考文献（如专利/论文/标准等）"}),"\n",(0,r.jsxs)(e.p,{children:["l ",(0,r.jsx)(e.a,{href:"https://zh.wikipedia.org/wiki/Linux",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(e.em,{children:"Linux操作系统"})})]}),"\n",(0,r.jsxs)(e.p,{children:["l ",(0,r.jsx)(e.a,{href:"https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(e.em,{children:"Shell壳层"})})]}),"\n",(0,r.jsxs)(e.p,{children:["l ",(0,r.jsx)(e.a,{href:"https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8B%95%E5%8C%96%E6%B8%AC%E8%A9%A6%E6%A1%86%E6%9E%B6",target:"_blank",rel:"noopener noreferrer",children:(0,r.jsx)(e.em,{children:"自动化测试框架"})})]})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let h=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["tech_doc%2F%E4%B8%93%E5%88%A9%E4%BA%A4%E5%BA%95%E4%B9%A6%2F%E4%B8%80%E7%A7%8D%E9%92%88%E5%AF%B9Linux%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E6%8A%80%E6%9C%AF%E4%BA%A4%E5%BA%95%E4%B9%A6.md"]={toc:[{text:"**0、缩略语和关键术语定义**",id:"0缩略语和关键术语定义",depth:2},{text:"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**",id:"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术",depth:2},{text:"**1.1、与本发明相关的现有技术**",id:"11与本发明相关的现有技术",depth:3},{text:"**1.1.1、现有技术的技术方案**",id:"111现有技术的技术方案",depth:4},{text:"**1.1.2、现有技术的缺点**",id:"112现有技术的缺点",depth:3},{text:"**2、本发明技术方案的详细阐述**",id:"2本发明技术方案的详细阐述",depth:2},{text:"**2.1、本发明所要解决的技术问题**",id:"21本发明所要解决的技术问题",depth:3},{text:"**2.2、本发明提供的完整技术方案**",id:"22本发明提供的完整技术方案",depth:3},{text:"**2.3、本发明技术方案带来的有益效果**",id:"23本发明技术方案带来的有益效果",depth:3},{text:"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**",id:"24针对上述技术方案是否还有替代方案同样能完成发明目的",depth:3},{text:"**3、本发明的技术关键点和欲保护点是什么**",id:"3本发明的技术关键点和欲保护点是什么",depth:2},{text:"**4、附件：**",id:"4附件",depth:2}],title:"一种针对Linux系统异常命令的测试方法技术交底书",headingTitle:"一种针对Linux系统异常命令的测试方法技术交底书",frontmatter:{Author:"海针"}}}}]);