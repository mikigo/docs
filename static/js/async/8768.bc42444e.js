"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["8768"],{3643:function(e,n,s){s.r(n),s.d(n,{default:()=>c});var d=s(2676),r=s(453);function l(e){let n=Object.assign({h1:"h1",a:"a",h3:"h3",p:"p",pre:"pre",code:"code",ol:"ol",li:"li"},(0,r.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"shell问题随记",children:["Shell问题随记",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#shell问题随记",children:"#"})]}),"\n",(0,d.jsxs)(n.h3,{id:"脚本实现切换用户后操作",children:["脚本实现切换用户后操作",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#脚本实现切换用户后操作",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述：shell脚本中如果涉及切换用户，无法执行切换操作之后命令，如root用户执行以下脚本："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:"#! /bin/bash\n\nsu mars  # 执行成功\necho 666 # 不会执行\n"})}),"\n",(0,d.jsx)(n.p,{children:"问题原因：脚本中切换用户后，会先开一个子shell，所以后续命令不会执行，返回当前shell后才会执行"}),"\n",(0,d.jsx)(n.p,{children:"解决方案：使用xdotool模仿键盘输入，可规避环境问题，安装xdotool(apt install xdotool)后，修改代码如下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:"#! /bin/bash\n\n方案1：\nxdotool type 'su mars'    # 模拟输入'su mars'\nxdotool key Return        # 模拟输入回车\nxdotool type 'echo 666'   # 模拟输入'echo 666'\nxdotool key Return        # 模拟输入回车\n\n方案2：\nxdotool type 'su mars'    # 模拟输入'su mars'\nxdotool keydown Return    # 模拟按下回车\nxdotool keyup Return      # 模拟弹起回车\nxdotool type 'echo 666'   # 模拟输入'echo 666'\nxdotool keydown Return    # 模拟按下回车\nxdotool keyup Return      # 模拟弹起回车\n\n方案3：\nxdotool type 'su mars\n'                         # 模拟输入'su mars'+回车\nxdotool type 'echo 666\n'                         # 模拟输入'echo 666'+回车\n"})}),"\n",(0,d.jsxs)(n.p,{children:["补充：xdotool存在一些稳定性问题，以上方案实测仅",(0,d.jsx)(n.code,{children:"方案3"}),"可用，其他方案理论上无问题，但执行失败，常用命令说明："]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:"# 模拟击键a [*注1]\nxdotool key a\n\n# 模拟按两个键alt+tab\nxdotool key alt+Tab\n\n# 自动输入word\nxdotool type 'word'\n\n# 自动输入word带回车\nxdotool type \"word\n\"\n\n# 模拟鼠标移动+点击，这会让鼠标移动到（x，y），然后点击鼠标左键。“1”代表鼠标左键，“2”则是滚轮，“3”则是右键。\nxdotool mousemove 655 320 click 1\n\n# 打开的窗口中搜索对应名称的窗口，并聚焦于该窗口，然后模拟击键\nxdotool search --name [name of the window] key [keys to press]\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"通过命令创建用户并设置密码",children:["通过命令创建用户并设置密码",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过命令创建用户并设置密码",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:["问题描述：shell脚本使用root用户创建普通用户并设置密码操作时，因为设置密码是交互式操作，需要用户2次确认，使用",(0,d.jsx)(n.code,{children:"echo Test#136 | passwd login_a"}),"显然不会成功。"]}),"\n",(0,d.jsx)(n.p,{children:"解决方案：使用非交互式命令设置密码，如下："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-bash",children:'# 方案1 使用passwd参数\'--stdin\'，uos与Ubuntu不可用，不支持该参数\necho "Test#136" | passwd login_a --stdin\n\n# 方案2 使用chpasswd\nuseradd login_a -m -s /bin/bash && echo "login_a:Test#136" | chpasswd\n'})}),"\n",(0,d.jsxs)(n.p,{children:["补充：如果密码中包含 ",(0,d.jsx)(n.code,{children:"$"})," 字符，需要使用反斜线进行转义",(0,d.jsx)(n.code,{children:"\\$"})]}),"\n",(0,d.jsxs)(n.h3,{id:"账号相关命令",children:["账号相关命令",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#账号相关命令",children:"#"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"# passwd：修改密码\n# uptime： 显示系统运行信息\n# who：查看当前登录的用户\n# passwd root：修改root密码\n# su 切换root用户，保留当前工作环境（保持当前目录），输入root用户密码\n# su -i 切换root用户与root用户环境，输入root用户密码，无初始密码则设置后登陆\n# sudo su 切换root，输入当前用户密码\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"用户管理",children:["用户管理",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#用户管理",children:"#"})]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"$ useradd username -m -s /bin/bash -u uid -g gid\n# -c<备注> 　加上备注文字。备注文字会保存在passwd的备注栏位中。\n# -d<登入目录> 　指定用户登入时的起始目录。\n# -D 　变更预设值．\n# -e<有效期限> 　指定帐号的有效期限。\n# -f<缓冲天数> 　指定在密码过期后多少天即关闭该帐号。\n# -g<群组> 　指定用户所属的群组。\n# -G<群组> 　指定用户所属的附加群组。\n# -m 　自动建立用户的登入目录。（等效 -d /home/username）\n# -M 　不要自动建立用户的登入目录。\n# -n 　取消建立以用户名称为名的群组．\n# -r 　建立系统帐号。\n# -s<shell>　 　指定用户登入后所使用的shell。\n# -u<uid> 　指定用户ID。\n\n$ usermol -l new_username old_username  # 修改用户名\n$ usermol -u uid username # 修改uid\n$ userdel username  # 删除用户名\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"解除账户锁定",children:["解除账户锁定",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解除账户锁定",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述：命令行输出错误密码次数过多，导致账号被锁定xmin"}),"\n",(0,d.jsx)(n.p,{children:"解决办法："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"# 以下命令可登录root用户执行，username为锁定用户账号\n\npam_tally2 --user username   #查看错误了几次\npam_tally2 --user username --reset   #重置\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"ssh配置root登录",children:["ssh配置root登录",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ssh配置root登录",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述：ssh默认不允许root用户登录"}),"\n",(0,d.jsx)(n.p,{children:"解决办法："}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"# 修改ssh服务配置文件\n\n$ sudo vi /etc/ssh/sshd_config\n#调整PermitRootLogin参数值为yes，并保存退出\n\n$ sudo service ssh restart\n# 重启服务生效\n"})}),"\n",(0,d.jsxs)(n.h3,{id:"删除目录的非指定文件",children:["删除目录的非指定文件",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#删除目录的非指定文件",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述\n在shell 脚本调试或者执行时，会经常遇到需要删除当前目录不需要的文件，手动删除十分麻烦。"}),"\n",(0,d.jsxs)(n.p,{children:["解决方案\n",(0,d.jsx)(n.code,{children:"shopt -s extglob"}),"\n",(0,d.jsx)(n.code,{children:"rm -rf !(file1|file2)"})]}),"\n",(0,d.jsxs)(n.p,{children:["解决过程与分析\n",(0,d.jsx)(n.code,{children:"shopt"})," 命令用于显示和设置shell中的行为选项，通过这些选项以增强shell易用性；如果不执行",(0,d.jsx)(n.code,{children:"shopt -s extglob"})," ，直接执行 ",(0,d.jsx)(n.code,{children:"rm -rf !(*.txt)"}),"会提示",(0,d.jsx)(n.code,{children:"bash: !: event not found"})]}),"\n",(0,d.jsxs)(n.p,{children:["实例：\n1)  在",(0,d.jsx)(n.code,{children:"/home/amd"}),"目录下存在文件：",(0,d.jsx)(n.code,{children:"1.txt、test.log、test.txt、1.deb、1.log"}),"，现在只保留",(0,d.jsx)(n.code,{children:"txt"}),"格式的文件。"]}),"\n",(0,d.jsx)(n.p,{children:"补充代码块"}),"\n",(0,d.jsxs)(n.p,{children:["​	2)  在",(0,d.jsx)(n.code,{children:"/home/amd"}),"目录下存在文件：",(0,d.jsx)(n.code,{children:"1.txt、test.log、test.txt、1.deb、1.log"}),"，现在只保留",(0,d.jsx)(n.code,{children:"txt"}),"和",(0,d.jsx)(n.code,{children:"deb"}),"格式的文件。"]}),"\n",(0,d.jsx)(n.p,{children:"补充代码块"}),"\n",(0,d.jsxs)(n.p,{children:["​	3)  在",(0,d.jsx)(n.code,{children:"/home/amd"}),"目录下存在文件：",(0,d.jsx)(n.code,{children:"1.txt、test.log、test.txt、1.deb、1.log"}),"，现在保留指定目录下",(0,d.jsx)(n.code,{children:"log"}),"格式的文件。"]}),"\n",(0,d.jsx)(n.p,{children:"补充代码块"}),"\n",(0,d.jsxs)(n.h3,{id:"shell中单双反引号的区别",children:["shell中单/双/反引号的区别",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#shell中单双反引号的区别",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述\n在shell执行的时候，常常遇到调用的变量被当做字符处理，导致脚本运行出错。"}),"\n",(0,d.jsx)(n.p,{children:"解决方案\n使用双引号将需要保留特殊字符的字符串括起来。"}),"\n",(0,d.jsx)(n.p,{children:"解决过程与分析\n双引号（\"\"）：保留特殊字符的功能，如美元符号、反引号、反斜线。\n单引号（''）：被单引号括起来的字符都被视为普通字符对待。\n反引号（``）：被反引号括起来的字符串被当做shell命令执行，其标准输入结果取代整个反引号部分。"}),"\n",(0,d.jsx)(n.p,{children:"实例："}),"\n",(0,d.jsx)(n.p,{children:"补充代码块"}),"\n",(0,d.jsxs)(n.h3,{id:"杀死进程的多种方法",children:["杀死进程的多种方法",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#杀死进程的多种方法",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述\n在shell脚本执行中，经常遇到需要终止某个进程，但是通过进程id终止十分不方便，因为每次执行的进程id是变化的，导致脚本运行效率低下。"}),"\n",(0,d.jsxs)(n.p,{children:["解决方案\n第一种：",(0,d.jsx)(n.code,{children:"ps aux | grep netserver | grep -v grep | cut -c 9-15 | xargs kill -9"}),"\n第二种：",(0,d.jsx)(n.code,{children:"pidof netserver | xargs kill -9"}),"\n第三种：",(0,d.jsx)(n.code,{children:"pgrep netserver | xargs kill -9"})]}),"\n",(0,d.jsxs)(n.p,{children:["解决过程与分析\n第一种：\n",(0,d.jsx)(n.code,{children:"ps aux"})," 显示所有的进程\n",(0,d.jsx)(n.code,{children:"grep netserver "}),"过滤显示",(0,d.jsx)(n.code,{children:"netserver"}),"相关的进程\n",(0,d.jsx)(n.code,{children:"grep -v grep "}),"过滤",(0,d.jsx)(n.code,{children:"grep"}),"的查询进程\n",(0,d.jsx)(n.code,{children:"cut -c 9-15 "})," 截取对应位置的字符，即进程id\n",(0,d.jsx)(n.code,{children:"xargs"})," 捕获左边的输出传递给右边的命令\n",(0,d.jsx)(n.code,{children:"kill -9"})," 强制杀死进程"]}),"\n",(0,d.jsxs)(n.p,{children:["第二种：\n",(0,d.jsx)(n.code,{children:"pidof"})," 用于查找指定名称的进程的进程号id号\n语法：\n",(0,d.jsx)(n.code,{children:"pidof (选项) (参数)"}),"\n选项：\n",(0,d.jsx)(n.code,{children:"-s：仅返回一个进程号；"}),"\n",(0,d.jsx)(n.code,{children:"-c：仅显示具有相同“root”目录的进程；"}),"\n",(0,d.jsx)(n.code,{children:"-x：显示由脚本开启的进程；"}),"\n",(0,d.jsx)(n.code,{children:"-o：指定不显示的进程ID。"})]}),"\n",(0,d.jsxs)(n.p,{children:["第三种：\n",(0,d.jsx)(n.code,{children:"pgrep "}),"是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。\n语法：\n",(0,d.jsx)(n.code,{children:"pgrep  (选项) (参数)"}),"\n选项：\n",(0,d.jsx)(n.code,{children:"-l 同时显示进程名和PID"}),"\n",(0,d.jsx)(n.code,{children:"-o 当匹配多个进程时，显示进程号最小的那个"}),"\n",(0,d.jsx)(n.code,{children:"-n 当匹配多个进程时，显示进程号最大的那个"})]}),"\n",(0,d.jsx)(n.p,{children:"实例："}),"\n",(0,d.jsxs)(n.ol,{children:["\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsx)(n.p,{children:"启动stress进程，执行命令：\n	stress -c 1 &\n	stress -c 1 &\n	stress -c 1 &"}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["使用第一种终止进程的命令：\n",(0,d.jsx)(n.code,{children:"ps aux | grep stress | grep -v grep | cut -c 9-15 | xargs kill -9"})]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["使用第二种终止进程的命令：\n",(0,d.jsx)(n.code,{children:"pidof stress | xargs kill -9"})]}),"\n"]}),"\n",(0,d.jsxs)(n.li,{children:["\n",(0,d.jsxs)(n.p,{children:["使用第三种终止进程的命令：\n",(0,d.jsx)(n.code,{children:"pgrep stress | xargs kill -9"})]}),"\n"]}),"\n"]}),"\n",(0,d.jsxs)(n.h3,{id:"0-等用法及说明",children:["$#,$0,$@ 等用法及说明",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#0-等用法及说明",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"问题描述"}),"\n",(0,d.jsx)(n.p,{children:"​		在编写shell脚本的时候常常会向方法里面传递不同的参数，将参数放入变量的方式会导致脚本行数增加，代码执行效率不高，且不利于后期维护。"}),"\n",(0,d.jsx)(n.p,{children:"解决方案"}),"\n",(0,d.jsx)(n.p,{children:"​		使用$1、$2、$@等方式调用传入的参数。"}),"\n",(0,d.jsx)(n.p,{children:"解决过程与分析"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:"$# 是传给脚本的参数个数\n$0 是脚本本身的名字\n$1 是传递给该shell脚本的第一个参数\n$2 是传递给该shell脚本的第二个参数\n$@ 是传给脚本的所有参数的列表\n$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个\n$$ 是脚本运行的当前进程ID号\n$? 是显示最后命令的退出状态，0表示没有错误，其他表示有错误\n"})}),"\n",(0,d.jsx)(n.p,{children:"实例："}),"\n",(0,d.jsxs)(n.p,{children:["​		创建脚本文件：",(0,d.jsx)(n.code,{children:"test.sh"}),"，将下面的代码复制到文件中。"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-shell",children:' #!/bin/bash\ntest(){\necho "传入的参数总数："$#\necho "第一个参数是："$1\necho "第二个参数是："$2\necho "传入的所有参数在这里："$@\necho "我是字符串："$*\necho "本次运行的脚本进程号是："$$\necho "我的名字是："$0\necho \'$@ 和 $*的区别如下：\'\necho \'$@ 被双引号括起来后，是4份数据\'\nfor var in "$@"\ndo	\n	echo "${var}"\ndone\n\necho \'$* 被双引号括起来后，是1份数据\'\nfor var in "$*"\ndo\n	echo "${var}"\ndone\n}\ntest "1" "2" "3" "4"\n'})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(l,{...e})}):l(e)}let c=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["blog%2F2024%2FShell%E9%97%AE%E9%A2%98%E9%9A%8F%E8%AE%B0.md"]={toc:[{text:"脚本实现切换用户后操作",id:"脚本实现切换用户后操作",depth:3},{text:"通过命令创建用户并设置密码",id:"通过命令创建用户并设置密码",depth:3},{text:"账号相关命令",id:"账号相关命令",depth:3},{text:"用户管理",id:"用户管理",depth:3},{text:"解除账户锁定",id:"解除账户锁定",depth:3},{text:"ssh配置root登录",id:"ssh配置root登录",depth:3},{text:"删除目录的非指定文件",id:"删除目录的非指定文件",depth:3},{text:"shell中单/双/反引号的区别",id:"shell中单双反引号的区别",depth:3},{text:"杀死进程的多种方法",id:"杀死进程的多种方法",depth:3},{text:"$#,$0,$@ 等用法及说明",id:"0-等用法及说明",depth:3}],title:"Shell问题随记",headingTitle:"Shell问题随记",frontmatter:{Author:"海针"}}}}]);