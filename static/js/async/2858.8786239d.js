"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["2858"],{2505:function(e,n,l){l.r(n),l.d(n,{default:()=>r});var c=l(2676),s=l(453);function i(e){let n=Object.assign({h1:"h1",code:"code",a:"a",h2:"h2",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",p:"p",pre:"pre",strong:"strong",ul:"ul",li:"li",img:"img"},(0,s.ah)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"python调用动态库运行时报静态tls块不能分配内存根因分析报告",children:[(0,c.jsx)(n.code,{children:"Python"}),"调用动态库运行时报静态",(0,c.jsx)(n.code,{children:"TLS"}),"块不能分配内存根因分析报告",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#python调用动态库运行时报静态tls块不能分配内存根因分析报告",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"一相关术语",children:["一、相关术语",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一相关术语",children:"#"})]}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{align:"center",children:"缩写"}),"\n",(0,c.jsx)(n.th,{align:"center",children:"全称"}),"\n",(0,c.jsx)(n.th,{align:"left",children:"描述"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{align:"center",children:"Python"}),"\n",(0,c.jsx)(n.td,{align:"center",children:"Python"}),"\n",(0,c.jsx)(n.td,{align:"left",children:"一种跨平台的计算机程序设计语言"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{align:"center",children:"C++"}),"\n",(0,c.jsx)(n.td,{align:"center",children:"C++"}),"\n",(0,c.jsx)(n.td,{align:"left",children:"一种静态数据类型检查的、支持多重编程范式的通用程序设计语言"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{align:"center",children:(0,c.jsx)(n.code,{children:"jemalloc"})}),"\n",(0,c.jsx)(n.td,{align:"center",children:(0,c.jsx)(n.code,{children:"jemalloc"})}),"\n",(0,c.jsx)(n.td,{align:"left",children:"一种内存分配器"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{align:"center",children:(0,c.jsx)(n.code,{children:"TLS"})}),"\n",(0,c.jsx)(n.td,{align:"center",children:"Thread-Local Storage"}),"\n",(0,c.jsx)(n.td,{align:"left",children:"一种实现线程私有全局变量的机制"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{align:"center",children:"Initial Executable"}),"\n",(0,c.jsx)(n.td,{align:"center",children:"Initial Executable"}),"\n",(0,c.jsxs)(n.td,{align:"left",children:["一种在程序启动后从加载的共享对象中引用",(0,c.jsx)(n.code,{children:"TLS"}),"变量的模型"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"二问题概述",children:["二、问题概述",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二问题概述",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"【背景】"}),"\n",(0,c.jsx)(n.p,{children:"基于Python、C++，通过白盒测试手段完成对某些重要功能在代码层面的测试"}),"\n",(0,c.jsx)(n.p,{children:"【复现步骤】"}),"\n",(0,c.jsxs)(n.p,{children:["1.",(0,c.jsx)(n.code,{children:"Python"}),"通过",(0,c.jsx)(n.code,{children:"ctypes"}),"第三方库调用C++ 动态库so文件中的函数"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import ctypes\nfrom utils import config\n\n#加载C++动态库\nlib = ctypes.cdll.LoadLibrary(config.so_path+'/libfjemalloc.so')\nprint(lib.fibo(8))\n"})}),"\n",(0,c.jsxs)(n.p,{children:["2.运行时报",(0,c.jsx)(n.code,{children:"libjemalloc.so.2 cannot allocate memory in static TLS block"})]}),"\n",(0,c.jsx)(n.p,{children:"【期望】"}),"\n",(0,c.jsx)(n.p,{children:"可正常调用共享库so中的函数并得到正确的结果。"}),"\n",(0,c.jsx)(n.p,{children:"【环境】"}),"\n",(0,c.jsxs)(n.p,{children:["硬件环境：",(0,c.jsx)(n.code,{children:"X86"}),"平台、",(0,c.jsx)(n.code,{children:"ARM"}),"平台（",(0,c.jsx)(n.code,{children:"龙芯平台、申威平台未依赖jemalloc"}),"）"]}),"\n",(0,c.jsxs)(n.p,{children:["python：",(0,c.jsx)(n.code,{children:"3.7"})]}),"\n",(0,c.jsxs)(n.p,{children:["jemalloc:",(0,c.jsx)(n.code,{children:"5.1.0-3"})]}),"\n",(0,c.jsxs)(n.h2,{id:"三问题分析",children:["三、问题分析",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三问题分析",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在",(0,c.jsx)(n.code,{children:"X86"}),"平台和ARM平台上，Python调用C++动态库so中函数并运行的流程如下图所示，Python程序使用第三方库",(0,c.jsx)(n.code,{children:"ctypes"}),"加载",(0,c.jsx)(n.code,{children:"libTestlib"}),"、并通过",(0,c.jsx)(n.code,{children:"jemalloc"}),"进行内存分配。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-mermaid",children:"sequenceDiagram\nPython->>libTest.so: ctypes加载动态库\nlibTest.so->>jemalloc: 依赖jemalloc进行内存分配\njemalloc--\x3e>libTest.so: 完成内存分配\nlibTest.so--\x3e>Python: 返回so对象\n\n"})}),"\n",(0,c.jsx)(n.p,{children:"。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"【分析】"})}),"\n",(0,c.jsxs)(n.p,{children:["加载动态库",(0,c.jsx)(n.code,{children:"jemalloc"}),"时报不能在静态",(0,c.jsx)(n.code,{children:"TLS"}),"块中分配内存，可以猜测导致出现报错的原因有两种："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["第一：Python使用第三方库",(0,c.jsx)(n.code,{children:"ctypes"}),"调用C++动态库存在问题。"]}),"\n",(0,c.jsxs)(n.li,{children:["第二：",(0,c.jsx)(n.code,{children:"jemalloc"}),"内部在分配内存时有一些特性导致加载C++动态库存在问题。"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"对第一种情况进行分析"})}),"\n",(0,c.jsxs)(n.p,{children:["使用",(0,c.jsx)(n.code,{children:"ctypes.cdll.LoadLibrary"}),"的方式加载依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的动态库与加载不依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的动态库，验证Python是否能正常加载so文件："]}),"\n",(0,c.jsxs)(n.p,{children:["1.通过",(0,c.jsx)(n.code,{children:"ctypes"}),"加载不依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的共享库：",(0,c.jsx)(n.code,{children:"ldd libfibo.so"}),"列出该库依赖的其他共享库"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://i.loli.net/2020/11/24/RnHYMDXsC2V7EpO.png",alt:"1"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"import ctypes\nfrom utils import config\n\n#加载C++动态库\nlib = ctypes.cdll.LoadLibrary(config.so_path+'/libfibo.so')\nprint(lib.fibo(8))\n\n运行结果：\n/usr/bin/python3.7 /home/mola/PycharmProjects/whitebox-autotest/test.py\n1\n"})}),"\n",(0,c.jsxs)(n.p,{children:["2.通过",(0,c.jsx)(n.code,{children:"ctypes"}),"加载依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的共享库：",(0,c.jsx)(n.code,{children:"ldd libfjemalloc.so"}),"列出该库依赖的其他共享库"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.img,{src:"https://i.loli.net/2020/11/24/uQpWq6cVLR7zxAC.png",alt:"截图录屏_选择区域_20201124135519"})}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:'import ctypes\nfrom utils import config\n\n#加载C++动态库\nlib = ctypes.cdll.LoadLibrary(config.so_path+\'/libfjemalloc.so\')\nprint(lib.fibo(8))\n\n运行结果：\nTraceback (most recent call last):\n  File "/home/mola/PycharmProjects/whitebox-autotest/utils/test1.py", line 11, in <module>\n    lib = ctypes.cdll.LoadLibrary(config.so_path+\'/libfjemalloc.so\')\n  File "/usr/lib/python3.7/ctypes/__init__.py", line 434, in LoadLibrary\n    return self._dlltype(name)\n  File "/usr/lib/python3.7/ctypes/__init__.py", line 356, in __init__\n    self._handle = _dlopen(self._name, mode)\nOSError: /lib/x86_64-linux-gnu/libjemalloc.so.2: cannot allocate memory in static TLS block\n\n'})}),"\n",(0,c.jsxs)(n.p,{children:["根据调用两个共享库的对比结果可知，Python通过",(0,c.jsx)(n.code,{children:"ctypes"}),"第三方库加载C++共享库的方案是可行的。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"对第二种情况进行分析"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"jemalloc"}),"是一个能够快速分配/回收内存，减少内存碎片，对多核友好，具有可伸缩性的内存分配器。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"TLS"}),"线程局部缓存，将数据和执行的特定的线程连续起来，在线程内部，各个函数可以像使用全局变量一样调用它，但它对线程外部的的其他线程是不可见的。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"TLS"}),"有４种访问模型，每个",(0,c.jsx)(n.code,{children:"TLS"}),"的引用均遵循其中之一，另外，可以从较一般的访问模型转换为更优化的访问模型。"]}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{children:"访问类型"}),"\n",(0,c.jsx)(n.th,{children:"解释"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsxs)(n.td,{children:["General Dynamic (GD) - dynamic ",(0,c.jsx)(n.code,{children:"TLS"})]}),"\n",(0,c.jsxs)(n.td,{children:["此模型允许从共享对象或动态可执行文件引用所有",(0,c.jsx)(n.code,{children:"TLS"}),"变量，当",(0,c.jsx)(n.code,{children:"TLS"}),"块首次从特定线程引用时，该模型还支持延迟分配",(0,c.jsx)(n.code,{children:"TLS"}),"块"]}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsxs)(n.td,{children:["Local Dynamic (",(0,c.jsx)(n.code,{children:"LD"}),") - dynamic ",(0,c.jsx)(n.code,{children:"TLS"})," of local symbols"]}),"\n",(0,c.jsx)(n.td,{children:"该模型是对GD模型的优化。编译器可以确定变量是在本地绑定的，还是在正在构建的对象中受保护的"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsxs)(n.td,{children:["Initial Executable (IE) - static ",(0,c.jsx)(n.code,{children:"TLS"})," with assigned offsets"]}),"\n",(0,c.jsxs)(n.td,{children:["这个模型只能引用作为初始静态",(0,c.jsx)(n.code,{children:"TLS"}),"模板一部分的",(0,c.jsx)(n.code,{children:"TLS"}),"变量。这个模板由进程启动时可用的所有",(0,c.jsx)(n.code,{children:"TLS"}),"块以及一个小的备份预留块组成。（通过固定预留块来满足有限数量",(0,c.jsx)(n.code,{children:"TLS"}),"的访问）"]}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsxs)(n.td,{children:["Local Executable (LE) - static ",(0,c.jsx)(n.code,{children:"TLS"})]}),"\n",(0,c.jsxs)(n.td,{children:["这个模型只能引用作为动态可执行文件的",(0,c.jsx)(n.code,{children:"TLS"}),"块的一部分的",(0,c.jsx)(n.code,{children:"TLS"}),"变量"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["查看",(0,c.jsx)(n.code,{children:"jemalloc"}),"源码可知，",(0,c.jsx)(n.code,{children:"jemalloc"}),"默认打开initial-exec模型并定义了",(0,c.jsx)(n.code,{children:"JEMALLOC_TLS_MODEL"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c++",children:'dnl Use initial-exec TLS by default.\nAC_ARG_ENABLE([initial-exec-tls],\n  [AS_HELP_STRING([--disable-initial-exec-tls],\n                  [Disable the initial-exec tls model])],\n[if test "x$enable_initial_exec_tls" = "xno" ; then\n  enable_initial_exec_tls="0"\nelse\n  enable_initial_exec_tls="1"\nfi\n],\n[enable_initial_exec_tls="1"]\n)\nAC_SUBST([enable_initial_exec_tls])\n\nif test "x${je_cv_tls_model}" = "xyes" -a \\\n       "x${enable_initial_exec_tls}" = "x1" ; then\n  AC_DEFINE([JEMALLOC_TLS_MODEL],\n            [__attribute__((tls_model("initial-exec")))])\nelse\n  AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])\nfi\n\n'})}),"\n",(0,c.jsxs)(n.p,{children:["通过",(0,c.jsx)(n.code,{children:"JEMALLOC_TLS_MODEL"}),"，找到了",(0,c.jsx)(n.code,{children:"tsd.h"}),"，里面的头文件清晰的解释了定义与不定义",(0,c.jsx)(n.code,{children:"JEMALLOC_TLS_MODEL"}),"的区别,如果默认开启了initial-exec模型，即定义了",(0,c.jsx)(n.code,{children:"JEMALLOC_TLS_MODEL"}),"，则使用",(0,c.jsx)(n.code,{children:"tsd_tls.h"}),"，如果没有，则使用",(0,c.jsx)(n.code,{children:"tsd_generic.h"})]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c++",children:'//tsd.h\n#ifdef JEMALLOC_MALLOC_THREAD_CLEANUP\n#include "jemalloc/internal/tsd_malloc_thread_cleanup.h"\n#elif (defined(JEMALLOC_TLS))\n#include "jemalloc/internal/tsd_tls.h"\n#elif (defined(_WIN32))\n#include "jemalloc/internal/tsd_win.h"\n#else\n#include "jemalloc/internal/tsd_generic.h"\n#endif\n'})}),"\n",(0,c.jsxs)(n.p,{children:["查阅",(0,c.jsx)(n.code,{children:"tsd_tls.h"}),"源码：直接将变量赋值给了已经存在的内存地址"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c++",children:'//tsd_tls.h\n/* Get/set. */\nJEMALLOC_ALWAYS_INLINE tsd_t *\ntsd_get(bool init) {\n	return &tsd_tls;\n}\n\nJEMALLOC_ALWAYS_INLINE void\ntsd_set(tsd_t *val) {\n	assert(tsd_booted);\n	if (likely(&tsd_tls != val)) {\n		tsd_tls = (*val);\n	}\n	if (pthread_setspecific(tsd_tsd, (void *)(&tsd_tls)) != 0) {\n		malloc_write("<jemalloc>: Error setting tsd.\\n");\n		if (opt_abort) {\n			abort();\n		}\n	}\n}\n\n'})}),"\n",(0,c.jsxs)(n.p,{children:["查阅",(0,c.jsx)(n.code,{children:"tsd_generic.h"}),"：先申请内存空间，再将变量赋值给申请的内存地址"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c++",children:"//tsd_generic.h\n/* Get/set. */\nJEMALLOC_ALWAYS_INLINE tsd_t *\ntsd_get(bool init) {\n	tsd_wrapper_t *wrapper;\n\n	assert(tsd_booted);\n	wrapper = tsd_wrapper_get(init);\n	if (tsd_get_allocates() && !init && wrapper == NULL) {\n		return NULL;\n	}\n	return &wrapper->val;\n}\n\nJEMALLOC_ALWAYS_INLINE void\ntsd_set(tsd_t *val) {\n	tsd_wrapper_t *wrapper;\n	assert(tsd_booted);\n	wrapper = tsd_wrapper_get(true);\n	if (likely(&wrapper->val != val)) {\n		wrapper->val = *(val);\n	}\n	wrapper->initialized = true;\n\n}\n"})}),"\n",(0,c.jsxs)(n.p,{children:["综上分析，",(0,c.jsx)(n.code,{children:"jemalloc"}),"默认开启initial-exec模型，直接将静态",(0,c.jsx)(n.code,{children:"TLS"}),"变量指向已有的内存空间，但Python是使用",(0,c.jsx)(n.code,{children:"dlopen"}),"的方式加载动态库，即没有分配好的内存空间，因此相关报错大概率与",(0,c.jsx)(n.code,{children:"jemalloc"}),"的initial-exec模型特性有关。"]}),"\n",(0,c.jsxs)(n.h2,{id:"四实验验证",children:["四、实验验证",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四实验验证",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["根据分析结果，相关报错大概率与",(0,c.jsx)(n.code,{children:"jemalloc"}),"的initial-exec模型特性有关。那么可以通过在编译",(0,c.jsx)(n.code,{children:"jemalloc"}),"时启用和禁用该功能来判断该分析结论是否正确。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-mermaid",children:"graph TD\nA(开始) --\x3eB(准备依赖jemalloc的共享库libtest.so)\n	B --\x3e C(使用dlopen方式调用test.so)\n    C --\x3e D(对jemalloc重新编译禁用initial-exec)\n    D --\x3e E(使用dlopen方式调用test.so)\n    E --\x3e F(对比运行结果)\n    F --\x3e |满足实验期望|G(成功)\n    F --\x3e |不满足实验期望|H(失败)\n    G --\x3e I(结束)\n    H --\x3e I\n"})}),"\n",(0,c.jsx)(n.p,{children:"【影响分析】"}),"\n",(0,c.jsx)(n.p,{children:"根据问题分析中的源码分析可知，禁用与不禁用initial-exec的不同在于变量的内存空间分配上，不会对原有代码的功能逻辑产生影响。"}),"\n",(0,c.jsx)(n.p,{children:"【实验环境】"}),"\n",(0,c.jsxs)(n.p,{children:["系统：",(0,c.jsx)(n.code,{children:"uos 20 1030"})]}),"\n",(0,c.jsxs)(n.p,{children:["python：",(0,c.jsx)(n.code,{children:"3.7"})]}),"\n",(0,c.jsxs)(n.p,{children:["jemalloc:",(0,c.jsx)(n.code,{children:"5.1.0-3"})]}),"\n",(0,c.jsx)(n.p,{children:"【实验设计】"}),"\n",(0,c.jsx)(n.p,{children:"实验操作："}),"\n",(0,c.jsxs)(n.p,{children:["操作1：编译一个依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的动态库",(0,c.jsx)(n.code,{children:"libtest.so"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["操作2：对",(0,c.jsx)(n.code,{children:"jemalloc"}),"进行重新编译禁用initial-exec。"]}),"\n",(0,c.jsxs)(n.p,{children:["操作3：进行操作2前，使用",(0,c.jsx)(n.code,{children:"dlopen"}),"加载",(0,c.jsx)(n.code,{children:"libtest.so"}),"，记录运行结果。"]}),"\n",(0,c.jsxs)(n.p,{children:["操作4：进行操作2后，使用",(0,c.jsx)(n.code,{children:"dlopen"}),"加载",(0,c.jsx)(n.code,{children:"libtest.so"}),"，记录运行结果。"]}),"\n",(0,c.jsx)(n.p,{children:"实验步骤："}),"\n",(0,c.jsx)(n.p,{children:"操作1->操作3->操作2->操作4"}),"\n",(0,c.jsx)(n.p,{children:"实验期望：\n$$\n对jemalloc重新编译后，可通过dlopen方式正常加载test.so\n$$"}),"\n",(0,c.jsx)(n.p,{children:"【实验验证】"}),"\n",(0,c.jsxs)(n.p,{children:["步骤一：首先完成操作1，编译一个依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的动态库",(0,c.jsx)(n.code,{children:"libtest.so"}),"。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-c",children:'#include <iostream>\n\nusing namespace std;\n\nextern "C" {\n    unsigned long fibo(int n);\n}\nunsigned long fibo(int n)\n{\n    long result = 0;\n    if (n <= 0 || n > 100) { \n        result = 0;\n    }\n    else { \n        result=n;\n    }\n    return result;\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:"使用如下命令进行编译"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.code,{children:"g++ -fPIC -shared test.cpp -o libtest.so -ljemalloc"})}),"\n",(0,c.jsxs)(n.p,{children:["步骤二:使用Python直接调用",(0,c.jsx)(n.code,{children:"libtest.so"}),"，运行结果如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:'#python源码\nimport ctypes\nfrom utils import config\n#加载C++动态库\nlib = ctypes.cdll.LoadLibrary(config.so_path+\'/libtest.so\')\nprint(lib.fibo(8))\n\n#运行结果\n/usr/bin/python3.7 /home/mola/PycharmProjects/whitebox-autotest/utils/test1.py\nTraceback (most recent call last):\n  File "/home/mola/PycharmProjects/whitebox-autotest/utils/test1.py", line 11, in <module>\n    lib = ctypes.cdll.LoadLibrary(config.so_path+\'/test.so\')\n  File "/usr/lib/python3.7/ctypes/__init__.py", line 434, in LoadLibrary\n    return self._dlltype(name)\n  File "/usr/lib/python3.7/ctypes/__init__.py", line 356, in __init__\n    self._handle = _dlopen(self._name, mode)\nOSError: /lib/x86_64-linux-gnu/libjemalloc.so.2: cannot allocate memory in static TLS block\n\nProcess finished with exit code 1\n'})}),"\n",(0,c.jsxs)(n.p,{children:["步骤三：重新编译",(0,c.jsx)(n.code,{children:"jemalloc"}),"，禁用initial-exec"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:"1.下载jemalloc-5.1.0.tar.bz2\n2. tar -xjvf jemalloc-5.1.0.tar.bz2\n3. ./configure -prefix=/usr/local/jemalloc  --disable-initial-exec-tls\n4. make && make install\n5. cp /usr/local/jemalloc/lib/libjemalloc.so.2 /lib/x86_64-linux-gnu/\n"})}),"\n",(0,c.jsxs)(n.p,{children:["步骤四：使用Python直接调用",(0,c.jsx)(n.code,{children:"libtest.so"}),"，运行结果如下："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-python",children:"#python源码\nimport ctypes\nfrom utils import config\n#加载C++动态库\nlib = ctypes.cdll.LoadLibrary(config.so_path+'/libtest.so')\nprint(lib.fibo(8))\n\n#运行结果\n/usr/bin/python3.7 /home/mola/PycharmProjects/whitebox-autotest/utils/test1.py\n8\n\nProcess finished with exit code 0\n"})}),"\n",(0,c.jsx)(n.p,{children:"步骤五：运行结果对比"}),"\n",(0,c.jsxs)(n.p,{children:["根据实验结果，未禁用initial-exec时运行程序会报错、禁用initial-exec后程序可正常运行，即禁用前，需要提前预留内存并将其分配给相应的静态",(0,c.jsx)(n.code,{children:"TLS"}),"使用，禁用后，则不再需要提前分配内存，因此",(0,c.jsx)(n.strong,{children:"数据符合期望值"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"最终得出结论："})}),"\n",(0,c.jsxs)(n.p,{children:["Python调用动态库报错的根本原因是:",(0,c.jsx)(n.code,{children:"jemalloc"}),"默认打开了",(0,c.jsx)(n.code,{children:"Initial Executable (IE)"})," 模型，而Python是通过",(0,c.jsx)(n.code,{children:"dlopen"}),"的方式加载动态库，导致没有预留的内存可分配给相应的静态",(0,c.jsx)(n.code,{children:"TLS"}),"使用。"]}),"\n",(0,c.jsxs)(n.h2,{id:"五解决方案",children:["五、解决方案",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五解决方案",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["根据上述实验可知，在程序启动后，加载包含静态",(0,c.jsx)(n.code,{children:"TLS"}),"的共享对象时，会给这些静态",(0,c.jsx)(n.code,{children:"TLS"}),"分配内存，由于Python的第三方库",(0,c.jsx)(n.code,{children:"ctypes"}),"是使用",(0,c.jsx)(n.code,{children:"dlopen"}),"的方式加载动态库（",(0,c.jsx)(n.code,{children:"以dlopen的方式加载动态库只能在程序运行时进行内存分配，不能提前分配内存"}),"）导致报不能在静态",(0,c.jsx)(n.code,{children:"TLS"}),"中分配内存的错误。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"方案一：更换动态库的依赖对象"})}),"\n",(0,c.jsxs)(n.p,{children:["既然调用依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"的动态库，会报不能在静态",(0,c.jsx)(n.code,{children:"TLS"}),"中分配内存的错误，那么可以换一种内存分配器来规避该问题，常见的内存分配器有",(0,c.jsx)(n.code,{children:"tcmalloc"}),"、",(0,c.jsx)(n.code,{children:"jemalloc"}),"、",(0,c.jsx)(n.code,{children:"ptmalloc"}),"，如果我们的动态库在编译时没有指定",(0,c.jsx)(n.code,{children:"jemalloc"}),"，则默认链接到",(0,c.jsx)(n.code,{children:"ptmalloc"}),"，即经过上面的问题分析可知，使用",(0,c.jsx)(n.code,{children:"ptmalloc"}),"内存分配器不会出现相关报错。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["方案二：禁用",(0,c.jsx)(n.code,{children:"jemalloc"}),"的Initial Executable模型特性"]})}),"\n",(0,c.jsxs)(n.p,{children:["使用",(0,c.jsx)(n.code,{children:"jemalloc"}),"会报相关错误的原因是",(0,c.jsx)(n.code,{children:"jemalloc5"}),"新增了一个新特性，会在加载包含静态",(0,c.jsx)(n.code,{children:"TLS"}),"的动态库时给静态",(0,c.jsx)(n.code,{children:"TLS"}),"分配内存，但由于使用",(0,c.jsx)(n.code,{children:"dlopen"}),"的方式加载动态库，没有静态存储区可用，因此我们可以通过禁用",(0,c.jsx)(n.code,{children:"jemalloc"}),"的这个特性来解决这个问题，可使用shell脚本来实现该操作的自动化。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-shell",children:'#!/bin/bash\necho "1"|sudo -S su\napt source libjemalloc-dev\ncd jemalloc-5.1.0\n./configure -prefix=/usr/local/jemalloc  --disable-initial-exec-tls\nmake && make install\ncp /usr/local/jemalloc/lib/libjemalloc.so.2 /lib/x86_64-linux-gnu/\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"方案比较"})}),"\n",(0,c.jsxs)(n.p,{children:["从可行性、可操作性、稳定性等方面进行考虑可知，由于我们是通过Python加载动态库的方式对开发的C++源码进行测试，而开发构建出来的动态库在",(0,c.jsx)(n.code,{children:"X86"}),"平台和ARM平台默认依赖",(0,c.jsx)(n.code,{children:"jemalloc"}),"（",(0,c.jsx)(n.code,{children:"龙芯和申威未依赖jemalloc"}),"），如果要更换内存分配器，则潜在影响是未知且巨大的，方案一从可操作性、稳定性方面被否决；方案二目前能解决该问题，且可操作性很强，影响也较小。"]}),"\n",(0,c.jsxs)(n.table,{children:["\n",(0,c.jsxs)(n.thead,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.th,{}),"\n",(0,c.jsx)(n.th,{children:"方案一"}),"\n",(0,c.jsx)(n.th,{children:"方案二"}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.tbody,{children:["\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"可行性"}),"\n",(0,c.jsx)(n.td,{children:"可行"}),"\n",(0,c.jsx)(n.td,{children:"可行"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"易操作性"}),"\n",(0,c.jsx)(n.td,{children:"较差"}),"\n",(0,c.jsx)(n.td,{children:"较好"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"跨平台性"}),"\n",(0,c.jsx)(n.td,{children:"不可行"}),"\n",(0,c.jsx)(n.td,{children:"可行"}),"\n"]}),"\n",(0,c.jsxs)(n.tr,{children:["\n",(0,c.jsx)(n.td,{children:"稳定性"}),"\n",(0,c.jsx)(n.td,{children:"不稳定"}),"\n",(0,c.jsx)(n.td,{children:"稳定"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"影响评估:"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"jemalloc"}),"默认开启Initial Executable模型特性的优点：在对静态",(0,c.jsx)(n.code,{children:"TLS"}),"进行内存分配时可直接赋值，不需要每次都重新申请内存空间，可使性能有一定的提升。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"jemalloc"}),"禁用Initial Executable模型特性的影响：首先，在性能方面会有一定的影响，其次，在动态申请内存时会存在一定的风险，例如可能会遇到没有内存可用的极端情况等。本次使用场景为基于",(0,c.jsx)(n.code,{children:"Python"}),"、对Ｃ++动态库的白盒测试，因此在性能及其他方面的影响可忽略。"]}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.strong,{children:"最终结论："})}),"\n",(0,c.jsxs)(n.p,{children:["最终选择方案二来解决该问题，即禁用",(0,c.jsx)(n.code,{children:"jemalloc"}),"的Initial Executable模型特性。"]}),"\n",(0,c.jsxs)(n.h2,{id:"六小结",children:["六、小结",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六小结",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["问题描述：Python通过",(0,c.jsx)(n.code,{children:"ctypes"}),"第三方库调用C++ 动态库so文件中的函数，运行时报",(0,c.jsx)(n.code,{children:"libjemalloc.so.2 cannot allocate memory in static TLS block"}),"。"]}),"\n",(0,c.jsx)(n.p,{children:"根因查找步骤：现象->分析->假设->实验->验证->结论。"}),"\n",(0,c.jsxs)(n.p,{children:["根本原因：",(0,c.jsx)(n.code,{children:"jemalloc5"}),"有一个新特性，在加载共享对象时会给静态",(0,c.jsx)(n.code,{children:"TLS"}),"分配预留内存。由于Python使用",(0,c.jsx)(n.code,{children:"dlopen"}),"的方式加载共享对象，不能提前预分配内存导致报错。"]}),"\n",(0,c.jsxs)(n.p,{children:["解决方案：重新编译",(0,c.jsx)(n.code,{children:"jemalloc"}),"禁用Initial Executable模型特性。"]}),"\n",(0,c.jsxs)(n.p,{children:["优化/改进：可向在",(0,c.jsx)(n.code,{children:"jemalloc"}),"源码中自动判定是否需要开启",(0,c.jsx)(n.code,{children:"TLS"}),"的Initial Executable特性的方向探索"]}),"\n",(0,c.jsx)(n.p,{children:"收获与启示：在平时工作过程中，需要多多学习系统底层相关理论知识，在原理上实践。"}),"\n",(0,c.jsxs)(n.h2,{id:"七参考资料",children:["七、参考资料",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#七参考资料",children:"#"})]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://github.com/jemalloc/jemalloc/",target:"_blank",rel:"noopener noreferrer",children:"jemalloc源码"})}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["\n",(0,c.jsx)(n.p,{children:(0,c.jsx)(n.a,{href:"https://blog.csdn.net/foreverfresh/article/details/78932776",target:"_blank",rel:"noopener noreferrer",children:"TLS四种模式介绍"})}),"\n"]}),"\n"]})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(i,{...e})}):i(e)}let r=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["tech_doc%2F%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90%2FPython%E8%B0%83%E7%94%A8%E5%8A%A8%E6%80%81%E5%BA%93%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8A%A5%E9%9D%99%E6%80%81TLS%E5%9D%97%E4%B8%8D%E8%83%BD%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.md"]={toc:[{text:"一、相关术语",id:"一相关术语",depth:2},{text:"二、问题概述",id:"二问题概述",depth:2},{text:"三、问题分析",id:"三问题分析",depth:2},{text:"四、实验验证",id:"四实验验证",depth:2},{text:"五、解决方案",id:"五解决方案",depth:2},{text:"六、小结",id:"六小结",depth:2},{text:"七、参考资料",id:"七参考资料",depth:2}],title:"`Python`调用动态库运行时报静态`TLS`块不能分配内存根因分析报告",headingTitle:"`Python`调用动态库运行时报静态`TLS`块不能分配内存根因分析报告",frontmatter:{Author:"张芮"}}}}]);