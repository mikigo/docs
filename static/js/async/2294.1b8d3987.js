"use strict";(self.webpackChunk=self.webpackChunk||[]).push([["2294"],{7094:function(e,n,s){s.r(n),s.d(n,{default:()=>l});var r=s(2676),d=s(453);function c(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",h3:"h3",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",h4:"h4",pre:"pre",ul:"ul",li:"li",strong:"strong",br:"br"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"shell变量使用",children:["Shell变量使用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#shell变量使用",children:"#"})]}),"\n",(0,r.jsxs)(n.h2,{id:"1-变量的声明",children:["1. 变量的声明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-变量的声明",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"在Shell脚本内，变量是可以不先声明而直接使用的。有过传统语言编程经验的小伙伴习惯先声明再使用，这是个好的编程习惯。"}),"\n",(0,r.jsxs)(n.h3,{id:"11-常用内置变量",children:["1.1 常用内置变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-常用内置变量",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"函数或者命令接收参数时，按照位置获取参数。"}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"工具/表达式"}),"\n",(0,r.jsx)(n.th,{children:"案例说明"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$0"})}),"\n",(0,r.jsxs)(n.td,{children:["代表命令或者脚本本身，如常用",(0,r.jsx)(n.code,{children:"basename $0"})," 输出脚本名称本身。"]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$1~$n"})}),"\n",(0,r.jsxs)(n.td,{children:["第1个到第n个参数,从第10参数开始，引用时要加",(0,r.jsx)(n.code,{children:"{}"}),"，如$",(0,r.jsx)(n.code,{children:"{10}"})]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$#"})}),"\n",(0,r.jsx)(n.td,{children:"传入的参数个数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$*"})}),"\n",(0,r.jsx)(n.td,{children:"传入的全部参数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$@"})}),"\n",(0,r.jsx)(n.td,{children:"传入的全部参数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$$"})}),"\n",(0,r.jsx)(n.td,{children:"当前运行的进程ID"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$!"})}),"\n",(0,r.jsx)(n.td,{children:"最后一个后台进程的ID"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$?"})}),"\n",(0,r.jsx)(n.td,{children:"最后一个执行命令的返回码"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$_"})}),"\n",(0,r.jsx)(n.td,{children:"最后执行的命令的最后一个参数的值"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PPID"})}),"\n",(0,r.jsx)(n.td,{children:"shell 的父进程的进程号"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$BASH"})}),"\n",(0,r.jsx)(n.td,{children:"扩展为用来启动当前 bash 实例的文件全名"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$BASH_VERSION"})}),"\n",(0,r.jsxs)(n.td,{children:["一个只读数组变量，成员保存着当前 bash 实例的版本信息。","赋予数组元素的值是如下这些：       ",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[0]"}),"       主版本号 (release).",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[1]"}),"        次版本号 (version)."," ",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[2]"}),"        补丁版本",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[3]"}),"        编译信息",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[4]"}),"        发布时的状态 (例如, beta1).",(0,r.jsx)(n.code,{children:"BASH_VERSINFO[5]"}),"        MACHTYPE 平台类型"]}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$UID"})}),"\n",(0,r.jsx)(n.td,{children:"UID    扩展为当前用户的 ID，在启动时初始化。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$GROUPS"})}),"\n",(0,r.jsx)(n.td,{children:"一个数组变量，包含当前用户所属的组的列表"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$HOME"})}),"\n",(0,r.jsx)(n.td,{children:"前用户的个人家目录，内建命令 cd 的默认参数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$HOSTNAME"})}),"\n",(0,r.jsx)(n.td,{children:"自动设置为当前的主机名。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$IFS"})}),"\n",(0,r.jsx)(n.td,{children:"内部字段分隔符 Internal Field Separator 用来在扩展之后进行分词"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PATH"})}),"\n",(0,r.jsx)(n.td,{children:"索命令的路径"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PWD"})}),"\n",(0,r.jsx)(n.td,{children:"由 cd 命令设置的当前工作目录。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$OLDPWD"})}),"\n",(0,r.jsx)(n.td,{children:"上一次命令 cd 设置的工作目录。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$LINENO"})}),"\n",(0,r.jsx)(n.td,{children:"引用这个参数时，shell 将它替换为一个指示在脚本或函数中当前行号的十进制数字(从 1 开始)"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$FUNCNAME"})}),"\n",(0,r.jsx)(n.td,{children:"前执行的 shell 函数名。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$OSTYPE"})}),"\n",(0,r.jsx)(n.td,{children:"正在运行 bash 的操作系统类型。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$MACHTYPE"})}),"\n",(0,r.jsx)(n.td,{children:"正在运行 bash 的硬件系统类型"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$RANDOM"})}),"\n",(0,r.jsx)(n.td,{children:"引用这个参数时，都会产生一个 0 到 32767 之间的随机整数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$SECONDS"})}),"\n",(0,r.jsx)(n.td,{children:"引用这个参数时，返回 shell 自运行以来的秒数"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$TMOUT"})}),"\n",(0,r.jsx)(n.td,{children:"如果设置为大于  0 的值，TMOUT 被当作内建命令 read 的默认超时 等待时间。可以用来设置终端无操作的超时时间"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$HISTSIZE"})}),"\n",(0,r.jsx)(n.td,{children:"令历史中保存的历史数量,默认值是 500。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PS1"})}),"\n",(0,r.jsx)(n.td,{children:"用作主提示符字符串"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PS2"})}),"\n",(0,r.jsx)(n.td,{children:"个参数的值同 PS1 一起被扩展，用作次提示符字符串。"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"$PS4"})}),"\n",(0,r.jsx)(n.td,{children:"这个参数的值同 PS1 一起被扩展，在执行跟踪中在 bash 显示每个命令之前显示"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["更多内置变量详情，可查看",(0,r.jsx)(n.code,{children:"man bash"})]}),"\n",(0,r.jsxs)(n.h3,{id:"12-变量的声明",children:["1.2 变量的声明",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-变量的声明",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"121-变量的声明与赋值",children:["1.2.1 变量的声明与赋值",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#121-变量的声明与赋值",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/work/study/shell/share/1$ vi var.sh "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"#!/bin/bash\n  \nvar1=            #变量赋值为空串\nvar2=abc         #变量赋值为abc\nvar3='It sales $125.00'    #使用单引号，避免字符串$符号被解析\nvar4=\"It's my book.\"       #使用双引号\nvar5=\"${var4}\"             #变量的结果可以赋值给另一变量 \nvar6=4                     #变量值可以为数字， 在shell变量存储是以字符串方式存储\nvar7=3.14159\nvar8=$(( ( ${var6} + 10 ) * 2 ))  #表达式的结果可以赋值给变量 \nvar9=$( echo \"scale=2; ${var6}*${var7}/3\" | bc )   # 命令的执行结果可以赋值给变量 \nvar10=`expr ${var6} + ${var8}`    # 另一种执行命令的方式，结果赋值给变量 \nvar11=( 'a' 'b' 'c' 'd' )         # 变量可以为数组\nfunc() { echo $1; }; var12=$(func ${var6})   # 函数的执行结果可以赋值给变量 \n\nfor i in `seq 1 12`\ndo\n    [ $i -eq 11 ] && eval echo \"var${i}=\\${var${i}[@]}\" && continue\n    eval echo \"var${i}=\\${var${i}}\"\ndone\n"})}),"\n",(0,r.jsx)(n.p,{children:"脚本执行结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/work/study/shell/share/1$ bash var.sh \nvar1=\nvar2=abc\nvar3=It sales $125.00\nvar4=It's my book.\nvar5=It's my book.\nvar6=4\nvar7=3.14159\nvar8=28\nvar9=4.18\nvar10=32\nvar11=a b c d\nvar12=4\n"})}),"\n",(0,r.jsx)(n.p,{children:"注意以下几点："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"变量名由数字、字母、下划线组成，并且必须以数字，字母开头，不能包含Shell关键字。"}),"\n",(0,r.jsxs)(n.li,{children:["变量名称与值之间用",(0,r.jsx)(n.code,{children:"="}),"连接，",(0,r.jsx)(n.code,{children:"="}),"两点不能有空格。在",(0,r.jsx)(n.code,{children:"$((...))"}),",",(0,r.jsx)(n.code,{children:"$[...]"})," 表达式内除外。"]}),"\n",(0,r.jsx)(n.li,{children:"Bash变量可以不用指定类型，默认都是字符串。"}),"\n",(0,r.jsx)(n.li,{children:"变量赋值使用单引确保引号内的字符串不被转义，不被解析，保持原本输出。 而使用双引号，引号内字符串包含变量，命令，转义符将先会被解析后再赋值给变量。"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"122-删除变量",children:["1.2.2 删除变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#122-删除变量",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"unset var             # 清除变量\n"})}),"\n",(0,r.jsxs)(n.h4,{id:"123-readonly只读变量",children:["1.2.3 ",(0,r.jsx)(n.code,{children:"readonly"}),"只读变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#123-readonly只读变量",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["用",(0,r.jsx)(n.code,{children:"readonly"}),"声明的变量是只读的，不能修改。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nreadonly rvar="TEST"\nrvar="MOD"\n'})}),"\n",(0,r.jsx)(n.p,{children:"执行修改："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/work/study/shell/share/1$ bash readonly.sh\nreadonly.sh:行4: rvar：只读变量\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"注意"}),"\n",(0,r.jsx)(n.code,{children:"readonly"}),"和",(0,r.jsx)(n.code,{children:"local"}),"不能同时使用，如果同时使用，则在最前面的生效，后面的则失效，具体原理尚未深究。",(0,r.jsx)(n.br,{}),"\n","如 ",(0,r.jsx)(n.code,{children:"readonly loacl var=123"})," : ",(0,r.jsx)(n.code,{children:"readonly"}),"生效，",(0,r.jsx)(n.code,{children:"local"}),"失效。",(0,r.jsx)(n.br,{}),"\n","如 ",(0,r.jsx)(n.code,{children:"local readonly var=123"})," ：",(0,r.jsx)(n.code,{children:"local"}),"生效，",(0,r.jsx)(n.code,{children:"readonly"}),"失效。"]}),"\n",(0,r.jsxs)(n.h4,{id:"124-declare声明变量",children:["1.2.4 ",(0,r.jsx)(n.code,{children:"declare"}),"声明变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#124-declare声明变量",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"declare -i"})," : 声明整型变量"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ declare -i intval=123   #声明一个整型\ntest@test-PC:~/share/1$ echo $intval \n123\ntest@test-PC:~/share/1$ intval=abc    #将字符串赋值给整型变量，结果被转换为0\ntest@test-PC:~/share/1$ echo $intval \n0\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"declare -r"}),": 声明只读变量"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ declare -r rdval=123  #声明只读变量，等同readonly rdval=123\ntest@test-PC:~/share/1$ rdval=456    #只读变量不能被修改\n-bash: rdval：只读变量\ntest@test-PC:~/share/1$ echo $rdval \n123\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"declare -a"}),": 声明数组变量"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ declare arr=('a' 'b' 1 2)\ntest@test-PC:~/share/1$ echo ${arr[@]}\na b 1 2\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"declare -f"}),": 声明函数\n在函数定义之前可以先声明"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'declare -f call_script\n\ncall_script()\n{\n    echo "[$(basename $0)] - call declare_test.sh"\n}\n'})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"declare -x"}),": 声明环境变量"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"声明变量为环境变量，可在当前Shell进程及其子进程中使用。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi declare.sh "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \ndeclare -i intval=123\ndeclare -r rdval=123\ndeclare -a arr=123\ndeclare -f call_script\n\ndeclare -x DECLARE_XVAL  # 声明了一个环境变量\ncall_script()\n{\n    echo "[$(basename $0)] - call declare_test.sh"  \n    DECLARE_XVAL="This_is_a_TEST_program"   #主进程中赋值环境变量\n    bash declare_test.sh   #调用子脚本，在子进程中使用环境变量\n}\n\ncall_script   #调用声明的函数\n'})}),"\n",(0,r.jsxs)(n.p,{children:["子进程脚本如下：\n",(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi declare_test.sh "})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash  \necho "[$(basename $0)] - DECLARE_XVAL=${DECLARE_XVAL}"\n'})}),"\n",(0,r.jsx)(n.p,{children:"调用主脚本，执行结果如下,在子脚本中打印出了环境变量的值。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/hare/1$ bash declare.sh \n[declare.sh] - call declare_test.sh\n[declare_test.sh] - DECLARE_XVAL=This_is_a_TEST_program\n"})}),"\n",(0,r.jsx)(n.p,{children:"如果单独调用子脚本，这个变量是没有赋值的。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ bash declare_test.sh \n[declare_test.sh] - DECLARE_XVAL=\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"注意"}),"：\n实际测试，如果",(0,r.jsx)(n.code,{children:"declare"}),"声明的变量是在函数体内，则变量的作用域也仅是函数体内有效。具体原理尚未深究。"]}),"\n",(0,r.jsxs)(n.h2,{id:"2-变量的应用",children:["2 变量的应用",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-变量的应用",children:"#"})]}),"\n",(0,r.jsxs)(n.h3,{id:"21-变量的作用域",children:["2.1 变量的作用域",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-变量的作用域",children:"#"})]}),"\n",(0,r.jsxs)(n.h4,{id:"211-全局变量",children:["2.1.1 全局变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#211-全局变量",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["全局变量的作用域是从变量定义位置开始，到Shell进程结束，全局变量的作用域不包含当前进程的子进程。",(0,r.jsx)(n.br,{}),"\n","全局变量的声明：\n",(0,r.jsx)(n.code,{children:"VariableName=Value"}),"\n如",(0,r.jsx)(n.code,{children:'var="abc"'}),"或者",(0,r.jsx)(n.code,{children:'global var="abc"'}),"，以下示例来演示全局变量的作用域。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi global.sh  "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nfunc1() {\n    #依次打印[进程ID]<脚本名:函数名:行号>  变量名称=变量值\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "main_var=$main_var"\n}\n\nfunc2() {\n    main_var="This is main_var"   #在func2中定义了全局变量，作用域从定义的位置开始到进程结束\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "main_var=$main_var"\n}\n\nmain() {\n    func1     #调用func1，此时main_var还未定义\n    func2     #调用func2，此时main_var已经定义\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "main_var=$main_var"\n    source source.sh   #用source调用脚本，souce.sh脚本中的代码导入到当前进程中。 注意，这里还是当前的shell进程\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "source_var=$source_var"\n\n    bash extern.sh   #用bash调用脚本，注意，extern.sh脚本是开启新的进程去执行\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "extern_var=$extern_var"\n}\n\nmain\n'})}),"\n",(0,r.jsxs)(n.p,{children:["在以下脚本中调用的两个脚本分别定义如下：\n",(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi source.sh "})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash  \nsource_var="This is source_var\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi extern.sh"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nprint_var() {\n     printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "main_var=$main_var"\n}\n\nset_var() {\n     extern_var="This is extern_var"  #定义了全局变量，只在当前进程有效\n}\nprint_var\nset_var\n'})}),"\n",(0,r.jsxs)(n.p,{children:["执行主脚本",(0,r.jsx)(n.code,{children:"global.sh"}),"，结果如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/work/study/shell/share/1$ bash global.sh \n[28581]<global.sh:func1:4>     : main_var=\n[28581]<global.sh:func2:9>     : main_var=This is main_var\n[28581]<global.sh:main:15>     : main_var=This is main_var\n[28581]<global.sh:main:17>     : source_var=This is source_var\n[28586]<extern.sh:print_var:4> : main_var=\n[28581]<global.sh:main:20>     : extern_var=\n"})}),"\n",(0,r.jsx)(n.p,{children:"说明："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["1）",(0,r.jsx)(n.code,{children:"<global.sh:func1:4>"}),"函数位置，",(0,r.jsx)(n.code,{children:"main_var"}),"尚未定义，所以值为空。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["2）",(0,r.jsx)(n.code,{children:"<global.sh:func2:9>"}),"函数位置，",(0,r.jsx)(n.code,{children:"main_var"}),"已定义，打印值有效。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["3）",(0,r.jsx)(n.code,{children:"<global.sh:main:15>"}),"在",(0,r.jsx)(n.code,{children:"main"}),"在",(0,r.jsx)(n.code,{children:"func2"}),"后执行，",(0,r.jsx)(n.code,{children:"main_var"}),"已定义，值有效。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["4）",(0,r.jsx)(n.code,{children:"<global.sh:main:17>"}),"变量",(0,r.jsx)(n.code,{children:"source_var"}),"在",(0,r.jsx)(n.code,{children:"source.sh"}),"定义，并且以source的方式导入，还在当前进程中，所以变量",(0,r.jsx)(n.code,{children:"source_var"}),"有效。 以都是在同一进程内运行，进程ID:28581。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["5）",(0,r.jsx)(n.code,{children:"<extern.sh:print_var:4>"}),"，当前是在新进程中运行，进程ID:28286。它打印主进程main_var是无效的，因为已经不在变量的作用域内。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["6）",(0,r.jsx)(n.code,{children:"<global.sh:main:20>"})," 同理，",(0,r.jsx)(n.code,{children:"extern_var"}),"是在子进程",(0,r.jsx)(n.code,{children:"extern.sh"}),"中定义，也已经超出了变量的作用域，打印无效。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"212-局部变量",children:["2.1.2 局部变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#212-局部变量",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["局部变量的作用域是在函数体内定义的位置开始，到函数执行完毕。",(0,r.jsx)(n.br,{}),"\n","局部变量的定义，使用",(0,r.jsx)(n.code,{children:"local"}),"来定义局部变量，",(0,r.jsx)(n.code,{children:"local"}),"只能在函数中使用。",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:"local VariableName=Value"}),"，如",(0,r.jsx)(n.code,{children:"local var=123"}),"。如下示例演示局部变量的作用域。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi local.sh"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nfunc1() {\n    local local_var=3    #定义了局部变量\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "local_var=$local_var"\n}\n\nmain(){\n    func1\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "local_var=$local_var"  #在函数外打印局部变量的值\n}\n\nmain\n'})}),"\n",(0,r.jsx)(n.p,{children:"调用执行结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/work/study/shell/share/1$ bash local.sh \n[1491]<local.sh:func1:5>       : local_var=3\n[1491]<local.sh:main:10>       : local_var=\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，",(0,r.jsx)(n.code,{children:"local_var"}),"变量只是在函数",(0,r.jsx)(n.code,{children:"func"})," 是有效的，函数外打印无效。"]}),"\n",(0,r.jsxs)(n.h4,{id:"213-环境变量",children:["2.1.3 环境变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#213-环境变量",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["环境变量对当前Shell进程及其子进程都是生效的，但不对当前Shell的父进程生效，不同Shell进程也是不生效的。",(0,r.jsx)(n.br,{}),"\n","假如脚本间有如下调用关系："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"A.sh -> B.sh ->C.sh   #A.sh调用B.sh, B.sh调用C.sh\nZ.sh                  #Z.sh独立调用\n"})}),"\n",(0,r.jsxs)(n.p,{children:["在脚本",(0,r.jsx)(n.code,{children:"B.sh"}),"定义了环境变量，那么变量在",(0,r.jsx)(n.code,{children:"B.sh"}),"和",(0,r.jsx)(n.code,{children:"C.sh"}),"是生效的，但是对于调用它的",(0,r.jsx)(n.code,{children:"A.sh"}),"是不生效的， 而",(0,r.jsx)(n.code,{children:"Z.sh"}),"独立进程调用，所以",(0,r.jsx)(n.code,{children:"B.sh"}),"中定义的环境变量在",(0,r.jsx)(n.code,{children:"Z.sh"}),"也是无效的。"]}),"\n",(0,r.jsxs)(n.p,{children:["环境变量的声明：\n",(0,r.jsx)(n.code,{children:"export VARIABLENAME=Value"}),"，如",(0,r.jsx)(n.code,{children:"local PROJECT_NAME=menu"}),"。",(0,r.jsx)(n.br,{}),"\n","也可以",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:"declare -x VARIABLENAME=Value"}),",如",(0,r.jsx)(n.code,{children:"declare PROJECT_NAME=menu"}),"。",(0,r.jsx)(n.br,{}),"\n","一般我们习惯用大写字母表示环境变量，以下示例演示环境变量的作用域:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi export.sh "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nfunc1() {\n    export MAIN_ENV=project    #声明了环境变量MAIN_ENV\n}\n\nmain(){\n    func1\n    bash extern.sh   #开辟新进程调用子脚本\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "EXTERN_ENV=$EXTERN_ENV"   #打印子进程环境变量EXTERN_ENV\n}\n\nmain\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi extern.sh "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nprint_env(){\n    export EXTERN_ENV="extern_env_value"   #声明环境变量EXTERN_ENV\n    printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "MAIN_ENV=$MAIN_ENV"   #打印父进程环境变量\n}\nprint_env\nbash subextern.sh   #开辟新进程调用子脚本\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi subextern.sh "})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\n  \nsub_print_env() {\n     printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "MAIN_ENV=$MAIN_ENV"   #打印爷爷进程的环境变量 \n     printf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "EXTERN_ENV=$EXTERN_ENV"  #打印父进程的环境变量\n}\nsub_print_env\n'})}),"\n",(0,r.jsx)(n.p,{children:"调用主父进程脚本，执行结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ bash export.sh \n[17698]<extern.sh:print_env:9> : MAIN_ENV=project\n[17700]<subextern.sh:sub_print_env:4> : MAIN_ENV=project\n[17700]<subextern.sh:sub_print_env:5> : EXTERN_ENV=extern_env_value\n[17697]<export.sh:main:10>     : EXTERN_ENV=\n"})}),"\n",(0,r.jsx)(n.p,{children:"分析："}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["1） 输出第一行：子进程",(0,r.jsx)(n.code,{children:"extern.sh"}),"打印出了父进程中定义的",(0,r.jsx)(n.code,{children:"MAIN_ENV"}),"值。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["2） 输出第二行：孙进程",(0,r.jsx)(n.code,{children:"subextern.sh"}),"打印出了爷爷进程的环境变量",(0,r.jsx)(n.code,{children:"MAIN_ENV"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["3） 输出第三行:孙进程",(0,r.jsx)(n.code,{children:"subextern.sh"}),"打印出了父进程的环境变量",(0,r.jsx)(n.code,{children:"EXTERN_ENV"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["4）输出第四行：主父进程",(0,r.jsx)(n.code,{children:"export.sh"}),"尝试打印子进程",(0,r.jsx)(n.code,{children:"extern.sh"}),"的环境变量",(0,r.jsx)(n.code,{children:"EXTERN_ENV"}),"不成功，已经超出了环境变量的作用域范围。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["然后再编写一个独立调用的脚本，它与前三个脚本是不相关，不过是在同一Shell终端下执行。\n",(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi third.sh "})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'#!/bin/bash\n  \nprintf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "ENV_NAME=$ENV_NAME"\nprintf "%-30s : %s\\n" "[$$]<$(basename $0):$FUNCNAME:$LINENO>" "EXTERN_ENV=$EXTERN_ENV"\n'})}),"\n",(0,r.jsx)(n.p,{children:"调用执行结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/work/study/shell/share/1$ bash third.sh   \n[16280]<third.sh::3>           : ENV_NAME=\n[16280]<third.sh::4>           : EXTERN_ENV=\n"})}),"\n",(0,r.jsxs)(n.p,{children:["因为与前面脚本",(0,r.jsx)(n.code,{children:"export.sh"}),"与相互独立的，无法共享环境变量。"]}),"\n",(0,r.jsxs)(n.p,{children:["但是，它们都是在同一Shell终端下运行，也就是它有共同的父进程，所以如果需要共享环境变量，只需要在当前Shell终端下设置一个环境变量就可以了， 如：",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:'test@test-PC:~/share/1$ export EXPORT_TEST="export_test"'}),(0,r.jsx)(n.br,{}),"\n","然后在",(0,r.jsx)(n.code,{children:"export.sh"}),"和",(0,r.jsx)(n.code,{children:"third.sh"}),"脚本入口添加打印代码：",(0,r.jsx)(n.br,{}),"\n",(0,r.jsx)(n.code,{children:"echo EXPORT_TEST=$EXPORT_TEST"}),(0,r.jsx)(n.br,{}),"\n","执行两个脚本，结果如下："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ bash export.sh \nEXPORT_TEST=export_test\ntest@test-PC:~/share/1$ bash third.sh \nEXPORT_TEST=export_test\n"})}),"\n",(0,r.jsxs)(n.p,{children:["可以看到，打印出了共享的环境变量。也可以查看当前Shell终端的环境变量，已经包含了",(0,r.jsx)(n.code,{children:"EXPORT_TEST"}),"。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ env | grep EXPORT_TEST\nEXPORT_TEST=export_test\n"})}),"\n",(0,r.jsxs)(n.p,{children:["但是，这也仅对当前登录的Shell终端生效，但关掉终端重新打开又是一个新的Shell终端，要想永久生效，可以写入环境变量配置文件，如",(0,r.jsx)(n.code,{children:"~/.bashrc"}),"或",(0,r.jsx)(n.code,{children:"~/.bash_profile"}),"等 。Shell终端在登录的时候会自动加载共同的环境变量配置文件，保持在整个终端持续期间生效。"]}),"\n",(0,r.jsxs)(n.h3,{id:"22-变量替换",children:["2.2 变量替换",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-变量替换",children:"#"})]}),"\n",(0,r.jsxs)(n.table,{children:["\n",(0,r.jsxs)(n.thead,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.th,{children:"表达式"}),"\n",(0,r.jsx)(n.th,{children:"案例说明"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.tbody,{children:["\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${var:-word}"})}),"\n",(0,r.jsx)(n.td,{children:"如果变量var已经设置且非空，结果为var的值，否则结果为word"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${var:=word}"})}),"\n",(0,r.jsx)(n.td,{children:"如果变量var已经设置且非空，结果为var的值，否则设置var为word"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${var:+word}"})}),"\n",(0,r.jsx)(n.td,{children:"如果变量var已经设置且非空，则设置var的值为word;否则不替换"}),"\n"]}),"\n",(0,r.jsxs)(n.tr,{children:["\n",(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"${var:?word}"})}),"\n",(0,r.jsx)(n.td,{children:"如果变量var已经设置且非空，则替换为word，否则退出shell。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"23-变量嵌套",children:["2.3 变量嵌套",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-变量嵌套",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"变量嵌套一般是变量名中仍然包含变量，需要做二次解析，最终求出变量的结果。"}),"\n",(0,r.jsxs)(n.h4,{id:"231-eval",children:["2.3.1 ",(0,r.jsx)(n.code,{children:"eval"}),(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#231-eval",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"eval"}),"命令将会首先扫描命令行进行所有的替换，然后再执行命令。\n",(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi eval.sh "})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nvar1=abc\nvar2=\'It sales $125.00\'\nvar3="It\'s my book."\nvar4=4\nvar5=3.14159\n\nfor i in `seq 1 5`\ndo\n    eval echo "var${i}=\\${var${i}}"  \n    #eval echo "var${i}=\'$\'{var${i}}"\ndone\n\n'})}),"\n",(0,r.jsxs)(n.p,{children:["如下，",(0,r.jsx)(n.code,{children:"i"}),"也循环变量，需要",(0,r.jsx)(n.code,{children:"eval"}),"将字符串的变量解析，然后",(0,r.jsx)(n.code,{children:"echo"}),"执行打印。外层变量的",(0,r.jsx)(n.code,{children:"$"}),"要做转义，否则再未被解析之前会被认为是非法的引用。当然转义也可以用单引号代替。"]}),"\n",(0,r.jsxs)(n.h4,{id:"232-varname变量名前缀",children:["2.3.2 ",(0,r.jsx)(n.code,{children:"${!varname*}"}),"变量名前缀",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#232-varname变量名前缀",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["扩展为名称以 prefix 开始的变量名，匹配",(0,r.jsx)(n.code,{children:"varname"}),"为形状的所有变量名。\n先从简单示例开始："]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nname="Tom"\ncolumn="name"\necho ${!column}\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"column"}),"先替换为变量 ",(0,r.jsx)(n.code,{children:"name"}),"，然后再取变量值，运行结果为：",(0,r.jsx)(n.code,{children:"Tom"}),"\n然后再实现上一例子：\n",(0,r.jsx)(n.code,{children:"test@test-PC:~/share/1$ vi eval.sh"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'#!/bin/bash\nvar1=abc\nvar2=\'It sales $125.00\'\nvar3="It\'s my book."\nvar4=4\nvar5=3.14159\n\nfor var in ${!var*}\ndo\n   echo "$var=${!var}"\ndone\n'})}),"\n",(0,r.jsx)(n.p,{children:"执行结果如下："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"test@test-PC:~/share/1$ bash eval.sh   \nvar1=abc\nvar2=It sales $125.00\nvar3=It's my book.\nvar4=4\nvar5=3.14159\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"3-awksed内使用外部变量",children:["3 awk/sed内使用外部变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-awksed内使用外部变量",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["在实际编程中，经常会遇到把shell定义的变量传入给",(0,r.jsx)(n.code,{children:"sed"}),"和",(0,r.jsx)(n.code,{children:"awk"}),"使用，这跟我们普通的命令与函数传参略微有所不同。"]}),"\n",(0,r.jsxs)(n.h4,{id:"31-sed使用外部变量",children:["3.1 sed使用外部变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31-sed使用外部变量",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"以下三种方法都是可以的"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'test@test-PC:~/share/1$ str="DEF";echo "ABC123FGH"|sed "s/123/"${str}"/g"    \nABCDEFFGH\ntest@test-PC:~/share/1$ str="DEF";echo "ABC123FGH"|sed \'s/123/\'"${str}"\'/g\'  \nABCDEFFGH\ntest@test-PC:~/share/1$ str="DEF";echo "ABC123FGH"|sed \'s/123/\'${str}\'/g\'  \nABCDEFFGH\n'})}),"\n",(0,r.jsxs)(n.h4,{id:"32-awk使用外部变量",children:["3.2 awk使用外部变量",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32-awk使用外部变量",children:"#"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'test@test-PC:~/share/1$ str="DEF";echo "ABC123FGH"|awk \'{gsub("123","\'"${str}"\'",$1);print $1}\'  \nABCDEFFGH\ntest@test-PC:~/share/1$ str="DEF";echo "ABC123FGH"|awk -v var=${str} \'{gsub("123",var,$1);print $1}\' \nABCDEFFGH\n'})})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}let l=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2FShell%2FShell%E5%8F%98%E9%87%8F%E4%BD%BF%E7%94%A8.md"]={toc:[{text:"1. 变量的声明",id:"1-变量的声明",depth:2},{text:"1.1 常用内置变量",id:"11-常用内置变量",depth:3},{text:"1.2 变量的声明",id:"12-变量的声明",depth:3},{text:"1.2.1 变量的声明与赋值",id:"121-变量的声明与赋值",depth:4},{text:"1.2.2 删除变量",id:"122-删除变量",depth:4},{text:"1.2.3 `readonly`只读变量",id:"123-readonly只读变量",depth:4},{text:"1.2.4 `declare`声明变量",id:"124-declare声明变量",depth:4},{text:"2 变量的应用",id:"2-变量的应用",depth:2},{text:"2.1 变量的作用域",id:"21-变量的作用域",depth:3},{text:"2.1.1 全局变量",id:"211-全局变量",depth:4},{text:"2.1.2 局部变量",id:"212-局部变量",depth:4},{text:"2.1.3 环境变量",id:"213-环境变量",depth:4},{text:"2.2 变量替换",id:"22-变量替换",depth:3},{text:"2.3 变量嵌套",id:"23-变量嵌套",depth:3},{text:"2.3.1 `eval`",id:"231-eval",depth:4},{text:"2.3.2 `${!varname*}`变量名前缀",id:"232-varname变量名前缀",depth:4},{text:"3 awk/sed内使用外部变量",id:"3-awksed内使用外部变量",depth:2},{text:"3.1 sed使用外部变量",id:"31-sed使用外部变量",depth:4},{text:"3.2 awk使用外部变量",id:"32-awk使用外部变量",depth:4}],title:"Shell变量使用",headingTitle:"Shell变量使用",frontmatter:{Author:"海针-搬运"}}}}]);