[{"id":0,"title":"菜谱-预览","content":"","routePath":"/cookbook/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"菜谱-预览"},"version":""},{"id":1,"title":"牛肝菌炒肉","content":"#","routePath":"/cookbook/家常菜/牛肝菌炒肉","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"火锅（家庭版）","content":"#","routePath":"/cookbook/特色菜/火锅","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"麻辣小龙虾","content":"#","routePath":"/cookbook/特色菜/麻辣小龙虾","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"鸡汤","content":"#\n\n\n纯鸡汤#\n\n\n菌菇鸡汤#","routePath":"/cookbook/营养汤/鸡汤","lang":"","toc":[{"text":"纯鸡汤","id":"纯鸡汤","depth":2,"charIndex":3},{"text":"菌菇鸡汤","id":"菌菇鸡汤","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"代码提交流程与常见场景","content":"#\n\n\ngit代码提交流程#\n\n * 本地创建密钥对，git项目中部署公钥\n\n\n\n * 克隆代码至本地仓库\n\n\n\n * 修改代码后提交（注意：若修改文件为公共文件，则以文件为最小单位提交合并请求，禁止同时修改多个公共文件，避免增加冲突几率）\n\n\n\n\ngreeit代码提交流程#\n\n背景：代码管理引入gerrit工具，主要实现提交代码前：自动代码扫描+人工代码审核，提升代码质量，具体提交流程如下：\n\n * 本地创建密钥对，获取公钥\n\n\n\n * 访问gerrit进行公钥部署：\n   * gerrit地址：点击跳转\n   * 设置页面滑动至设置项：SSH keys\n   * New SSH key输入框中公钥\n   * 点击按钮ADD NEW SSH KEY\n * 安装git-review：sudo apt install git-review\n * 克隆gerrit自动化测试仓库至本地\n\n\n\n * 修改代码后提交至gerrit仓库（注意：若修改文件为公共文件，则以文件为最小单位提交合并请求，禁止同时修改多个公共文件，避免增加冲突几率）\n\n\n\n * 登录gerrit网址，gerrit地址：点击跳转\n\n * 选择自己提交的记录，增加审核+1人员：点击ADD REVIEWER\n\n * 通知审核人员审核修改代码是否符合规范\n\n * 审核人员检查代码，点击REPLY填写结果：\n   \n   * 通过：+1\n   * 不通过：-1（针对错误代码处，可点击进行评论）\n\n * +1审核通过后，通知+2审核人员，进行最终审核并合并代码\n\n注意： 提交前请仔细检查\n\n\n分支管理#\n\n\n查看分支#\n\n使用命令：git branch\n\n * 查看本地分支\n\n\n\n * 查看本地+远程分支\n\n\n\n\n新建分支#\n\n使用命令：git branch 分支名称\n\n * 查看分支\n\n\n\n * 创建分支\n\n\n\n * 创建之后再次查看，可看到新建分支，master分支前面有个星号，代表此时还在master分支上\n\n\n\n\n切换分支#\n\n使用命令：git checkout 分支名称\n\n * 创建分支，默认在master上，切换到新的分支hhz上\n\n\n\n * 切换成功，查看当前的所有分支\n\n\n\n * 查看当前分支状态也可以用git status\n\n\n\n * 创建分支的同时并切换分支\n\n\n\n * 等同于：先创建分支，再切换分支\n\n\n\n\n删除本地分支#\n\n删掉本地的分支，使用git branch —delete 分支名称\n\n * —delete缩写就是-d，可以使用 git branch -d 分支名称来代替\n   \n   * 注意：使用—delete删除分支时,该分支必须完全和它的上游分支merge完成,如果没有上游分支,必须要和HEAD完全merge\n\n * -D 是—delete —force的缩写,这样写可以在不检查merge状态的情况下删除分支\n   \n   * —force\n     简写-f,作用是将当前branch重置到初始点(startpoint),如果不使用—force的话,git分支无法修改一个已经存在的分支.\n\n在不检查merge状态的情况下删除分支，使用git branch -D 分支名称 ，它是git branch --delete --force 分支名称的缩写\n\n**注意：**无法直接删除当前分支，需切换至其他分支\n\n\n\n\n删除远程分支#\n\n通过本地的命令行删除远程分支，使用git push origin -—delete 分支名称\n\n\n\n\n文件管理#\n\n\n恢复代码#\n\n放弃修改#\n\ngit reset --hard {commint id}\n\n代码整体回退到该次提交，所有修改均放弃。\n\n保留修改#\n\ngit reset --soft {commint id}\n\n代码当前指针移到该次提交，所有修改均保留。\n\n备注：常用于代码提交后被驳回，此时可移动指针后再次提交代码即可。\n\n\n恢复文件#\n\n恢复最新版本#\n\n * 本地修改未提交\n\n\n\n * 本地修改，已提交至暂存区（即编辑之后，git add但没有 git commit -m ....）\n\n\n\n * 本地修改，已提交至仓库区（即编辑之后，git add和 git commit -m ....）\n\n\n\n恢复至任意版本#\n\n\n\n\n拉取代码差异#\n\n使用git pull 与 git pull --rebase的差异，建议使用git pull --rebase，使提交曲线为直线，让大家易于理解。\n\n * git pull = git fetch + git merge\n\n\n\n * git pull --rebase = git fetch + git rebase\n\n\n\n\n文件冲突#\n\n * git pull --rebase:\n\n\n\n\n异常问题收集#\n\ngit config报错#\n\n操作人：黄海针\n\n操作背景：执行命令$ git config --global user.email \"huanghaizhen@uniontech.com\"失败\n\n报错：error: 不能锁定配置文件 /home/mars/.gitconfig: 权限不够\n\n根因：执行以上命令时，会在家目录创建文件.gitconfig，显然该提示是因为权限不够，查看家目录权限为555（why？）\n\n解决方案：修改家目录权限为755解决问题，需要注意的时，在以上命令前加sudo任然无法创建文件.gitconfig\n\n参考资料：暂无","routePath":"/博客/2024/AT代码提交流程与常见场景","lang":"","toc":[{"text":"git代码提交流程","id":"git代码提交流程","depth":2,"charIndex":3},{"text":"greeit代码提交流程","id":"greeit代码提交流程","depth":2,"charIndex":124},{"text":"分支管理","id":"分支管理","depth":2,"charIndex":682},{"text":"查看分支","id":"查看分支","depth":3,"charIndex":690},{"text":"新建分支","id":"新建分支","depth":3,"charIndex":744},{"text":"切换分支","id":"切换分支","depth":3,"charIndex":850},{"text":"删除本地分支","id":"删除本地分支","depth":3,"charIndex":1007},{"text":"删除远程分支","id":"删除远程分支","depth":3,"charIndex":1424},{"text":"文件管理","id":"文件管理","depth":2,"charIndex":1484},{"text":"恢复代码","id":"恢复代码","depth":3,"charIndex":1492},{"text":"放弃修改","id":"放弃修改","depth":4,"charIndex":1499},{"text":"保留修改","id":"保留修改","depth":4,"charIndex":1559},{"text":"恢复文件","id":"恢复文件","depth":3,"charIndex":1655},{"text":"恢复最新版本","id":"恢复最新版本","depth":4,"charIndex":1662},{"text":"恢复至任意版本","id":"恢复至任意版本","depth":4,"charIndex":1795},{"text":"拉取代码差异","id":"拉取代码差异","depth":2,"charIndex":1808},{"text":"文件冲突","id":"文件冲突","depth":2,"charIndex":1981},{"text":"异常问题收集","id":"异常问题收集","depth":3,"charIndex":2014},{"text":"git config报错","id":"git-config报错","depth":4,"charIndex":2023}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":7,"title":"AT 开发规范","content":"#\n\nAT 开发规范是根据自动化测试运行多年以来，遇到问题解决问题而形成的一些解决方案，或者说经验总结；\n\n这些经验符合我们现阶段 AT 所应用的场景需要，也是我们经过长期思考，不断试错不断修正，并在自动化测试项目实践中检验过可行的。\n\n以此，希望能帮助参与到自动化的相关人员减少试错成本，更好、更快的编写用例及维护用例。\n\n\n1. 版本及依赖#\n\n基础框架会根据自身的功能开发进行版本迭代发布，基础框架不与某个应用版本绑定；\n\n但是，应用库会依赖于基础框架的版本。因此，我们建议在 应用库 目录下保存一个文本文件用于记录所依赖的基础框架版本，类似于开发应用的 debian/control\n文件的功能，为了保持统一，这个文件就命名为 control，放在应用库根目录下。\n\n\n2. 命名规范#\n\n * 用例 ID\n   \n   每个应用自己维护一套 ID，可以是你自定义的 ID 值，也可以是用某些特有的 ID（比如 PMS 用例ID）；\n   \n   一个用例类里面有多个用例时，在用例名称后面加序号。\n   \n   \n\n * 方法函数命名\n\n方法函数命名关键词列表\n\n名称          单词\n左键点击        click\n右键点击        right_click\n双击          double_click\n移动          move_to\n拖动          drag\n新建          new\n拖动到         drag_to\n从哪里拖动到哪里    drag_something_from_xxx_to_xxx\n获取          get\n获取某个元素的坐标   get_location\n非特殊文件       file\nword文件      doc\ntext文件      text\n文件夹         dir\n:::         \n\n * 常量命名\n\n::: tip 常量关键词列表\n\n名称                单词\n应用名称              APP_NAME\n应用描述              DESC\n本应用以外的其他应用，比如帮助   HELP\n\n * 方法层文件名\n\n方法层文件名称列表\n\n名称            单词\n方法包名          widget\n方法文件名（文管举例）   dfm_widget.pytitle_widget.pyright_view_widget.pyleft_view_wi\n              dget.pypop_widget.pybase_widget.pydfm_assert.py\n\n * 断言语句名称\n\n::: tip 断言语句命名规范 断言语句都是以 assert 开头\n\n断言              语句\n判断文件是否存在        assert_file_existsassert_file_not_exists\n判断桌面目录下文件是否存在   assert_file_exists_in_desktopassert_file_not_exists_in_deskt\n                op\n判断图片存在          assert_image_existsassert_image_not_exists\n判断影院中是否存在图片     assert_image_exists_in_movieassert_image_not_exists_in_movie\n判断元素是否存在        assert_element_existassert_element_not_exist\n判断是否相等          assert_equalassert_not_equal\n判断是否为真          assert_trueassert_false\n:::             \n\n\n3. Fixture 规范#\n\n为统一编码风格方便后续用例代码维护，现做以下规范说明：\n\n * 不建议使用 Xunit 的写法，统一采用 Pytest fixture 的写法。\n * 应用内 fixture 谨慎使用 autouse=True ，非必要的情况下非常不建议使用这个参数。\n * 调用 fixture 不能使用 @pytest.mark.usefixture()，使用直接在用例里面传入函数对象。\n * 建议在一个 conftest.py 里面去写 fixture，一个应用也尽量维护一个 conftest.py 文件。\n * fixture 也需要写功能说明，函数名称要有具体含义。\n\n\n4. 方法编写&调用规范#\n\n\n4.1. 方法编写#\n\n * 写方法的时候注意方法归属；\n   \n   比如文件管理器的界面区域划分为：TitleWidget 、RightViewWidget、LeftViewWidget\n   、PopWidget，方法是在哪个区域操作的，就写在哪个类里面。\n   \n   举例：\n   \n   \n\n * 动作开头，注意是动词；\n   \n   \n\n * 元素对象名称；\n   \n   界面元素直接与元素名称相同，没有名称的就取一个好听易懂的名字。\n\n * 加上类的关键词；\n   \n   避免方法重名，同时可以标记区域。\n\n * 标定操作方法类型；\n   \n   \n\n * 正确使用方法类型；\n   \n   \n   \n   举例:\n   \n   \n\n * 函数名称尽量不出现数字，需要表示数量的用单词表示。\n\n * 函数功能注释；\n   \n   * 没有参数，没有返回，直接写函数功能说明；\n   \n   \n   \n   * 有参数，没有返回，需要写各参数说明；\n   \n   \n   \n   * 有参数，有返回，需要写返回值说明；\n     \n     \n     \n     用 Pycharm 的注释模板也可以，只要体现了参数的类型和返回就行了。\n   \n   * 暂不要求写类型注解。\n\n\n4.2. 方法调用#\n\n在用例中调用方法，通过该应用唯一的出口进行调用，比如文件管理器的统一出口类：\n\n\n\n在用例里面只需要导入这一个类即可；\n\n\n\n尽量不要在用例中单独去调用 TitleWidget 、RightViewWidget、LeftViewWidget 、PopWidget\n这些类，否则后期用例会变得不好维护；\n\n\n5. 用例编写规范#\n\n\n5.1. 基于类写用例#\n\n所有用例都应该基于类去写：\n\n\n\n注意以下几点：\n\n * 类名不要随便取，同一个应用应该使用同一个类名，用例类名称必须以 Test 开头，遵循大驼峰命名规范；\n\n * 用例类继承 BaseCase，一个应用只有一个 BaseCase ；\n\n * 一个 py 文件里面只有一个类，我们称为一个测试类；\n\n * 一个类里面可以有多个用例函数，这取决这条用例有多少个测试点：\n\n\n\n\n5.2. 用例函数规范#\n\n * 用例函数以 test 开头，遵循蛇形命名规范，中间为用例的模块名称，后面加用例 ID，最后加测试点序号，即：\n   \n   \n   \n   比如：test_music_679537_1，index 从 1 开始。\n\n * 函数功能说明里面写用例标题，直接复制 PMS 上用例标题即可，注意用三对双引号；\n\n * 复制 PMS 用例步骤\n   \n   直接将 PMS 上用例步骤和预期复制进来，然后进行批量注释（ ++ctrl+\"/\"++\n   ），在注释的基础上去写用例脚本会更加方便全面，也比你自己写注释更节约时间：\n   \n   举例： ???+ note \"PMS用例\"\n   \n   直接选中用例内容，复制下来，然后粘贴到自动化用例脚本中：\n   \n   \n   \n   上例中井号（#）注释部分就是直接从 PMS 上复制过来的，在此基础上写用例：\n   \n   \n   \n   你看，非常清楚每一步在做什么，重点是省去了写注释的时间，真的炒鸡方便。\n\n\n5.3. 数据驱动#\n\n * 如果用例操作步骤是相同的，只是一些参数变化，尽量使用数据驱动来实现用例；\n\n * 如果你需要使用外部文件 存放数据驱动的数据，尽量不要因此引入依赖，可以使用一些标准库能读取的文件格式，比如 json、ini、CSV、xml、txt\n   等文件格式；不建议使用 Yaml、Excel、MySQL 等数据格式；\n\n * 读取数据时也尽量使用标准库去做，如使用 pandas 处理 CSV 就属于大材小用了，正常的数据驱动还没到需要大数据分析来处理的地步；\n\n * 数据驱动的 外部文件存放在widget/ddt/ 目录下；\n\n * 数据驱动的写法：\n   \n   \n   \n   以上这种参数化的写法本身没什么问题；\n   \n   但是，这里必须要补充一个没有用的小知识：\n   \n   * 使用 ids 参数；\n     \n     加 ids 参数之前：\n     \n     如果参数化数据里面的字符会原封不动的输出到 item.name 里面，显示非常不优雅，而且可能会引入一些意想不到的问题，可以感受一下：\n     \n     参数：\n     \n     \n     \n     终端日志打印出来，现象是这样色儿的：\n     \n     \n     \n     说实话，看着心里堵得慌，如果这里面包含一些特殊字符或者是超长，可能还会有一些很奇妙的事情发生。\n     \n     加 ids 参数之后：\n     \n     \n     \n     再来感受一下：\n     \n     \n     \n     明显好多了，所以尽量使用 ids 这个参数。\n\n * 不建议使用 fixture 的数据驱动方式，框架虽然支持，但可读性比较差；\n   \n   如果你不知道这句话在说啥，那你可以忽略，我也不打算详细说这种实现方式，操作比较骚。\n\n\n5.4. 断言资源#\n\n * 用例断言的图片资源，直接放在 用例模块的同级目录下的 assert_res 目录 下，图片名称以 用例的模块名称 + 用例 ID 命名；\n * 图像识别断言，不要截取一张很大的图，图片资源包含的元素太多了，非常容易受到需求影响，建议是进行局部的断言；\n\n\n5.5. 元素定位#\n\n * 用于 用例操作步骤中进行元素定位的图片资源，放到 widget/pic_res 目录 下，图片名称命名为该元素的名称；\n * 用于元素定位的图片截取时尽量精确到这个具体的按钮，图片也不要太大；\n * 基于 UI 定位的操作较快，合理加入等待时间能提高用例的稳定性。\n\n\n5.6. 用例资源#\n\n * 用例执行过程中需要使用到的一些资源，存放在 widget/case_res 目录 下，前提是这些资源不超过 10M；\n\n * 如果是一些比较大的资源，建议放到统一的 ftp 服务器，需要执行用例的时候再下载下来；\n\n * 确保一个资源在一次用例执行中只需要下载一次，如果每次使用的时候都去下载，这样可能会耗费大量的网络资源，而因为先判断本地是否存在此资源，如果不存在再去下载；\n\n * 测试用例执行过程中，你可能需要将资源拷贝到对应的测试目录下；\n   \n   比如将 mp3 文件拷贝到 ~/Music\n   目录下，但是我们更建议你使用发送快捷链接的方式替代拷贝的操作，因为在拷贝大文件时是很消耗系统资源的，而创建链接则不会；\n   \n   \n   \n   \n   \n   如果你的测试资源很大，要特别注意这问题，如果你使用强制等待下载结束( os.system )，可能会造成用例执行时长变得不可接受；\n   \n   在持续集成环境执行时网络下载速度很慢，所以超时机制是很有必要的；run_cmd 方法有一个默认超时的时间，你可以根据资源大小对超时时间进行调整；\n\n\n6. 标签化管理规范#\n\n\n6.1. 对应关系#\n\n写完自动化用例之后，请在 CSV 文件中标记用例的 ID、等级等标签。\n\n为了提醒标记，执行用例时在首行会输出 ERROR 日志： CSV 文件里面没有对应的 ID；\n\n如果 CSV 文件里面没有对应 ID，后续在批量执行的时候，这些用例是不会执行的。\n\n\n6.2. 名称一致#\n\nCSV 文件的文件名、用例 py 文件中间的名称、用例函数中间的名称，这三个名称一致。\n\n举例：\n\n\n\n那么 CSV 文件的名称为 music.csv。\n\n框架底层代码实现是将 CSV 文件的名称 与 用例脚本名称 进行对应（建立映射）；\n\n\n7. 子应用Tag管理规范#\n\n * 应用库 tag 根据应用交付节点生成，每次打 tag 之前，相关测试人员需要进行用例调试；\n\n * 调试用例是指的在全架构上调试通过；\n\n * tag 号怎么打？\n   \n   根据持续集成的要求生成，其中应用版本号需要与项目经理确认本次即将集成的应用版本号是多少；\n   \n   tag 的 commit 信息格式：\n   \n   \n   \n   其中 5.6.5 写应用的集成版本号。\n\n\n8. 其他规范#\n\n * 不写 if __name__ '__main__':，不写多余的代码；\n\n * 统一文件注释头。\n   \n   \n\n * 日志打印要在方法最前面，否则代码报错没有日志输出，不好定位问题；\n\n * hook 函数只能写到根目录下的 conftest.py 里面；\n\n * apps 目录下的 conftest.py 原则上不会写 fixture；\n\n * 固定目录或元素控件的操作，将操作方法写死，类似文件的操作可以将文件名留参数；\n\n * 路径拼接规范：\n   \n   * 系统中固定目录，路径拼接时使用波浪符号，比如：~/Desktop/，下层使用 os.path.expanduser()，它可以自动识别波浪符号；\n   \n   * 项目下路径使用配置文件中的路径，比如：Config.BASE_PATH，因为项目是可以在任意路径运行的，需要动态拼接路径。","routePath":"/博客/2024/AT开发规范","lang":"","toc":[{"text":"1. 版本及依赖","id":"1-版本及依赖","depth":2,"charIndex":163},{"text":"2. 命名规范","id":"2-命名规范","depth":2,"charIndex":338},{"text":"3. Fixture 规范","id":"3-fixture-规范","depth":2,"charIndex":1644},{"text":"4. 方法编写&调用规范","id":"4-方法编写调用规范","depth":2,"charIndex":1945},{"text":"4.1. 方法编写","id":"41-方法编写","depth":3,"charIndex":1961},{"text":"4.2. 方法调用","id":"42-方法调用","depth":3,"charIndex":2512},{"text":"5. 用例编写规范","id":"5-用例编写规范","depth":2,"charIndex":2677},{"text":"5.1. 基于类写用例","id":"51-基于类写用例","depth":3,"charIndex":2690},{"text":"5.2. 用例函数规范","id":"52-用例函数规范","depth":3,"charIndex":2893},{"text":"5.3. 数据驱动","id":"53-数据驱动","depth":3,"charIndex":3342},{"text":"5.4. 断言资源","id":"54-断言资源","depth":3,"charIndex":4136},{"text":"5.5. 元素定位","id":"55-元素定位","depth":3,"charIndex":4279},{"text":"5.6. 用例资源","id":"56-用例资源","depth":3,"charIndex":4429},{"text":"6. 标签化管理规范","id":"6-标签化管理规范","depth":2,"charIndex":4931},{"text":"6.1. 对应关系","id":"61-对应关系","depth":3,"charIndex":4945},{"text":"6.2. 名称一致","id":"62-名称一致","depth":3,"charIndex":5086},{"text":"7. 子应用Tag管理规范","id":"7-子应用tag管理规范","depth":2,"charIndex":5220},{"text":"8. 其他规范","id":"8-其他规范","depth":2,"charIndex":5436}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":8,"title":"二、适合做自动化的用例","content":"AT 用例筛选指北#\n\nAT 用例筛选标准，是挑选合适的文本用例进行自动化用例转化的一些通用标准。\n\n过去我们在自动化测试实践过程中，写了不少自动化用例，随着需求的迭代，自动化用例会自然腐化，因而需要在迭代的过程中对自动化用例进行维护，在维护自动化用例的过程中我\n们发现，有些用例维护起来太难了，调试用例耗费大量时间，成本很高。\n\n因此，我们总结一些自动化用例选型的标准，以优化后续自动化用例结构，期待我们能编写出高效、稳定、易于维护的自动化用例。\n\n\n一、不适合做自动化的用例#\n\n自动化测试可以分为常规自动化测试和专项自动化测试，常规自动化测试一般只针对一些常规的功能测试，其他非常规功能的用例，应该采用专项的自动化测试方案；\n\n以下是不适合做自动化用例的情况：\n\n\n1. 稳定性、压测用例#\n\n稳定性测试、压测用例应该是属于性能相关的测试场景，如：反复多次点击按钮，检验其功能稳定性。因为这些用例断言的预期可能不是很明确，更有甚者不需要断言，用例时长比较\n长，而且不可控，因此不适合做常规自动化测试。\n\n目前我们有性能自动化的专项方案，以及一些稳定性测试的专项方案，可以考虑将此类用例放到专项自动化里面去做。\n\n\n2. 涉及多个用户操作#\n\n常见与文管的用例中，多用户操作的用例一般都会涉及到在系统中进行多个用户间的切换，自动化脚本一般是运行在一个用户空间下的，所以还无法实现多用户间的切换。\n\n此类不建议采用自动化执行。\n\n\n3. 与开关机、注销、重启交互#\n\n此类场景多为应用的异常场景测试，比如：复制大文件过程中注销机器。\n\n自动化脚本在系统关机、注销、重启之后是会停止运行的；此类用例可以做自动化，但是同样需要做专项方案，用例执行过程的处理逻辑完全不同。\n\n后续自动化需要攻关的点：\n\n * 自动化脚本在本机运行，自动化测试框架至少需要提供以下功能：\n   \n   * 重启之后用例能自动运行；可以考虑将执行用例写成一个开机自启的服务；\n   \n   * 能记录关机之前用例执行的位置，重启之后能从此位置开始执行；\n\n * 像性能自动化一样，由服务端控制；\n   \n   * 完全基于图形识别进行元素定位；\n   * 串口线控制键鼠稳定性；\n\n\n4. 测试执行时间长#\n\n用例执行时间控制在2分钟以内，极端情况不要超过5分钟，所有用例的平均时长应该在1分钟左右；\n\n用例执行时间太长，编写用例、调试用例、执行用例、维护用例都非常的耗时，人力成本时间成本投入太高。\n\n你想，这条用例执行需要5分钟，那你写这条用例的时间不可能一遍过，写的过程中跑不通还得重跑至少15分钟不过分，写完了还得在其他架构上调试，半个小时过去了，这还只是\n第一次写用例的时候，后续如果用例维护过程中，你可能需要经常投入相当长时间，这样其实是失去了自动化的意义的。常规自动化测试就应该是快准狠。\n\n\n5. 边缘性测试#\n\n有些功能模块本身是属于比较边缘性的，即极少用户会使用到的功能，这类功能模块不需要大规模实现自动化，一两个场景覆盖基本功能就行了，因此我们在挑选此类用例的时候可以\n结合整个功能模块的覆盖情况来决定。\n\n\n6. 需要依赖人工介入的#\n\n自动化执行的过程中是没有人工介入的，如果这条用例是比如要人工介入的，那么就背离了自动化的意义。\n\n比如光驱模块，光驱刻录是核心功能，但是光驱刻录之后光盘会弹出来，需要人工更换光盘，再手动推进光驱中。\n\n这种功能模块即使做自动化，能涉及到的功能非常有限，而且不是核心功能，所以明显就不适合做自动化。\n\n\n7. 难以实现的#\n\n用例所涉及到的方法实现起来可能有难度，甚至现阶段无法实现的，此类用例不适合做自动化。\n\n比如影院测试画面清晰度、流畅度、截图录屏录制视频之后的视频是否存在卡顿等用例，现阶段还无法实现。\n\n\n8. 功能不稳定#\n\n这个不是说还在开发阶段的功能，还在开发阶段的功能不稳定是正常的，这种我们可以等开发提测之后再写自动化用例。\n\n功能不稳定指的是用例所涉及的功能，可能存在多种变化，每次执行用例可能断言的预期都不同。\n\n\n9. 动态断言#\n\n用例执行过程中直到用例结束，一直是一个动态变化的过程，而且无法通过其他手段停下来；\n\n比如：截图录屏录制视频时，右下角的录制时间是一直在变化的，用例需要测试录制1分钟之后，录制时间是刚好停在60秒；\n\n目前自动化用例执行还做不到时间精准控制，程序执行时间是有波动的，而且要适配多个平台，所以此类用例大概率会执行失败。特别是在性能较差的国产化架构上，此类用例不太可\n能稳定执行。\n\n\n10. 探索性测试#\n\n探索性测试通常是一些不确定的操作，多变切复杂的测试场景，预期也可能是不确定的，简单讲就是骚操作太多了，因此不适合做自动化测试。\n\n此类用例适合采用手工测试，是手工测试真正的价值体现。\n\n\n11. 易用性测试#\n\n对于易用性的判断通常是主观的，对于自动化来讲很难去定义什么样的情况对用户是易用的，自动化需要有明确的可实现的预期。\n\n\n二、适合做自动化的用例#\n\n前面讲了不适合做自动化的一些用例情况，有同学就说了，适合做自动化的用例不用讲了，就是不适合的反面。没毛病哈，适合做自动化的用例，我们大体还可以分为两类：\n\n * 第一类：自动化效果好，应该尽可能实现的自动化用例；\n * 第二类：自动化效果一般，需要投入更多精力才能实现的自动化用例；\n\n以下介绍一些我们应该尽可能实现自动化的情况：\n\n\n1. 操作相对简单#\n\n用例步骤相对较少，这种用例通常是一些路径很浅的用例，一般也是一些基础用例。用例编写、维护都可以轻松搞定。\n\n\n2. 容易实现#\n\n现有技术是可实现的，没有难度，应该尽可能做自动化。\n\n\n3. 经常用于回归测试#\n\n如果这条用例是每次回归测试必须要执行的用例，那么这条用例应该尽可能实现自动化。\n\n回归测试时我们首先应该保证应用历史基本功能正常，所以那些每次在回归测试时都要执行的用例适合转化为自动化用例。\n\n\n4. 功能稳定的核心功能#\n\n涉及核心功能的用例是最最重要的用例，也是我们交付时必须要保证质量的相关功能，因此应该尽可能的转化为自动化。\n\n\n5. 输入数据测试#\n\n输入数据测试通常是检验被测应用接受有效数据、拒绝无效数据的能力。如：提交超长字符串、特殊字符串等等。\n\n此类用例手工测试很难比较全面的覆盖到所有的输入情况，但是对于自动化来讲，此类用例操作步骤都是一样的，变化的仅是输入参数和断言结果，采用数据驱动，可以轻松实现。\n\n\n6. 格式覆盖#\n\n原因同输入数据测试类用例一样，多种格式的覆盖也是一个很繁琐的事情，交给自动化来做再合适不过了。\n\n比如影院对影片格式的检查、截图录屏对保存格式分辨率的检查。\n\n\n7. 检查元素状态#\n\n查看被测应用的元素属性。如：图片的大小和排列；按钮的可用和不可用。","routePath":"/博客/2024/AT用例筛选指北","lang":"","toc":[{"text":"1. 稳定性、压测用例","id":"1-稳定性压测用例","depth":2,"charIndex":335},{"text":"2. 涉及多个用户操作","id":"2-涉及多个用户操作","depth":2,"charIndex":509},{"text":"3. 与开关机、注销、重启交互","id":"3-与开关机注销重启交互","depth":2,"charIndex":616},{"text":"4. 测试执行时间长","id":"4-测试执行时间长","depth":2,"charIndex":929},{"text":"5. 边缘性测试","id":"5-边缘性测试","depth":2,"charIndex":1191},{"text":"6. 需要依赖人工介入的","id":"6-需要依赖人工介入的","depth":2,"charIndex":1303},{"text":"7. 难以实现的","id":"7-难以实现的","depth":2,"charIndex":1469},{"text":"8. 功能不稳定","id":"8-功能不稳定","depth":2,"charIndex":1575},{"text":"9. 动态断言","id":"9-动态断言","depth":2,"charIndex":1687},{"text":"10. 探索性测试","id":"10-探索性测试","depth":2,"charIndex":1888},{"text":"11. 易用性测试","id":"11-易用性测试","depth":2,"charIndex":1994},{"text":"1. 操作相对简单","id":"1-操作相对简单","depth":2,"charIndex":2248},{"text":"2. 容易实现","id":"2-容易实现","depth":2,"charIndex":2315},{"text":"3. 经常用于回归测试","id":"3-经常用于回归测试","depth":2,"charIndex":2353},{"text":"4. 功能稳定的核心功能","id":"4-功能稳定的核心功能","depth":2,"charIndex":2465},{"text":"5. 输入数据测试","id":"5-输入数据测试","depth":2,"charIndex":2536},{"text":"6. 格式覆盖","id":"6-格式覆盖","depth":2,"charIndex":2682},{"text":"7. 检查元素状态","id":"7-检查元素状态","depth":2,"charIndex":2773}],"domain":"","frontmatter":{"Author":"litao"},"version":""},{"id":9,"title":"AT 经验总结","content":"#\n\n> 欢迎所有人提交你在自动化测试方面的优秀实践经验，以帮助大家解决可能遇到的问题。\n\n\n用例调试技巧#\n\n\n1. 日志#\n\n * 一定要先看报错，看 error 日志，通常能明确的告诉你具体哪里代码报错；\n * 结合报错点前面的 error、 info 和 debug 日志看否是正常。\n\n\n2. 断点调试#\n\n * 方法报错：\n   * 在方法库中找到对应的方法，单独调用，看是否能正常执行；\n   * 通常单个方法的执行是比较简单的，如果单个方法报错，很快就能排查出问题；在方法内部打断点，使用 Debug 运行，看方法内部数据传递是否存在问题；\n   * 如果单个方法调用没问题，那么在用例中报错的方法前面打断点，使用 Debug 运行，看用例的业务逻辑和数据传递是否存在问题；\n * 断言报错：\n   * 断言为数据断言，根据表达式进行断言语句进行修改；\n   * 文件生成类断言，查看是否需要加等待时间；\n   * 图像断言，在断言语句处打断点，使用 Debug\n     运行，用例运行到断言处会停止，查看此时断言的图片与用例执行的现场存在什么差异，此时也可以进行重新截图，从而替换新的图片；\n\n\n3. 远程执行#\n\n * 远程执行指的是编辑器通过指定远程解释器执行自动化代码；\n   \n   远程执行的好处是可以很方便的 Debug 运行，不用在测试机上打开编辑器，用例执行速度更快；\n   \n   支持远程执行功能的编辑器：\n   \n   * 专业版 Pycharm\n   * VScode ，需要使用插件 Remote-SSH\n\n * 远程执行配置\n   \n   以 Pycharm 为例：\n   \n   File —> Settings —> Project —> Python Interpreter —> 右边设置按钮 —> Add... —> SSH\n   Interpreter —> New server configuration(填入host和username) —> Next —>\n   password（测试机密码） —> Interpreter(选择远程解释器) —> Finish\n\n\n4. 环境清理#\n\n * 如果用例里面的 teardown 没有执行，大概率是因为 setup 里面代码报错，这两个是一对的，setup 里面报错，teardown\n   里面的代码不会执行；\n * 目前我们已经将各应用的 clean_all 这个 fixture 改成了终结器，确保始终能执行到这步，但是用例里面的\n   fixture，还是需要我们小心处理；\n * 要执行 clean_all 需要在编辑器运行参数加 --clean yes，写用例的时候请加上，不然你不确定用例执行之后的环境是否恢复；\n * setup 可以不要，将 setup 放到用例里面是一种稳妥的做法，teardown 一定要。\n\n\n5. 元素定位不准（坐标返回不对）#\n\n * 基于 UI 定位的方法，可能受到窗口 ID\n   的变化，导致坐标返回不准，默认取最新的一个窗口用于定位，但如果实际需要定位的不是最新的窗口，那么在用例中需要重新实例化方法类对象，并在类中传入对应的窗口序\n   号；\n * 基于属性定位的方法，目前遇到的笔记本上，由于屏幕缩放比例为 1.25，导致坐标返回不准，我们默认使用缩放比例为 1；\n * 基于图像定位的方法，如果当前屏幕中存在多个相同的目标元素，可能出现定位不准；支持通过参数控制，返回多个坐标；\n * 基于 OCR 定位的方法，如果当前屏幕中存在多个相同的文字元素，可能出现定位不准；同样支持通过参数控制，返回多个坐标；\n\n\n6. 键鼠操作不准#\n\n * 鼠标操作不生效，比如右键、双击无响应；\n * 键盘操作不生效，或者延迟输入，比如用例需要输入“我是中国人”，实际只输入了“我国人”；\n\n以上问题排除应用卡顿等问题，大概率是由于工具的问题，目前键鼠操作我们使用三个工具：Dogtail 提供的键鼠工具、PyAutoGUI、Xdotool ；\n\n有同学可能要说为啥要用三个啊，用一个不就好了，简单讲就是各有优点各有缺点。\n\n如果你遇到键鼠的问题，可以试试通过不同的工具操作；键盘输入延迟的问题，一般是因为输入速度太快了，系统没反应过来，常见于 ARM 和 MIPS 上，修改参数\ndelay_time 的值，单位为毫秒；\n\n\n\n如果不是方法的问题，则需要继续和开发一起排除，是否为应用接受键鼠信号处理的问题，这类情况我们也是遇到过的，具体问题具体分析。\n\n比如影院就重写了一个右键的方法：\n\n\n\n\n终结器#\n\n前置/后置步骤\n\nPytest 实现前置/后置步骤的方式有两种，yield 和终结函数；\n\nyield 实现，yield前面为用例的前置步骤，yield 后面为用例的后置步骤。\n\n\n\n终结函数实现，使用 request.addfinalizer 注册用例的后置步骤\n\n\n\nyield的优缺点：\n\n优点：代码简洁，直观，可使用yield在用例中获取前置步骤的返回值\n\n缺点：若前置步骤中出现错误，则后置步骤不会执行\n\n终结函数：\n\n优点：前置步骤失败的话，后置步骤仍会执行且可以注册多个后置步骤（前提：需要在代码报错之前注册后置步骤），支持灵活使用后置条件\n\n缺点：代码较为复杂，无法获取前置步骤的返回值（本人目前未实现）\n\n总结：在前置步骤保证绝对不会出错时，使用yield更佳简便，当前置步骤易出现问题时，推荐使用终结函数。\n\n场景：保险箱用例，前置步骤中开启保险箱，后置步骤删除保险箱。\n\n\n\n代码按注释中的序号执行步骤：\n\n * 代码在步骤 1 - 4 任意位置报错，则不会执行步骤 8，因为未执行到步骤 5，步骤8还未注册；\n * 代码在步骤 6 - 7 报错，仍会执行步骤 7，因为在步骤 5 中已经将步骤 7 注册；\n\n可以灵活注册后置步骤，能实现某个前置步骤执行之后，才会执行后置步骤。\n\n\n启动应用的方式#\n\n\n\n（1）命令行启动\n\n在 AT 代码中使用命令行启动应用，举例：\n\n\n\n这种方式启动存在一个问题，就是当使用 ssh 远程执行用例时，dogtail 无法获取到元素。\n\n（2）通过 UI 操作启动\n\n通过任务栏、启动器、桌面等 UI 方式启动，比如双击打开、右键打开等，这种操作方式不存在 ssh 远程执行用例时 dogtail\n无法获取到元素的问题，也更加符合用户的操作行为。\n\n\n文件选择框属性定位偶现无法找到#\n\n文件选择框存在一个问题，在调用文件选择框时，有一定的概率出现，界面已经渲染出来了，但是属性树并没有写入，导致通过属性无法找到元素，目前也没有很好的解决方案，为了\n用例稳定性，文件选择框的操作建议使用 UI 或者图片定位的方式，可以通过搜索内容固定文件位置。\n\n\n\n\n\n\n应用启动#\n\n\n\n在UI自动化测试中，一切操作的都是从应用启动开始的，而在Linux桌面应用自动化测试中，我们启动应用的方法有多种，下面做一个简单的介绍：\n\n【使用dogtail启动】\n\ndogtail提供了应用启动的方法，在utils库中，使用run方法启动：\n\n首先导入方法：\n\n\n\n调用run方法\n\n\n\n即可启动音乐\n\n这种方法的优点是采用进程的方式直接启动，不依赖与UI，无论桌面或任务栏上是否存在应用图标，都可以正常启动。\n\n但是在实际项目中，仍然存在一个问题，\n\n如果使用ssh远程调用，或者 Jenkins 中执行测试脚本的时候，在 sniff\n中会出现找不到应用，经过分析，可能是因为使用这种方法启动的时候，实际是采用一个子进程启动了应用，dogtail 无法识别到。\n\n【从任务栏启动】\n\n使用dogtail点击任务栏上的应用图标\n\n通常有两种方法：\n\n（1）使用dogtail点击任务栏上的应用图标。\n\n（2）已知应用图标在任务栏上的位置，然后使用鼠标点击对应坐标。\n\n第二种方法的缺点是位置必须固定，如果移动位置就不行了，而使用第一种方法，无论位置在哪里，只要图标在任务栏上存在即可。\n\n【点击桌面图标启动】\n\n桌面图标目前是采用图像识别技术，定位到应用图标的坐标，然后通过pyauogui进行点击操作。\n\n详细技术方案可以参考我的另外两篇博客:\n\n基于opencv的模板匹配实现图像识别，返回在屏幕中的坐标\n\nPython三方库PyAutoGui的使用方法\n\n【从启动器启动（俗称开始菜单）】\n\n启动中启动的实现逻辑实际和任务栏上启动差不多。\n\n首先，需要使用鼠标点击任务栏上的启动器图标，或者键盘super键，将启动器呼出来，\n\n然后，在启动器中点击对应的图标，\n\n但是这里有个问题，启动器中的应用列表，一页展示不完，所以如果我们要点击的应用图标不在第一页怎么办，通常解决方案有两种：\n\n（1）需要进行向下滑动，这里就涉及到相应的识别方案，判断如果不在第一页就往下滑动翻页。\n\n（2）启动器提供搜索的功能，输入应用名称搜索，然后进行点击。\n\n从实际操作中来看，采用第二种方法的效率会高一点。\n\n【终端命令启动】\n\n在 Python 中，使用 os.popen() 或 os.system() 或 subprocess.Popen()，实现命令行启动，比如：\n\n\n\n这种方式启动是比较简单的，但是在实际项目中，仍然存在远程执行脚本的时候，dogtail 无法识别的问题。\n\n【总结】\n\n以上几种方法，各有优缺点，在实际项目中：\n\n（1）如果需要在 Jenkins 中做持续集成，建议使用第二种任务栏启动的方法。\n\n（2）如果不会采用远程执行的，建议采用第一种或者最后一种方案。\n\n（3）第三种和第四种启动方法，通常在测试用例中会涉及到，所以偶尔会用。\n\n\n其他不为人知的细节#\n\n * 在一段时间内尽量编写同一个应用或模块的用例，能对该用例已有方法熟悉，避免过多重复业务代码的封装；\n * 相同的场景下，各架构等待时间不同，建议使用框架提供的 sleep，我们做了不同架构的倍数放大；\n * 编写用例时，尽量考虑到每一步异常后的环境恢复，需要建议这种意识，随时要考虑到，这步操作有没有可能出错，出错了改怎么办；\n * 提交代码的时候注意不要把一些临时的测试资源提交进去了，比如测试了一个影片，有些同学习惯使用 git add .\n   ，然后就全部提交到代码仓库了，这样即使后期把大文件删了，.git 文件里面也会很大，造成代码仓库变得十分臃肿。","routePath":"/博客/2024/AT经验总结","lang":"","toc":[{"text":"用例调试技巧","id":"用例调试技巧","depth":2,"charIndex":46},{"text":"1. 日志","id":"1-日志","depth":3,"charIndex":56},{"text":"2. 断点调试","id":"2-断点调试","depth":3,"charIndex":148},{"text":"3. 远程执行","id":"3-远程执行","depth":3,"charIndex":507},{"text":"4. 环境清理","id":"4-环境清理","depth":3,"charIndex":917},{"text":"5. 元素定位不准（坐标返回不对）","id":"5-元素定位不准坐标返回不对","depth":3,"charIndex":1224},{"text":"6. 键鼠操作不准","id":"6-键鼠操作不准","depth":3,"charIndex":1541},{"text":"终结器","id":"终结器","depth":2,"charIndex":1928},{"text":"启动应用的方式","id":"启动应用的方式","depth":2,"charIndex":2487},{"text":"文件选择框属性定位偶现无法找到","id":"文件选择框属性定位偶现无法找到","depth":2,"charIndex":2690},{"text":"应用启动","id":"应用启动","depth":2,"charIndex":2843},{"text":"其他不为人知的细节","id":"其他不为人知的细节","depth":2,"charIndex":4033}],"domain":"","frontmatter":{"Author":"mikigo、litao"},"version":""},{"id":10,"title":"Git报错","content":"#\n\n\n1. github 仓库 push 报错#\n\n\n\n之前还好好的，下班要推送代码到 github 报错，注销重启电脑死活都不行。\n\n解决方案：\n\n22端口不行，换个端口：\n\n\n\n创建一个 config 文件\n\n\n\n填入以下内容：\n\n\n\n再次 push 就可以了\n\n如果还是不行 参考以下方法： 打开 /etc/hosts文件补充\n\n\n\n便可成功","routePath":"/博客/2024/Git报错","lang":"","toc":[{"text":"1. github 仓库 push 报错","id":"1-github-仓库-push-报错","depth":2,"charIndex":3}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":11,"title":"OpenStack系统架构设计实战","content":"#\n\n\n\n\n概述#\n\nOpenStack\n是一个开源的云计算管理平台项目，在开源云平台中主题讨论数量最大、社区人数最多、提交代码人数最多的平台。支持几乎所有类型的云环境，项目目标是提供实施简单、可大规模\n扩展、丰富、标准统一的云计算管理平台。\n\nOpenStack 有几个核心组件组成：\n\n计算（Compute）、对象存储（Object Storage）、镜像服务（Image Service）、网络管理（Network）等；\n\nGithub：https://github.com/openstack\n\nOpenStack 的用户界面提供了 Web 界面和 Shell 界面，可以通过界面功能进行创建、维护虚拟机等，操作流程有点像 KVM 管理虚拟机的流程；\n\n\n计算（Compute）Nova#\n\nNova 是一套控制器，用于为单个用户或使用群组启动虚拟机实力。OpenStack中实例的整个生命周期中的所有行为都有 Nova 处理，Nova\n管理计算资源的创建、销毁、挂起、迁移等功能。\n\n但是，Nova自身并不提供任何虚拟化能力，而是使用支持虚拟化（Hypervisor）的 API 来提供。\n\nNova 可以多节点部署，支持主流的 Hypervisor 架构，比如：KVM、LXC、QEMU、Xen、Docker 等；也能和 VMware 对接；\n\n\n\n--------------------------------------------------------------------------------\n\n\nnova-api#\n\n是用 Python 实现的 Web 服务器，实现 RESTful API 到内部请求消息的转换，实际使用 WSGI 来实现；\n\n\n消息队列（AMQP）#\n\n是一个提供统一消息服务的应用层标准高级消息队列协议，基于此协议的客户端和消息中间件可以喘息消息；主要有 2 个组件：Exchange 和 Queue；\n\n\nnova-compute#\n\n负责管理虚拟机，单独运行于承载分配虚拟机的主机智商，通过消息队列获取任务然后执行。走的是 qemu 那套虚拟化方案；\n\n\n存储管理（Cinder）#\n\nCinder 是在虚拟机和具体的存储设备之间引入一个抽象的 “逻辑存储卷”，整合后端存储设备，并通过统一的 API 接口为云平台提供持久性的块设备存储服务。\n\n\n\n--------------------------------------------------------------------------------\n\n\nCinder API#\n\n接受客户端发来的HTTP请求，然后进行用户身份认证和消息分发，本质上是一个 WSGI 服务；\n\n\ncinder-scheduler#\n\nCinder 的调度器，主要功能是通过一定的调度算法选择合适的后端存储节点，用来放置新创建的卷；\n\n\ncinder-volume#\n\n运行在存储节点，用于管理存储空间，主要执行卷管理相关的功能，比如：创建、删除、挂载、卸载、生成快照等。\n\n\ncinder-backup#\n\n用于将 cinder 卷备份到其他存储系统上去；\n\n\nGlance#\n\n提供虚拟机镜像存储和管理服务，比如虚拟机镜像的查询、注册、传输等；\n\nGlance 是存储服务和 OpenStack 其他组件之间沟通的纽带；\n\n\n网络管理（Neutron）#\n\n网络管理可太重要了，以前是由各个 nova 自己做的，现在 OpenStack 将这块独立出来，进行统一管理；也是 OpenStack 后续发力的重点；\n\nNeutron 提供了灵活的网络模型、管理IP地址，用户可以创建自己的网络，控制流量，可扩展，实现高级别的多租户、大规模部署网络；\n\nNeutron定位于网络服务，主要实现网络能力的集成、开放和管理，而网络能力的具体实现必须借助于外部的网络功能实体，如SDN控制器，交换机等。\n\n主要功能特点如下：\n\n1）支持创建各种类型网络，如Flat、VLAN、GRE，并可为租户创建自己的业务网络结构，如Web层、应用层、数据层。\n\n2）可为租户插入各种网络服务，如防火墙、负载均衡、IPS、NAT等。\n\n3）主流网络设备厂家都提供了插件以便支持对网络的控制和管理（包括SDN控制器）。\n\n4）支持各种网络虚拟化技术，如VXLAN、NVGRE、VLAN等。\n\n\n计量于监控（Ceilometer）#\n\n获取系统中用户对各种资源的使用情况，确保资源处于健康状态；\n\nCeilometer 获取计量数据的三种方法：通知、轮询、RESTful API；\n\n测量数据通过 Pipeline 发布，Ceilometer 中的 collector 服务用来接受这些测量数据，并持久化到存储介质中；\n\n可以对阈值做告警：边界触发器、组合型；\n\n\n裸机管理（Ironic）#\n\n通过 PXE 等裸机管理软件能方便的控制裸机上电，然后通过网络进行操作系统的安装；\n\n提供了一些功能可以进行自动化装机；\n\n\n其他#\n\n其他还提供了一些如：大数据服务（Sahara）、数据库服务（Trove）等服务；","routePath":"/博客/2024/OpenStack系统架构设计实战","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":5},{"text":"计算（Compute）Nova","id":"计算computenova","depth":2,"charIndex":331},{"text":"nova-api","id":"nova-api","depth":3,"charIndex":663},{"text":"消息队列（AMQP）","id":"消息队列amqp","depth":3,"charIndex":739},{"text":"nova-compute","id":"nova-compute","depth":3,"charIndex":830},{"text":"存储管理（Cinder）","id":"存储管理cinder","depth":2,"charIndex":906},{"text":"Cinder API","id":"cinder-api","depth":3,"charIndex":1086},{"text":"cinder-scheduler","id":"cinder-scheduler","depth":3,"charIndex":1148},{"text":"cinder-volume","id":"cinder-volume","depth":3,"charIndex":1218},{"text":"cinder-backup","id":"cinder-backup","depth":3,"charIndex":1288},{"text":"Glance","id":"glance","depth":3,"charIndex":1331},{"text":"网络管理（Neutron）","id":"网络管理neutron","depth":2,"charIndex":1414},{"text":"计量于监控（Ceilometer）","id":"计量于监控ceilometer","depth":2,"charIndex":1834},{"text":"裸机管理（Ironic）","id":"裸机管理ironic","depth":2,"charIndex":2019},{"text":"其他","id":"其他","depth":2,"charIndex":2097}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":12,"title":"Pycharm 问题","content":"#\n\n\n1. chrome-sandbox报错，Pycharm闪退#\n\n\n\n使用以下命令解决：\n\n","routePath":"/博客/2024/Pycharm问题","lang":"","toc":[{"text":"1. chrome-sandbox报错，Pycharm闪退","id":"1-chrome-sandbox报错pycharm闪退","depth":2,"charIndex":3}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":13,"title":"Shell问题随记","content":"#\n\n\n脚本实现切换用户后操作#\n\n问题描述：shell脚本中如果涉及切换用户，无法执行切换操作之后命令，如root用户执行以下脚本：\n\n\n\n问题原因：脚本中切换用户后，会先开一个子shell，所以后续命令不会执行，返回当前shell后才会执行\n\n解决方案：使用xdotool模仿键盘输入，可规避环境问题，安装xdotool(apt install xdotool)后，修改代码如下：\n\n\n\n补充：xdotool存在一些稳定性问题，以上方案实测仅方案3可用，其他方案理论上无问题，但执行失败，常用命令说明：\n\n\n\n\n通过命令创建用户并设置密码#\n\n问题描述：shell脚本使用root用户创建普通用户并设置密码操作时，因为设置密码是交互式操作，需要用户2次确认，使用echo Test#136 |\npasswd login_a显然不会成功。\n\n解决方案：使用非交互式命令设置密码，如下：\n\n\n\n补充：如果密码中包含 $ 字符，需要使用反斜线进行转义\\$\n\n\n账号相关命令#\n\n\n\n\n用户管理#\n\n\n\n\n解除账户锁定#\n\n问题描述：命令行输出错误密码次数过多，导致账号被锁定xmin\n\n解决办法：\n\n\n\n\nssh配置root登录#\n\n问题描述：ssh默认不允许root用户登录\n\n解决办法：\n\n\n\n\n删除目录的非指定文件#\n\n问题描述 在shell 脚本调试或者执行时，会经常遇到需要删除当前目录不需要的文件，手动删除十分麻烦。\n\n解决方案 shopt -s extglob rm -rf !(file1|file2)\n\n解决过程与分析 shopt 命令用于显示和设置shell中的行为选项，通过这些选项以增强shell易用性；如果不执行shopt -s extglob ，直接执行\nrm -rf !(*.txt)会提示bash: !: event not found\n\n实例： 1) 在/home/amd目录下存在文件：1.txt、test.log、test.txt、1.deb、1.log，现在只保留txt格式的文件。\n\n补充代码块\n\n2) 在/home/amd目录下存在文件：1.txt、test.log、test.txt、1.deb、1.log，现在只保留txt和deb格式的文件。\n\n补充代码块\n\n3) 在/home/amd目录下存在文件：1.txt、test.log、test.txt、1.deb、1.log，现在保留指定目录下log格式的文件。\n\n补充代码块\n\n\nshell中单/双/反引号的区别#\n\n问题描述 在shell执行的时候，常常遇到调用的变量被当做字符处理，导致脚本运行出错。\n\n解决方案 使用双引号将需要保留特殊字符的字符串括起来。\n\n解决过程与分析 双引号（\"\"）：保留特殊字符的功能，如美元符号、反引号、反斜线。 单引号（''）：被单引号括起来的字符都被视为普通字符对待。\n反引号（``）：被反引号括起来的字符串被当做shell命令执行，其标准输入结果取代整个反引号部分。\n\n实例：\n\n补充代码块\n\n\n杀死进程的多种方法#\n\n问题描述 在shell脚本执行中，经常遇到需要终止某个进程，但是通过进程id终止十分不方便，因为每次执行的进程id是变化的，导致脚本运行效率低下。\n\n解决方案 第一种：ps aux | grep netserver | grep -v grep | cut -c 9-15 | xargs kill -9\n第二种：pidof netserver | xargs kill -9 第三种：pgrep netserver | xargs kill -9\n\n解决过程与分析 第一种： ps aux 显示所有的进程 grep netserver 过滤显示netserver相关的进程 grep -v grep\n过滤grep的查询进程 cut -c 9-15 截取对应位置的字符，即进程id xargs 捕获左边的输出传递给右边的命令 kill -9 强制杀死进程\n\n第二种： pidof 用于查找指定名称的进程的进程号id号 语法： pidof (选项) (参数) 选项： -s：仅返回一个进程号；\n-c：仅显示具有相同“root”目录的进程； -x：显示由脚本开启的进程； -o：指定不显示的进程ID。\n\n第三种： pgrep 是通过程序的名字来查询进程的工具，一般是用来判断程序是否正在运行。 语法： pgrep (选项) (参数) 选项： -l\n同时显示进程名和PID -o 当匹配多个进程时，显示进程号最小的那个 -n 当匹配多个进程时，显示进程号最大的那个\n\n实例：\n\n 1. 启动stress进程，执行命令： stress -c 1 & stress -c 1 & stress -c 1 &\n\n 2. 使用第一种终止进程的命令： ps aux | grep stress | grep -v grep | cut -c 9-15 | xargs kill\n    -9\n\n 3. 使用第二种终止进程的命令： pidof stress | xargs kill -9\n\n 4. 使用第三种终止进程的命令： pgrep stress | xargs kill -9\n\n\n$#,$0,$@ 等用法及说明#\n\n问题描述\n\n在编写shell脚本的时候常常会向方法里面传递不同的参数，将参数放入变量的方式会导致脚本行数增加，代码执行效率不高，且不利于后期维护。\n\n解决方案\n\n使用$1、$2、$@等方式调用传入的参数。\n\n解决过程与分析\n\n\n\n实例：\n\n创建脚本文件：test.sh，将下面的代码复制到文件中。\n\n","routePath":"/博客/2024/Shell问题随记","lang":"","toc":[{"text":"脚本实现切换用户后操作","id":"脚本实现切换用户后操作","depth":3,"charIndex":3},{"text":"通过命令创建用户并设置密码","id":"通过命令创建用户并设置密码","depth":3,"charIndex":257},{"text":"账号相关命令","id":"账号相关命令","depth":3,"charIndex":428},{"text":"用户管理","id":"用户管理","depth":3,"charIndex":440},{"text":"解除账户锁定","id":"解除账户锁定","depth":3,"charIndex":450},{"text":"ssh配置root登录","id":"ssh配置root登录","depth":3,"charIndex":501},{"text":"删除目录的非指定文件","id":"删除目录的非指定文件","depth":3,"charIndex":548},{"text":"shell中单/双/反引号的区别","id":"shell中单双反引号的区别","depth":3,"charIndex":1037},{"text":"杀死进程的多种方法","id":"杀死进程的多种方法","depth":3,"charIndex":1265},{"text":"$#,$0,$@ 等用法及说明","id":"0-等用法及说明","depth":3,"charIndex":2163}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":14,"title":"自动化开发","content":"单机服务部署#\n\n\n部署#\n\n1、后台部署组件机文档说明：https://filewh.uniontech.com/library/5c9b7174-752b-42f2-b132-5f378\n80f3543/%E6%8F%90%E6%B5%8B%E5%BA%93/2.1\n\n2、需要先准备一台部署机、一台服务机，研测平台创建服务器后，服务机，新增磁盘挂载为 /data 分区（如果空间足够，可不用新增）\n\n\n\n3、服务机设置uos和root用户密码，以及将uos用户添加到sudo组\n\n\n\n4、部署命令（均为正常部署命令，步骤1文档中摘取，如果出现异常，需在文档中查看解决办法）\n\n\n\n5、部署完成后，首次进入平台配置管理员并激活，激活需在明道云申请激活序列号\n\n\n平台设置#\n\n\n登录#\n\n1、入域账号密码强度设置：平台 -》配置 -》人员设置 -》密码安全设置 -》密码长度范围\n\n2、平台保持登录状态：平台 -》配置 -》系统设置 -》基础设置 -》登录安全 -》页面最长静止时间\n\n\n自动化开发#\n\n\nWEB#\n\n\nCLIENT#","routePath":"/博客/2024/UDCP自动化过程中记录","lang":"","toc":[{"text":"部署","id":"部署","depth":2,"charIndex":9},{"text":"登录","id":"登录","depth":2,"charIndex":340},{"text":"WEB","id":"web","depth":2,"charIndex":454},{"text":"CLIENT","id":"client","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":15,"title":"VSCode远程环境开发指南","content":"#\n\n\n1.为什么要远程开发#\n\n办公电脑常常会因安装各种包和部署开发环境而变得混乱，导致项目开发中出现各种问题，重新安装环境并不现实。因此，许多开发者选择将开发环境与办公环境分离，通过远程连接\n开发环境来编码，确保办公电脑的整洁和高效。\n\n\n2.为什么选择vscode#\n\n测试部主要使用 Python 和 Shell 进行开发。在众多 IDE 中，PyCharm 和 VSCode 是不可避免的选择，两者的对比如下：\n\n对比项       启动速度           功能集成                 PYTHON 支持                    扩展定制\nVSCode    轻量、启动快，占用资源少   核心功能简洁，大多数功能依赖插件支持   需安装 Python 扩展和调试插件           丰富插件市场，可灵活定制\nPyCharm   启动慢，占用资源多      开箱即用的高级功能            原生支持 Python，专为 Python 开发设计   定制性较少，不够灵活\n\n关键原因：VSCode 完全免费，而 PyCharm 的远程开发功能需要专业版，且专业版是收费的。\n\n\n3.配置步骤#\n\n\n1）下载安装#\n\n * 从应用商店下载\n\n\n\n * 官网下载：点我跳转\n\n\n2）插件下载#\n\n第一步：安装简体中文插件\n\n\n\n第二步：安装完成后点击右下角重启vscode\n\n\n\n第三步：安装remote-ssh插件\n\n插件市场搜索remote-ssh，点击安装\n\n\n\n\n3）VSCode配置#\n\n第一步：ctrl+shift+p调出命令框，输入remote-ssh:config\n\n\n\n第二步：配置远程环境信息\n\n\n\n第三步：ctrl+shift+p调出命令框，输入Remote-SSH:Settings，把Remote.SSH：Enable Agent\nForwarding的勾选去掉\n\n\n\n\n4）免密配置#\n\n第一步：打开终端输入ssh-keygen，连续回车生成密钥\n\n\n\n第二步：配置远程免密：\n\n\n\n\n4）远程机器配置#\n\n第一步：安装openssh-server，专业版安装命令sudo apt-get install openssh-server，服务器版安装命令yum\ninstall openssh-server，安装完成后打开/etc/ssh/sshd_config，做如下修改\n\n将PermitRootLogin前的注释去掉，同时将后面字段改为yes\n\n\n\n将AllowTcpForwarding 前的注释去掉，同时将后面字段改为yes\n\n\n\n第二步：重启服务\n\nsystemctl restart sshd\n\n\n4.连接远程#\n\n大功即将告成，重启vscode后，点击左侧边电脑图标，然后点击已配置的远程机器，开始链接~~~\n\n\n\n会发现右下角开始链接远程并开始相关配置提示\n\n\n\n进度条读完后，点击左侧边栏文件图标，即可打开远程项目进行开发啦！！\n\n\n\n\n5.推荐插件#\n\nPython插件：Microsoft 提供的 Python 扩展，提供了强大的 Python 支持，包括代码补全、Linting、格式化等功能\n\n\n\nblack formatter：Python 代码格式化工具，能够自动格式化代码以符合 PEP 8 标准，使代码保持一致的风格\n\n格式化快捷键：\n\n * Windows/Linux‌: Ctrl + Shift + I\n * macOS‌: Cmd + Shift + F\n\n","routePath":"/博客/2024/VSCode远程环境开发指南","lang":"","toc":[{"text":"1.为什么要远程开发","id":"1为什么要远程开发","depth":2,"charIndex":3},{"text":"2.为什么选择vscode","id":"2为什么选择vscode","depth":2,"charIndex":121},{"text":"3.配置步骤","id":"3配置步骤","depth":2,"charIndex":518},{"text":"1）下载安装","id":"1下载安装","depth":3,"charIndex":528},{"text":"2）插件下载","id":"2插件下载","depth":3,"charIndex":566},{"text":"3）VSCode配置","id":"3vscode配置","depth":3,"charIndex":663},{"text":"4）免密配置","id":"4免密配置","depth":3,"charIndex":826},{"text":"4）远程机器配置","id":"4远程机器配置","depth":3,"charIndex":884},{"text":"4.连接远程","id":"4连接远程","depth":2,"charIndex":1146},{"text":"5.推荐插件","id":"5推荐插件","depth":2,"charIndex":1269}],"domain":"","frontmatter":{"Author":"wangpeng"},"version":""},{"id":16,"title":"Wayland下sniff命令报错~/.Xauthorty文件不存在","content":"#\n\n\n\n根据 Xlib.xauth 源代码里面这里：\n\n\n\n是因为读文件 filename 的时候报错，filename 要么从环境变量 XAUTHORITY 里面拿，要么就赋值 ~/.Xauthority，而咱们系统中\n~/.Xauthority 文件是存在的，那么肯定就是环境变量里面 XAUTHORITY 的值有问题； 查看一下：\n\n\n\n环境变量里面有 XAUTHORITY，但是值为空；\n\n所以这就是问题，filename 拿到一个空串，open 读肯定会报 OSError；\n\n解决方法，在 sniff 的代码里面把 XAUTHORITY=~/.Xauthority 这个环境变量加上理论上就行了；\n\n\n\n再执行 sniff 就不会报错啦；","routePath":"/博客/2024/Wayland下sniff报错","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":17,"title":"YouQu - 远程交互式控制","content":"#\n\n\n序言#\n\n在 youqu\n中，master主机承担测试代码分发、执行控制。进行测试时，设备A作为测试环境中的控制端（master），进行代码执行，执行过程中，同步代码给设备B（clien\nt）去做实际的测试执行。测试过程中，设备B（client）将数据、结果，收集后返回数据到客户端A（master）。这部分是 youqu 的远程执行能力，在\nyouqu 官网中执行管理器有详细的使用说明\n\n\n\n\n\n在自动化测试场景中，经常会涉及子设备对附属子设备的控制。所以 YouQu\n同时实现附属子设备远程控制能力。可以在测试用例步骤中实现对子设备进行命令行操作、UI操作、图像识别等，并对其操作返回相应数据。接下来，让我们去了解下关于\nyouqu 自动化测试的远程交互式控制。\n\n\nZeroRPC#\n\n\n简介#\n\nZeroRPC 是一个轻量级的远程过程调用（RPC）框架以简单的方式实现分布式应用间的通信，支持多种语言，Python 是其中之一。\n\n\n\n通过一个简单实例，了解下两个设备互相通信的过程\n\n设备A:\n\n\n\n设备B:\n\n\n\n\n不足#\n\nZeroRPC 设计上主要用于传递基本数据类型和字符串等简单的对象，把对象，比如：类实例，直接传输会存在问题。\n\n\n\n\nYouQu 远程方法绑定#\n\n\n实践#\n\nyouqu 远程控制时，客户端实际执行的代码是服务端提前进行绑定的方法。所以在 youqu 中已经对公共方法（Src 和\nDogtailUtils）进行了绑定，满足大部分测试场景，但是，实际测试中可能需要进行单独的方法绑定已满足测试需求。\n\n\n\n在 youqu 中需要在代码中进行提前注册，注册的方式为：\n\n 1. 在原始类中增加供调用的方法\n 2. 在远程调用接口，新增通过远程调用的入口方法\n\n\n\n由于 zerorpc 无法返回对象，又需要进行一些复杂的操作，只需要将所有操作都封装到方法内实现即可。\n\n比如：在上面 dogtail ，默认封装的 dogtail 的 obj 对象不会指定应用对象，在进行一个元素定位时，可能需要10多秒，原因是寻找定位元素是从\nDOM 的根节点开始寻找。如果想要在远程定位时，直接通过某个应用去点击其中某个元素的相邻元素，则可以修改注册方法：\n\n\n\n\n调用过程#\n\n远程方法调用时，需要经过以下过程。在调用远程方法时，需要去判断是否需要发送当前项目文件（涉及一些本地测试资源），并且需要判断远程是否已经存在zerorpc\n服务。并对其做出相应的逻辑处理。\n\n\n\n\n调用步骤#\n\n在 youqu 中提供两种远程执行配置方式\n\n\n\n\n\n在用例中获取远程设备信息，需要从 fixture 中获取，在用例中直接调用，返回的是一个包含所有远程设备信息的列表。用例中使用方式，可查看 远程交互式控制\n\n\n\n\n常见问题#\n\n\nzerorpc通信超时#\n\n1、报错信息\n\n\n\n2、查看当前登录终端，发现有多个 x 服务在运行：\n\n\n\n3、注销 x 服务为 0 的用户，再次尝试依旧复现，查询后发现加域账户依旧虽然为第一个 x 服务，但是标识依旧是 :1\n\n\n\n4、重启终端系统，再次运行，问题解决\n\n\n客户端断言时，找不到资源#\n\n1、找不到资源，查看客户端 youqu 项目的自动化应用项目是否存在对应资源，发现整个 youqu 项目没有同步到客户端\n\n2、执行前有进行过手动删除 youqu 的动作，重新执行时，调试发现没有进行重新发送\n\n\n\n3、继续断点调试，发现逻辑为如果存在远端远程服务进程，则不进行文件同步\n\n\n\n4、查看客户端服务进程，文件虽然不存在，但是进程依旧存在\n\n\n\n5、杀掉原进程，重新执行，报错消失","routePath":"/博客/2024/YouQu-远程交互式控制","lang":"","toc":[{"text":"序言","id":"序言","depth":2,"charIndex":3},{"text":"ZeroRPC","id":"zerorpc","depth":2,"charIndex":340},{"text":"简介","id":"简介","depth":3,"charIndex":351},{"text":"不足","id":"不足","depth":3,"charIndex":468},{"text":"YouQu 远程方法绑定","id":"youqu-远程方法绑定","depth":2,"charIndex":533},{"text":"实践","id":"实践","depth":3,"charIndex":549},{"text":"调用过程","id":"调用过程","depth":3,"charIndex":949},{"text":"调用步骤","id":"调用步骤","depth":3,"charIndex":1055},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":1171},{"text":"zerorpc通信超时","id":"zerorpc通信超时","depth":3,"charIndex":1179},{"text":"客户端断言时，找不到资源","id":"客户端断言时找不到资源","depth":3,"charIndex":1316}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":18,"title":"emoji 不显示","content":"#\n\n系统中缺少支持 Emoji 的字体：\n\n\n\n重启即可","routePath":"/博客/2024/emoji不显示","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"ftp服务器无法连接问题","content":"#\n\n\n问题描述#\n\n使用vsftpd搭建好ftp服务器之后，无法访问服务器，且配置文件的配置项设置完全正确。\n\n步骤：\n\n1、打开UOS系统计算机 - 菜单 - 连接到服务器\n\n2、输入ftp服务器地址：ftp://10.8.11.xx\n\n3、选择匿名 - 点击连接\n\n现象：\n\n提示挂载设备出错\n\n预期：\n\n连接成功，并展示ftp服务器中文件\n\n\n根因#\n\nvsftpd在2.5.5版本针对ftp目录自主访问控制权加入了安全策略，若ftp目录权限为 777，则会拒绝连接。\n\n\n解决办法#\n\n修改ftp目录权限即可解决\n\n\n\n\n补充#\n\n1、除此之外如果遇上vsftpd的服务无法启用，存在以下几种可能：\n\n * 21端口被占用\n\n\n\n * 配置文件中ipv4和ipv6同时开启或关闭\n\n\n\n2、目录权限为755时，就算对匿名用户开放了上传权限，也无法上传成功，可在ftp匿名主目录下创建一个权限为777的文件目录，匿名用户要上传文件时，上传至该目录即\n可。","routePath":"/博客/2024/ftp服务器无法连接问题","lang":"","toc":[{"text":"问题描述","id":"问题描述","depth":2,"charIndex":3},{"text":"根因","id":"根因","depth":2,"charIndex":175},{"text":"解决办法","id":"解决办法","depth":2,"charIndex":240},{"text":"补充","id":"补充","depth":2,"charIndex":265}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":20,"title":"中文文案排版指北","content":"#\n\n摘抄自《中文文案排版指北》，对我文档写作帮助巨大，这里分享给大家。\n\n\n空格#\n\n「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34\n岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。\n\n与大家共勉之。」——vinta/paranoid-auto-spacing\n\n\n中英文之间需要增加空格#\n\n正确：\n\n> 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。\n\n错误：\n\n> 在LeanCloud上，数据存储是围绕AVObject进行的。\n\n> 在 LeanCloud上，数据存储是围绕AVObject 进行的。\n\n完整的正确用法：\n\n> 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value\n> 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。\n\n例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。\n\n\n中文与数字之间需要增加空格#\n\n正确：\n\n> 今天出去买菜花了 5000 元。\n\n错误：\n\n> 今天出去买菜花了 5000元。\n\n> 今天出去买菜花了5000元。\n\n\n数字与单位之间无需增加空格#\n\n正确：\n\n> 我家的光纤入户宽带有 10Gbps，SSD 一共有 10TB。\n\n错误：\n\n> 我家的光纤入户宽带有 10 Gbps，SSD 一共有 20 TB。\n\n另外，度／百分比与数字之间不需要增加空格：\n\n正确：\n\n> 今天是 233° 的高温。\n\n> 新 MacBook Pro 有 15% 的 CPU 性能提升。\n\n错误：\n\n> 今天是 233 ° 的高温。\n\n> 新 MacBook Pro 有 15 % 的 CPU 性能提升。\n\n\n全角标点与其他字符之间不加空格#\n\n正确：\n\n> 刚刚买了一部 iPhone，好开心！\n\n错误：\n\n> 刚刚买了一部 iPhone ，好开心！\n\n\n-ms-text-autospace to the rescue?#\n\nMicrosoft 有个 -ms-text-autospace 的 CSS 属性可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如\nOS X、iOS 的用户界面目前并不存在这个特性，所以请继续保持随手加空格的习惯。\n\n\n标点符号#\n\n\n不重复使用标点符号#\n\n正确：\n\n> 德国队竟然战胜了巴西队！\n\n> 她竟然对你说「喵」？！\n\n错误：\n\n> 德国队竟然战胜了巴西队！！\n\n> 德国队竟然战胜了巴西队！！！！！！！！\n\n> 她竟然对你说「喵」？？！！\n\n> 她竟然对你说「喵」？！？！？？！！\n\n\n全角和半角#\n\n不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全角和半角』。\n\n\n使用全角中文标点#\n\n正确：\n\n> 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！\n\n> 核磁共振成像（NMRI）是什么原理都不知道？JFGI！\n\n错误：\n\n> 嗨! 你知道嘛? 今天前台的小妹跟我说 \"喵\" 了哎!\n\n> 嗨!你知道嘛?今天前台的小妹跟我说\"喵\"了哎!\n\n> 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI!\n\n> 核磁共振成像(NMRI)是什么原理都不知道?JFGI!\n\n\n数字使用半角字符#\n\n正确：\n\n> 这件蛋糕只卖 1000 元。\n\n错误：\n\n> 这件蛋糕只卖 １０００ 元。\n\n例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全角数字的。\n\n\n遇到完整的英文整句、特殊名词，其內容使用半角标点#\n\n正确：\n\n> 乔布斯那句话是怎么说的？「Stay hungry, stay foolish.」\n\n> 推荐你阅读《Hackers & Painters: Big Ideas from the Computer Age》，非常的有趣。\n\n错误：\n\n> 乔布斯那句话是怎么说的？「Stay hungry，stay foolish。」\n\n> 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。\n\n\n名词#\n\n\n专有名词使用正确的大小写#\n\n大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论內容，在这里只对部分易错用法进行简述。\n\n正确：\n\n> 使用 GitHub 登录\n\n> 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。\n\n错误：\n\n> 使用 github 登录\n\n> 使用 GITHUB 登录\n\n> 使用 Github 登录\n\n> 使用 gitHub 登录\n\n> 使用 gｲんĤЦ8 登录\n\n> 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。\n\n> 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。\n\n> 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。\n\n> 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。\n\n> 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。\n\n注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标准的大小写规范进行书写；并通过 text-transform:\nuppercase;／text-transform: lowercase; 对表现形式进行定义。\n\n\n不要使用不地道的缩写#\n\n正确：\n\n> 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。\n\n错误：\n\n> 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。\n\n\n争议#\n\n以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。\n\n\n链接之间增加空格#\n\n用法：\n\n> 请 提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请 点击这里 进行订阅！\n\n对比用法：\n\n> 请提交一个 issue 并分配给相关同事。\n\n> 访问我们网站的最新动态，请点击这里进行订阅！\n\n\n简体中文使用直角引号#\n\n用法：\n\n> 「老师，『有条不紊』的『紊』是什么意思？」\n\n对比用法：\n\n> “老师，‘有条不紊’的‘紊’是什么意思？”","routePath":"/博客/2024/中文文案排版指北","lang":"","toc":[{"text":"空格","id":"空格","depth":2,"charIndex":38},{"text":"中英文之间需要增加空格","id":"中英文之间需要增加空格","depth":3,"charIndex":187},{"text":"中文与数字之间需要增加空格","id":"中文与数字之间需要增加空格","depth":3,"charIndex":516},{"text":"数字与单位之间无需增加空格","id":"数字与单位之间无需增加空格","depth":3,"charIndex":600},{"text":"全角标点与其他字符之间不加空格","id":"全角标点与其他字符之间不加空格","depth":3,"charIndex":838},{"text":"`-ms-text-autospace` to the rescue?","id":"-ms-text-autospace-to-the-rescue","depth":3,"charIndex":-1},{"text":"标点符号","id":"标点符号","depth":2,"charIndex":1071},{"text":"不重复使用标点符号","id":"不重复使用标点符号","depth":3,"charIndex":1079},{"text":"全角和半角","id":"全角和半角","depth":2,"charIndex":1211},{"text":"使用全角中文标点","id":"使用全角中文标点","depth":3,"charIndex":1261},{"text":"数字使用半角字符","id":"数字使用半角字符","depth":3,"charIndex":1464},{"text":"遇到完整的英文整句、特殊名词，其內容使用半角标点","id":"遇到完整的英文整句特殊名词其內容使用半角标点","depth":3,"charIndex":1569},{"text":"名词","id":"名词","depth":2,"charIndex":1829},{"text":"专有名词使用正确的大小写","id":"专有名词使用正确的大小写","depth":3,"charIndex":1835},{"text":"不要使用不地道的缩写","id":"不要使用不地道的缩写","depth":3,"charIndex":2569},{"text":"争议","id":"争议","depth":2,"charIndex":2730},{"text":"链接之间增加空格","id":"链接之间增加空格","depth":3,"charIndex":2777},{"text":"简体中文使用直角引号","id":"简体中文使用直角引号","depth":3,"charIndex":2906}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":21,"title":"前端问题","content":"#\n\n\n1. Error: ENOSPC: System limit for number of file watchers reached#\n\n报错的原始输出：\n\n\n\n达到文件观察者数量的系统限制；\n\n错误产生的原因是负责监控 Linux 文件系统的 inotify 程序达到了系统默认的限制上限；\n\ninotify 提供了一种监控文件系统（基于 inode 的）事件的机制，可以监控文件系统的变化如文件修改、新增、删除等，并可以将相应的事件通知给应用程序。\n\n查看 inotify 在内核中的默认配置\n\n\n\n解决方法\n\n临时解决：\n\n\n\n永久解决：\n\n\n\n\n2. WARN  GET https://registry.npm.taobao.org/vitepress error (CERT_HAS_EXPIRED).\nWill retry in 10 seconds. 2 retries left.#\n\n原因是npm淘宝的镜像 https 过期，取消掉严格https验证\n\n","routePath":"/博客/2024/前端问题","lang":"","toc":[{"text":"1. `Error: ENOSPC: System limit for number of file watchers reached`","id":"1-error-enospc-system-limit-for-number-of-file-watchers-reached","depth":2,"charIndex":-1},{"text":"2. `WARN  GET https://registry.npm.taobao.org/vitepress error (CERT_HAS_EXPIRED). Will retry in 10 seconds. 2 retries left.`","id":"2-warn-get-httpsregistrynpmtaobaoorgvitepress-error-cert_has_expired-will-retry-in-10-seconds-2-retries-left","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":22,"title":"控制客户端，无法找到资源问题","content":"控制客户端，返回超时问题#\n\n\n现象#\n\n执行需要与加域客户端交互的测试用例，当脚本代码完成发送后，操作客户端时，zerorpc通信超时：\n\n\n\n\n分析#\n\n1、进入加域客户端，手动启动远程服务，提示Could not open X display：\n\n\n\n2、查看当前登录终端，发现有多个 x 服务在运行：\n\n\n\n3、注销 x 服务为 0 的用户，再次尝试依旧复现，查询后发现加域账户依旧虽然为第一个 x 服务，但是标识依旧是 :1\n\n\n\n\n解决#\n\n重启终端系统，只登录加域账户，问题消失\n\n\n#\n\n\n控制客户端，无法找到资源问题#\n\n\n现象#\n\n执行用例时，服务端网页自动化执行正常，进行客户端断言时，找不到资源（图片资源）\n\n\n分析#\n\n1、找不到资源，查看客户端 youqu 项目的自动化应用项目是否存在对应资源，发现整个 youqu 项目没有同步到客户端\n\n2、执行前有进行过手动删除 youqu 的动作，重新执行时，调试发现没有进行重新发送\n\n\n\n3、继续断点调试，发现逻辑为如果存在远端远程服务进程，则不进行文件同步\n\n\n\n4、查看客户端服务进程，文件虽然不存在，但是进程依旧存在\n\n\n\n\n解决#\n\n杀掉原进程，重新执行，报错消失","routePath":"/博客/2024/域管客户端自动化执行失败问题","lang":"","toc":[{"text":"现象","id":"现象","depth":2,"charIndex":15},{"text":"分析","id":"分析","depth":2,"charIndex":73},{"text":"解决","id":"解决","depth":2,"charIndex":221},{"text":"现象","id":"现象-1","depth":2,"charIndex":270},{"text":"分析","id":"分析-1","depth":2,"charIndex":317},{"text":"解决","id":"解决-1","depth":2,"charIndex":502}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":23,"title":"大型网站技术架构","content":"#\n\n\n\n这本书是阿里资深架构师（李智慧）写的，人如其名，这满脑子哐哐都是智慧，实战型大佬，全方位的解读了构建大型网站面临的各种架构问题及应该怎样去做；内容绝对是教材级别\n的；\n\n\n概述#\n\n大型网站软件系统的特点：高并发，大流量、高可用、海量数据、用户分布广，网络情况复杂、安全环境恶劣、快速迭代发布；\n\n\n大型网站架构演化发展历程#\n\n一台服务器：大型网站都是从小型网站慢慢发展过来的，小网站最开始没啥人访问，一台服务器就够了；\n\n应用服务和数据服务分离：随着用户增多，性能越来越差，存储空间不足，将应用和数据分离：应用服务器、文件服务器、数据库服务器；\n\n使用缓存改善网站性能：实际业务中，80% 的业务方位集中在 20% 的数据上，将这 20% 的数据缓存在内存（缓存服务器）中，改善性能；\n\n应用服务器集群改善并发处理能力：随着访问量增加，换更强大的服务器是不行的，再厉害的服务器都顶不住持续增长的业务需求，而应该增加服务器分担访问和存储压力；\n\n增加了很多服务器之后就成了集群，通过负载均衡调度服务器，将来自用户浏览器的访问请求分发到应用服务器集群；\n\n数据库读写分离：使用缓存服务器后，虽然大部分数据读可以不走数据库，但是小部分读和全量写数据库的操作也会让数据负载压力过大，造成性能瓶颈；\n\n可以将一台数据库服务器的数据更新同步到另一台服务器（主从关系），做数据库的读写分离：写数据走主数据库，主数据库同步到从数据库，读数据走从数据库；\n\n反向代理和CDN网络加速：基本原理都是缓存，CDN部署在网络提供商的机房，用户请求时可以从距离最近的一个机房获取；反向代理服务器也缓存了数据，用户访问方向代理服\n务器，由反向代理服务器中缓存返回用户；\n\n业务拆分（模块化）、分布式服务\n\n\n大型网站核心架构要素#\n\n5个架构要素：性能、可用性、伸缩行、扩展性、安全性\n\n\n性能#\n\n在浏览器端，可以通过浏览器缓存、使用页面压缩、合理布局页面、减少Cookie传输等手段改善性；\n\n在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力；\n\n在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能；\n\n在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能；\n\n在数据库服务器端，索引、缓存、SQL优化等性能优化手段；\n\n\n可用性#\n\n7×24可用\n\n网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失。\n\n\n伸缩性#\n\n伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。\n\n主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总的服务器数量是\n否有限制。\n\n\n扩展性#\n\n业务功能要能方便的扩展新功能，而且对原来的功能不造成影响，需要做好模块化划分；\n\n\n安全性#\n\nXSS攻击、SQL注入等\n\n--------------------------------------------------------------------------------\n\n书中的核心内容都是围绕这5个有要素来展开描述的\n\n\n架构#\n\n\n高性能架构#\n\n前端性能优化、应用服务器性能优化、存储性能优化\n\n\n高可用架构#\n\n高可用的架构、高可用的应用、高可用的服务、高可用的数据、高可用的软件质量保证、运行监测\n\n事物总是先求生存，然后求发展。保证网站可用，万无一失，任重而道远。\n\n\n伸缩性架构#\n\n应用服务器集群伸缩性设计、分布式缓存集群的伸缩性设计、数据存储服务器集群的伸缩性设计。\n\n高手定律：这个世界只有遇不到的问题，没有解决不了的问题，高手之所以成为高手，是因为他们遇到了常人很难遇到的问题，并解决了；\n\n救世主定律：遇到问题，分析问题，最后总能解决问题。\n\n\n可扩展性架构#\n\n设计网站可扩展架构的核心思想是模块化，并在此基础之上，降低模块间的耦合性，提高模块的复用性。\n\n模块分布式部署以后具体聚合方式主要有分布式消息队列和分布式服务；\n\n马克思的劳动价值理论告诉我们，产品的内在价值在于劳动的时间，劳动的时间不在于个体付出的劳动时间，而在于行业一般劳动时间，资本家只会为行业一般劳动时间买单，如果你\n的效率低于行业一般劳动时间，对不起，请你自愿加班。反之，如果你有一个更具有扩展性的网站架构，可以更快速地开发新产品，也许你也享受不了只上半天班的福利，但是至少在\n这个全行业加班的互联网领域，你能够按时下班，陪陪家人，看看星星。\n\n\n安全架构#\n\n常见的攻击是 XSS 攻击、SQL 注入攻击、CSRF、Session 劫持\n\n做好信息加密：单向三列加密、对称加密、非对称加密；\n\n--------------------------------------------------------------------------------\n\n\n软实力#\n\n作者在后面几个章节还讲了很多职场攻略，没有多余的废话，都非常实用。","routePath":"/博客/2024/大型网站技术架构","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":90},{"text":"大型网站架构演化发展历程","id":"大型网站架构演化发展历程","depth":3,"charIndex":154},{"text":"大型网站核心架构要素","id":"大型网站核心架构要素","depth":2,"charIndex":746},{"text":"性能","id":"性能","depth":3,"charIndex":787},{"text":"可用性","id":"可用性","depth":3,"charIndex":1029},{"text":"伸缩性","id":"伸缩性","depth":3,"charIndex":1126},{"text":"扩展性","id":"扩展性","depth":3,"charIndex":1273},{"text":"安全性","id":"安全性","depth":3,"charIndex":1321},{"text":"架构","id":"架构","depth":2,"charIndex":1449},{"text":"高性能架构","id":"高性能架构","depth":3,"charIndex":1455},{"text":"高可用架构","id":"高可用架构","depth":3,"charIndex":1489},{"text":"伸缩性架构","id":"伸缩性架构","depth":3,"charIndex":1578},{"text":"可扩展性架构","id":"可扩展性架构","depth":3,"charIndex":1722},{"text":"安全架构","id":"安全架构","depth":3,"charIndex":2010},{"text":"软实力","id":"软实力","depth":2,"charIndex":2167}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":24,"title":"","content":"这两个明明是一样的，为啥会报错~~\n\n于是我直接debug看看：\n\n\n\n我去，明明字符串也是一样的，还就是不对，，这是什么操作，一瞬间直接感觉小脑萎缩了~~\n\n找不同： 把resourceName打印出来也是一样的，尝试split反斜杠或空格，也是一样的~~ 一时竟也不知如何入手~\n\n在编辑器里面直接copy value，再粘贴出来是这样的：\n\n\n\n这后面多个什么玩意儿，不管了，直接干掉试试\n\n\n\n然后，就报错了，\n\n\n\n结合数据源是从咱们操作系统中cmdline文件中来的，这玩意儿是C语言生成的，多半是C中的字符串结束符的问题，尝试直接把 \\x00 干掉，\n\n\n\n这会儿得劲儿了","routePath":"/博客/2024/报错Python字符串不相等","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":25,"title":"生成式AI：人工智能的未来","content":"#\n\n\n\n这本书勾起我兴趣的是竟然号称是一个AI写的，就很好奇AI这玩意儿能写出什么来；\n\n实际看下来，是作者写本书的时候使用AI辅助写作，5天就写完这本书，效率确实炸裂啊。\n\n\n为什么让AI自己写一本关于AI的书？#\n\n首先，AI本身很适合编写AI领域的书，因为它可以在几秒钟内处理、分析大量信息。\n\n其次，AI本身能从独特的视角来描述AI，特别地，它能够以人类难以做到的方式分析与理解复杂的概念和想法\n\n再次，让AI来创作一本关于AI的书，将有助于消除这个先进领域的神秘感，使AI更易被大众接受。\n\n最后，让AI描述AI，可以为这个领域开辟全新的可能性。\n\n\n简史#\n\n人类自古渴望构建智能思维的机器，从最早的算盘 --> 计算机 --> 机器学习 --> 人工智能 --> 未来可能超越人类\n\n\n理解AI#\n\n用一系列测试来确定机器是否具有智能，如一些比较著名的测试：\n\n * 图灵测试，如果一台机器能够与人类进行对话，而人类又无法将机器与人类彻底区分开来，那么这台机器就可以被认为具备智能。\n * 勒布纳奖（基于图灵测试的年度竞赛）\n * 中文房间测试\n * King-Kong测试\n * AI箱实验\n\n尚没有一个计算机系统以被科学界普遍接受的方式通过图灵测试，但该测试仍被认为是机器展示智能行为能力的基准。\n\n\nAI的原理#\n\nAI系统分为两类：基于规则的学习系统、机器学习系统\n\n基于规则的学习系统#\n\n通过一些条件判断，然后做出相应的响应。\n\n机器学习系统#\n\n从数据中学习，并且会随着时间的推移而改进性能。\n\n--------------------------------------------------------------------------------\n\n人类无法理解AI，因为AI是从数据中学习，建立自己的模式和关系并不断调整，而不是明确地用一套规则来编程。\n\n工程师想要了解他们的AI究竟在做什么，可以查看权重、偏差和激活函数，但这并不一定就是直接且清晰的。\n\n在某些情况下，LIME、SHAP等可解释性工具可以用来帮助理解AI的决策过程。\n\n但它仍然需要对模型和数据集有很好理解，最终可能无法完全掌握AI生成的规则。\n\n\nAI学习的类型#\n\n在监督学习中，机器学习系统是在一个标记的数据集上训练的，这意味着每一个输入都会提供期望的输出；\n\n * 计算机视觉\n * 自然语言处理\n * 语音识别\n * 推荐系统\n * 机器人\n\n在无监督学习中，机器学习系统必须自己在数据中找到模式和结构。\n\n半监督学习是监督学习和无监督学习的结合。在半监督学习中，机器学习系统被提供一些标记的数据，但不是所有数据。然后，系统必须使用标记数据来对未标记的数据进行预测。\n\n机器学习有一种方法叫作“强化学习”。在这种方法中，数据集并不像监督学习中那样被事先标记。相反，机器被要求做出预测或决策，正确的答案会得到奖励，不正确的答案会受到\n惩罚。\n\n\nChatGPT#\n\nChatGPT主要是基于从数据中学习到的模式，还不是通用人工智能，但它是个强大的工具，能够以较高的准确性，执行广泛的自然语言处理任务，也就是说ChatGPT还不\n属于传统意义上的“智能”。但它肯定是一个“超级有用”的工具，可以在语言翻译、文本总结、问题回答等许多应用中大放异彩。\n\n属于弱人工智能。\n\n\nAI的真相和虚妄#\n\n\n大势不可逆#\n\n没有应用AI技术的企业很快就会落后，而成功实施AI战略的企业将会具备显著的竞争优势，通过技术实现运营自动化，降低成本，开发新产品和服务，建立新的商业模式和抓住新\n的盈利点。\n\n没有任何工作能够在AI时代独善其身，所有的一切都清晰地摆上台面。如果你觉得自己的工作不会被替代，那只能是一种幻觉。\n\n\nAI的局限#\n\n莫得感情，AI可以识别情绪，但它们无法真正体验和理解情绪。\n\n莫得创造力，AI能够生成新想法与解决方案，通常被称为“创造力”。然而，AI的创造力与人类的创造力不同，无法提出真正原创和独特的概念，只能生成在其被训练范围内的想\n法，缺乏跳出框架思考并提出真正新颖想法的能力。\n\n莫得道德，对错、善恶直接干蒙圈；\n\n\n未来#\n\nAI很可能彻底改变人类的生活和工作方式，同时也会给社会带来重大风险。随着AI系统变得更加先进、自主，它可能开始以法律系统无法处理的方式犯罪，对人类造成伤害。\n\n以下情况阁下何如应对？\n\n * 执法系统是AI\n * AI本身就是犯罪分子\n\n最大的问题是缺乏问责制。谁对AI的行为负责，无法知道谁是真正的控制者。\n\nAI带来的问题：\n\n * 它可能直接取代大量工作岗位，扰乱劳动力市场。\n\n * AI对隐私和安全的影响。\n\n * AI对社会造成的潜在风险。\n\n * 要确保AI系统是透明的，要具备可解释性和公平性。\n\n * 必须确保AI系统的开发和应用能够促进人类福祉，而不会威胁人类生存，我们必须保持警惕，确保AI系统的开发应用与人类价值观相一致。\n\n\n人类教育如何应对#\n\n1.技术能力。理解AI和机器学习的基础知识，并且有能力在新技术涌现时迅速学习。\n\n2.创造力。具备提出创意和解决方案的能力，有能力跳出传统思维框架。\n\n3.适应性。能够迅速适应新技术与就业市场的变化。\n\n4.解决问题。具备分析和解决复杂问题的能力，能够进行批判性思考，做出明智决策。\n\n5.情绪管理。具备理解和管理自己和他人情绪的能力，包括良好的工作能力。\n\n6.沟通能力。具备沟通复杂思想和信息的能力（口语和文字能力）。\n\n7.领导力。鼓舞、激励和领导他人以实现共同目标的能力。\n\n8.道德与社会责任。能够负责任地理解和驾驭AI带来的道德和社会影响。\n\n9.持续学习。在科技和就业市场不断发展的情况下，具备持续学习和适应的能力。\n\n10.以人为本。设计、开发对人的需求和福祉具备包容性和响应性的AI方案。","routePath":"/博客/2024/生成式AI：人工智能的未来","lang":"","toc":[{"text":"为什么让AI自己写一本关于AI的书？","id":"为什么让ai自己写一本关于ai的书","depth":2,"charIndex":89},{"text":"简史","id":"简史","depth":2,"charIndex":281},{"text":"理解AI","id":"理解ai","depth":3,"charIndex":350},{"text":"AI的原理","id":"ai的原理","depth":3,"charIndex":560},{"text":"基于规则的学习系统","id":"基于规则的学习系统","depth":4,"charIndex":595},{"text":"机器学习系统","id":"机器学习系统","depth":4,"charIndex":628},{"text":"AI学习的类型","id":"ai学习的类型","depth":3,"charIndex":930},{"text":"ChatGPT","id":"chatgpt","depth":3,"charIndex":1232},{"text":"AI的真相和虚妄","id":"ai的真相和虚妄","depth":2,"charIndex":1394},{"text":"大势不可逆","id":"大势不可逆","depth":3,"charIndex":1406},{"text":"AI的局限","id":"ai的局限","depth":3,"charIndex":1562},{"text":"未来","id":"未来","depth":2,"charIndex":1726},{"text":"人类教育如何应对","id":"人类教育如何应对","depth":2,"charIndex":2057}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":26,"title":"自动化过程","content":"#\n\n\n提交代码时提示邮箱或者名称不对#\n\n重新配置邮箱或者名称，然后重置生效：\n\n\n\n\n怎么回滚到之前的版本#\n\n(1)查询历史提交记录\n\n\n\n找到你要回滚的版本，复制 hash 值。\n\n * 注意：是 commit 空格之后的 hash 值，之前有同学复制的 Change-Id: 这样肯定报错。\n\n(2)回滚版本，不清除代码\n\n\n\n(3)回滚版本，清除代码，慎用哈\n\n\n\n\n解决 git status 中文显示的问题#\n\n\n\n\napps 目录下颜色有些是黄色的#\n\n在 Pycharm 中 apps 目录下应用库文件是黄色的，编辑器识别不到代码新增和修改；\n\n由于社区版 Pycharm 不能动态识别多仓库，需要在 setting 里面手动注册，操作步骤：\n\nFile —Settings —Version Control —点 + 号 —Directory 选中应用库工程目录 —VCS 选中 Git —Apply\n\n如此就可以了。\n\n专业版 Pycharm 一般不存在这个问题。\n\n\n执行 env.sh 报错 $'\\r':未找到命令#\n\n出现这个问题你应该是在 windows 上打开或编辑过 env.sh 脚本，windows下的换行是回车符+换行符，也就是\\r\\n，而 Linxu 下是换行符\n\\n，Linux 下不识别 \\r，因此报错。\n\n解决方案：\n\n\n\n\n怎样为单独某一条用例配置执行超时时间#\n\n在用例脚本中添加装饰器，如下：\n\n\n\n\n如何修复子仓库 master 分支游离头（detached head）#\n\n修复所有子仓库默认master 分支游离头\n\n","routePath":"/博客/2024/自动化过程","lang":"","toc":[{"text":"提交代码时提示邮箱或者名称不对","id":"提交代码时提示邮箱或者名称不对","depth":2,"charIndex":3},{"text":"怎么回滚到之前的版本","id":"怎么回滚到之前的版本","depth":2,"charIndex":44},{"text":"解决 git status 中文显示的问题","id":"解决-git-status-中文显示的问题","depth":2,"charIndex":189},{"text":"apps 目录下颜色有些是黄色的","id":"apps-目录下颜色有些是黄色的","depth":2,"charIndex":216},{"text":"执行 `env.sh` 报错 `$'\\r':未找到命令`","id":"执行-envsh-报错-r未找到命令","depth":2,"charIndex":-1},{"text":"怎样为单独某一条用例配置执行超时时间","id":"怎样为单独某一条用例配置执行超时时间","depth":2,"charIndex":587},{"text":"如何修复子仓库 master 分支游离头（detached head）","id":"如何修复子仓库-master-分支游离头detached-head","depth":2,"charIndex":628}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"锁屏被长时间锁住问题解决方法","content":"#\n\n\n背景#\n\n由于多次尝试，或者误操作导致登录系统桌面被锁住，需等待较长时间可重试，无法进入系统。且由于没有绑定 UOS ID，无法进行密码重置。\n\n\n现象#\n\n1、登录界面无法输入密码登录\n\n\n\n2、ssh 可连接，但是无法使用 sudo 进行提权（提示被锁住）\n\n\n解决方法#\n\n1、使用启动盘，引导进入系统修复界面\n\n2、在系统修复工具界面，挂载系统盘\n\n3、从系统修复工具 -> 工具，打开终端\n\n4、通过命令 lsblk 查看启动盘挂载目标\n\n5、通过命令 chroot 将根路径更换为指定目录，如：chroot /target\n\n6、进入系统配置文件路径 cd /var/lib/deepin/authenticate\n\n7、修改 config 文件config.json 、config_v1.json\n\n\n\n8、删除limit-states.json limit-states_v1.json 两个配置文件（保险起见，可进行备份）\n\n9、退出 chroot，重启系统","routePath":"/博客/2024/锁屏界面被长时间锁住问题","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":3},{"text":"现象","id":"现象","depth":2,"charIndex":77},{"text":"解决方法","id":"解决方法","depth":2,"charIndex":136}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":28,"title":"0312-FileServer 上线啦","content":"#\n\n我个人经常有一些文件需要存放，不喜欢放在本地，于是乎就有文件服务器的需求，但是基于 FTP 的文件服务器，只能说勉强能用，主要是界面太丑了。\n\n终于在 GitHub 上找到了 Dufs 界面挺漂亮，搭配 dufs-material-assets 效果棒棒哒。\n\nDufs 支持在浏览器端增删改文件，下载接口简单，权限管理也方便。\n\ndufs-material-assets 支持文档预览、音频播放、视频播放。\n\n而且还可以作为简易的文档管理使用，因为它可以自动展示 README.md 的内容，这样就可以方便的展示一些 markdown 文件，绝了。\n\n我很长一段时间给领导提供文档资料，就是通过这种形式，直接给领导一个网页链接，领导很方便的就可以查看内容。","routePath":"/博客/2025/997-0312-FileServer","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"0311-家庭网站搞不下去了","content":"#\n\n某一天和老婆聊到了现在的小学生竞选班委需要做 PPT 用于介绍自己，但是一般都是由家长带着一起做，实际这个事情也就落到了家长身上。\n\n我个人是对 PPT\n很不喜欢的，对我来讲太形式化了，当时只是一瞬间的想法：“何不如直接我做一个网站介绍自己，“天天”竞选班委的时候，直接在电脑上访问网站就能看到自我介绍，这多酷炫，\n毕竟我最近几年在公司已经做过好几个广受好评网站了，一个简单的自我介绍网站简直不要太简单。”\n\n就那一瞬间的想法，在之后的两天，我的脑海中不停的在想做网站这个事情，就一直在想如何去做，仔细想下来这里面还没那么简单。\n\n首先，“天天”的个人信息，不可能直接暴露在外网，这样信息安全风险太大了，如果只做家庭内网部署，就失去了意义，想在外网访问还得做内网穿透，也存在风险。\n\n然后，如果要在外网访问，必须要加用户登录权限管理，这就不能只是简单的静态网站了，静态站点做不了用户登录权限管理，必须得加后端才行，这样就稍微有点复杂了。\n\n再然后，网站是聚焦在“天天”个人介绍，我想的是要包含从小到大的成长过程，同时也包含一些家庭的精彩瞬间，肯定需要包含很多的图片，那前后端分离的系统，在图片资源多的\n情况下很吃网络资源，访问效果如何也不清楚，主要看云服务器的网络带宽以及考虑要不要加 CDN，但是这些费用都很贵，感觉有点划不来。\n\n复杂归复杂，不管怎么样我还是决定试一下，看看效果如何，花了几天时间，基于 FastAPI + Vue\n快速的开发了一套前后端系统，能够做用户登录管理、图片批量上传后一键排版、首页轮播照片等等，前端效果类似于\nVitePress，因此我将此私有项目命名为：PhotoPress。\n\n买了个 2 核 3 M\n的云服务器（便宜，配置再往上就贵了），将此前后端系统部署上去，也上传了几百张图片到服务器，网站的访问效果非常拉跨，图片加载很缓慢，但是我又不想继续投钱进去了。\n\n最后，“家庭网站”的想法实施不下去了，Damn~~😂😂。","routePath":"/博客/2025/998-0311-家庭网站搞不下去了","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"0309-文档从 VitePress 迁移到 Rspress","content":"#\n\n关注到 Rspress 是在看 Midscene.js （一个 AI + Playwright 的自动化工具）文档的时候，发现风格有点像\nVitePress，但又有点不同，于是乎就上 Rspress 开源项目去了解情况（彼时 star 才 1k+，未来可期），这是字节跳动的一个前端开源组织 Web\nInfra 下的一个开源项目，此开源组织基于 Rust 构建了前端一系列工具，因此 Rspress 主要特点就是速度快。\n\n经过大概一周断断续续的文档学习，我发现 Rspress 相比于 VitePress，有许多优点：\n\n 1. 自动生成导航及 sidebar\n    \n    Rspress 原生自带功能，调整排序顺序很方便， VitePress 需要三方库支持，但三方库支持得并不好，调整排序顺序很复杂。\n    \n    这个对于我来说就是刚需，有谁能理解修改文档名称，或者修改了大目录名称，还要去改路由配置有多麻烦。这是我迁移到 Rspress\n    最直接的原因，让你能专注于码字，而不需要花大量时间维护路由配置。\n\n 2. 内置很多好用的组件\n    \n    比如图片点击放大、一键返回顶部、预览页、socialLinks 支持很多国内的平台，而这些在 VitePress\n    里面都需要三方库支持，但三方库的实现质量堪忧。\n\n 3. VitePress 有的基本功能 Rspress 都有\n    \n    由于底层都是基于 markdown，因此在 markdown 语法上的显示效果几乎一样的，比如代码块、容器、高亮都一样，因此从 markdown\n    文档编写的角度讲，几乎没有迁移成本。\n\n当然，也有 Rspress 也有缺点，主要由于是 2024 年才开源的新项目，又是基于 React\n的框架，生态插件少，如评论插件、作者信息插件还没有，也有可能有插件，主要我还没有太多时间去折腾这块，还有手机端浏览器似乎适配不太好，不过这些功能相信后面会有的，\n而且现阶段对于我来说，这些功能也无所谓。\n\n在技术这块我从来都是“喜新厌旧”的，也有可能是已经用 VitePress 构建了好几个网站，有点审美疲劳了。\n\n说干就干，3 月 7 日，我“侍寝”到晚上 12 点，起床拿起电脑直接干到凌晨 3 点，从 Github 仓库创建、框架迁移、各种配置、Github\nAction 配置、云服务器配置，一段操作初版完成上线；3 月 8 日，一样的时间干到凌晨 3 点，文档细节调整、网站 logo\n重做，主题色直接用的默认，终于达到自己比较满意的状态。\n\n迁移到 Rspress 后，目前情绪稳定，感觉良好。dev 速度和 build 速度好像是要快一点。","routePath":"/博客/2025/999-0309-文档从Vitepress迁移到Rspress","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"博客-预览","content":"","routePath":"/博客/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"博客-预览"},"version":""},{"id":32,"title":"技术文档-章节预览","content":"","routePath":"/技术文档/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"技术文档-章节预览"},"version":""},{"id":33,"title":"4、附件：","content":"一种dock栏展示和交互方法技术交底书#\n\n\n0、缩略语和关键术语定义#\n\n术语      定义\ndock栏   在计算机操作系统上，dock栏也被叫做任务栏。任务栏是桌面上一个用于启动和管理程序的工具，也用于快捷切换程序界面。\ndbus    D-Bus是针对桌面环境优化的IPC（interprocess communication\n        ）机制，用于进程间的通信或进程与内核的通信。最基本的D-Bus协议是一对一的通信协议。但在很多情况下，通信的一方是消息总\n        线。消息总线是一个特殊的应用，它同时与多个应用通信，并在应用之间传递消息。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n目前市场上的桌面操作系统，dock 栏为默认常驻屏幕底部，展示方式通常为“一直显示”、“一直隐藏”、“智能隐藏”。在 dock\n栏一直显示的情况下，应用界面底部不能铺满屏幕，在一些小屏幕的显示器或笔记本上，应用可操作区域减少。即使将 dock\n栏展示在操作系统界面的左侧、操作系统界面的右侧或者操作系统界面的顶部，在操作系统使用过程中，应用界面底部不能铺满屏幕，在一些小屏幕的显示器或笔记本上，应用可操作\n区域减少的问题也存在。\n\n而智能隐藏或者一直隐藏时，用户体验感受较差，每次操作应用底部区域时容易误唤醒 dock 栏，造成误操作。这对正常且高效使用操作系统界面，存在使用不便的影响。\n\n如果将 dock 栏进行收缩后半透明悬浮展示，既 不会影响当前使用区域，也不会被误唤醒。只有当使用者需要唤醒时，可以手动进行点击唤醒 dock 栏。\n\n\n1.1、与本发明相关的现有技术一#\n\n1.1.1、现有技术一的技术方案#\n\n在 dock 栏右键菜单中可以进行状态设置，可以设置为“智能隐藏”或者“一直隐藏”。\n\n1.1.2、现有技术一的缺点#\n\n（1）在“智能隐藏”状态时，打开应用软件，如：浏览器，鼠标滑动到网页底部区域时会唤醒 dock 栏，从而不能直接响应点击到想要点击的位置；\n\n（2）在“一直隐藏”状态时，会出现“智能隐藏”状态时面临的同样的问题，给使用者带来不便。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n在 dock 栏右键菜单中可以进行显示位置设置，可以设置为“上”、“下”、“左”、“右”。\n\n1.2.2、现有技术二的缺点#\n\n改变 dock 栏展示位置，本质上与 dock 栏常驻在底部无明显差别，打开后的应用软件界面，如：浏览器、工作文档（wps）。界面显示都会被 dock\n栏占用一部分，在小屏幕设备上对使用者是一种资源的浪费和不好的体验感受。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n本发明实现dock栏收起悬浮展示的方式。为用户提供更大的界面使用感受，并能对小屏幕物理属性设备，达到更好的资源利用需求，而提供的解决方案。\n\n\n2.2、本发明提供的完整技术方案#\n\n\n\n图1 专利流程图\n\ndock 栏向右侧收起悬浮方案发明详细如下：\n\n（1）在 dock 栏状态设置中增加显示方式“缩略展示”；\n\n（2）设置为缩略展示后，dock 栏出现缩略展示的开关 icon；\n\n（3）用户点击缩略展示开关后，dock 栏向右侧收起，在屏幕右下角显示半透明 dock 栏 icon 图片，悬浮在最顶层；\n\n（4）当用户点击 dock 栏 icon 时，任务向左展开，展示为正常 dock 栏。\n\n\n\n图2 实际效果展示\n\n（5）收起后的悬浮 dock 栏依旧能保持正常形态的常用功能：\n\n * 当 dock 栏展示为缩略悬浮图标后，在任意程序界面，都处于最顶层页面。可以随时手动点击唤出正常展示形态。在处于 dock\n   悬浮形态时，默认进行系统时间展示。\n\n * 当 dock 后端 dbus 服务监听到应用通知信息，将该应用以 dock 插件的方式加载到 dock，并通知 dock Mainwindow\n   进行数据刷新，悬浮 dock 将应用提醒信息图标居中展示在悬浮 dock 中间，并进行闪烁提示。用户通过鼠标点击闪烁图标时，dock dbus\n   将信号发送到窗管。窗管接收到请求后，进行应用程序界面绘制和打开。dock 栏保持悬浮状态，dock\n   服务卸载该应用的插件，恢复为展示系统时间。如果点击闪烁图标以外的悬浮 dock 位置时，唤出 dock 栏正常展示形态。\n\n\n\n图3 应用消息提醒\n\n * 当dock后端dbus服务监听到多个应用通知信息，将各个应用以dock插件的方式加载到dock，并通知dock\n   Mainwindow进行数据刷新，悬浮dock图标交替闪烁应用提醒图标。用户点击悬浮dock任意位置时，恢复正常形态下dock栏显示以及功能。再次点击do\n   ck栏以外的位置，dock栏重新向右侧收起展示为悬浮dock栏状态。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n本发明旨在为特殊场景和小屏幕属性设备提供系统显示界面，为用户提高资源利用率。并在长久不便的 dock 栏展示形态中做出创新，为用户提供不一样的使用体验。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n暂无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n本发明的技术点在于 dock 栏半透明悬浮在操作系统界面的展示形态，以及 dock 栏新的展示形态如何进行人机交互的方法，且不影响固有 dock 栏的功能特性。\n\n本发明的欲保护点在于 dock 栏半透明悬浮展示形态、在悬浮 dock 栏上进行操作系统固有功能或应用消息的提醒展示，以及悬浮 dock 栏的交互方法。\n\n\n4、附件：#\n\n*附件一*\n\n*操作系统技术**领域划分简介*\n\n一级标签   二级标签   解释、涉及技术\n内核     进程管理   进程线程管理，进程控制、进程同步、进程通信、死锁处理、处理机调度等\n内核     存储管理   内存分配、地址映射、内存保护与共享、虚拟内存等\n内核     文件管理   文件存储空间的管理、目录管理、文件读写管理和保护等\n内核     设备管理   I/O 请求、缓冲管理、设备分配、设备处理、虛拟设备、驱动等\n内核     虚拟化    容器、namesapce、cgroup、kvm\n内核     安全     LSM、审计、静态度量、模块签名、密钥环、bpf、加密算法\n系统     驱动开发   USB驱动，用户态驱动、硬件抽象层\n系统     设备管理   蓝牙、磁盘、显示、输入设备、触摸屏幕、扫描、打印\n系统     包管理    升级、补丁、安装、卸载\n系统     安全     TPM、国密、防火墙、日志审计、身份认证、应用签名\n系统     可靠性    系统修复、异常处理、维护、备份\n系统     开发工具   编译、调试、IDE\n系统     测试     测试（压力测试等）、自动化测试、UI测试\n系统     通信     IPC、DBus、网络、信号、代理\n系统     OEM    授权、系统构建、量产、许可证、安装\n桌面     UI     窗口、控件绘制、输入框架、国际化、辅助功能、字体、高分辨率\n桌面     图形栈    图片、音频、视频、Xorg、Wayland、窗口管理器、OpenGL、Vulkan\n桌面     桌面环境   桌面、启动器、dock栏、菜单栏、托盘、标准目录、XDG\n桌面     网络服务   远程桌面、文件共享、屏幕共享、RDP、VNC\n桌面     应用软件   应用管理、兼容性、自启动","routePath":"/技术文档/专利交底书/一种dock栏展示和交互方法技术交底书","lang":"","toc":[{"text":"0、缩略语和关键术语定义","id":"0缩略语和关键术语定义","depth":2,"charIndex":22},{"text":"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":285},{"text":"1.1、与本发明相关的现有技术一","id":"11与本发明相关的现有技术一","depth":3,"charIndex":697},{"text":"1.1.1、现有技术一的技术方案","id":"111现有技术一的技术方案","depth":4,"charIndex":716},{"text":"1.1.2、现有技术一的缺点","id":"112现有技术一的缺点","depth":4,"charIndex":779},{"text":"1.2、与本发明相关的现有技术二","id":"12与本发明相关的现有技术二","depth":3,"charIndex":914},{"text":"1.2.1、现有技术二的技术方案","id":"121现有技术二的技术方案","depth":4,"charIndex":933},{"text":"1.2.2、现有技术二的缺点","id":"122现有技术二的缺点","depth":4,"charIndex":999},{"text":"2、本发明技术方案的详细阐述","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":1130},{"text":"2.1、本发明所要解决的技术问题","id":"21本发明所要解决的技术问题","depth":3,"charIndex":1148},{"text":"2.2、本发明提供的完整技术方案","id":"22本发明提供的完整技术方案","depth":3,"charIndex":1239},{"text":"2.3、本发明技术方案带来的有益效果","id":"23本发明技术方案带来的有益效果","depth":2,"charIndex":2062},{"text":"2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":2,"charIndex":2162}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":34,"title":"一种基于Linux系统执行自动化测试用例实现负载均衡的技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                          \n术语       全称               解释\nSSH      Secure Shell     专为远程登录会话和其他网络服务提供安全性的协议，通过SSH服务可以远程连接到一个Linux操作系统，并进行一些远程操作。\n                          下文中的ssh表示命令，SSH表示服务。\nSocket   Socket           Socket（套接字），应用程序可以通过Socket向网络发送请求或者应答网络请求。\nps命令     process status   命令用于显示当前进程的状态，类似于 windows 的任务管理器。\nscp命令    secure copy      是 Linux 系统下基于 ssh 登陆进行安全的远程文件拷贝命令。\npytest   pytest           基于Python的常用自动化测试框架，可通过命令行执行测试用例。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在对UOS操作系统桌面应用进行自动化测试的过程中，由于自动化测试用例数量很多，单台测试机执行所有自动化用例时间很长。\n\n为了满足持续集成持续交付业务要求，自动化测试用例需在较短时间内完成执行。因此，需要同时在多台测试机上执行测试用例，所有测试机执行完用例之后返回汇总结果。\n\n在现有技术里面，基于云测试的自动化测试用例分发和执行方案，均设计为将自动化用例分发到多台测试机上执行。大多是手机端的APP自动化测试方案，测试端连接多台手机，服\n务端控制测试机进行分布式执行用例。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n通过给不同的测试机指定分配对应的测试用例，比如：总共两台测试机，之前需要先在配置文件里面配置好哪台机器执行哪些用例。当然，做的比较好的也有不用配置用例范围的方案\n，即通过用例管理进行顺序或随机分发，但是这些方案，都是基于socket协议，在服务端和测试段都需要开启socket服务，因此在测试环境部署方面要求偏高。\n\n1.1.2、现有技术的缺点#\n\n（1）需要结合用例总体运行时间，单独给每个测试机配置用例执行容量，后续随着自动化测试用例数量增加，需要结合每台测试机的执行容量，合理分配到各个测试机上。\n\n（2）所有测试机同时开始执行时，由于无法提前判断哪台机器先执行完，先执行完的测试机，只能等待后执行完的测试机完成之后才能汇总结果，等待的这段时间，不仅浪费了时间\n，也浪费了硬件资源。\n\n（3）基于socket协议，通常需要在测试机上提前手动部署socket服务，当测试机比较多的情况下，操作起来就比较麻烦。\n\n（4）没有对用例执行过程中异常情况，如用例进程卡住、测试机系统卡住等情况的处理。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）解决执行自动化测试用例，需要配置每台测试机执行的用例容量。\n\n（2）解决先执行完的测试机等待后执行完测试机，造成硬件资源浪费的问题。\n\n（3）解决需要提前在测试机上手动部署测试环境的问题。\n\n（4）解决在用例执行过程中，出现一些异常情况，能自动判断并解决相应异常问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n服务端与测试机采用SSH通讯，SSH通常在Linux系统上都会自带，因此不需要手动部署环境，整个测试过程可以全程自动化无人参与完成。\n\n服务端通过SSH隧道下发命令，测试机被动接受命令执行即可，整个测试过程均由服务端来控制。\n\n如果存在测试用例执行的进程，说明测试机当前正在执行测试用例，服务端将会ssh连接下一台测试机进行相同的检查操作，如果此时这台测试机上不存在测试用例执行的进程，说\n明测试机当前处于空闲状态，则服务端会通过ssh远程连接测试机执行这条测试用例。\n\n如此循环操作，直至所有测试用例执行完成。\n\n\n\n图（一）负载均衡分布式执行测试用例流程图\n\n2.2.1、用例分配管理#\n\n服务端通过文件查找，收集项目下所有要执行的用例，将收集到的用例保存为一个序列。获取测试用例名称列表可以参考以下方法：\n\n\n\n测试用例文件名称均为以“test”开头且以“.py”结尾的文件，test_case_list 为测试用例目录下的所有测试用例名称列表。\n\n用例分配可以通过入参决定，可以对测试用例名称列表进行遍历，也可以通过随机从列表中取出。\n\n遍历执行属于正常的功能测试自动化手段，而随机执行的时候可以指定执行的总时长，这种方法通常可以作为一种应用稳定性测试的自动化手段。可以根据要测试\n\n2.2.2、节点分配管理#\n\n服务端遍历所有需要执行的用例，通过子进程使用ssh远程连接测试机，使用ps命令查询测试机上是否存在自动化用例执行的进程，如果存在说明当前测试机负载状态为繁忙，测\n试机会将此状态返回给服务端，服务端接受到繁忙状态之后，会继续通过ssh连接下一台测试机进行相同的进程检测操作；\n\n如果未测试返回给服务端的状态为空闲，则服务端会发起执行测试用例的指令。\n\n服务端远程连接查询自动化用例执行进程的命令为：\n\n\n\n其中user为测试机的用户名，ip为测试机的ip地址，pytest为自动化测试框架，我们通常使用它来执行自动化测试用例，用例执行的进程里面会包含pytest字符\n。\n\n如果返回的数据为空，表示当前测试机负载状态为空闲。\n\n如果返回的数据不为空，表示当前测试机负载状态为繁忙。\n\n2.2.3、服务端控制测试机执行用例#\n\n服务端会提前把所有需要执行的测试用例文件，通过ssh远程拷贝到测试机上，服务端控制测试机执行测试用例的命令为：\n\n\n\n其中user为测试机的用户名，ip为测试机的ip地址，test_cases.py为测试用例的文件名称。\n\n2.2.4、测试机环境异常处理#\n\n每次测试机返回繁忙状态给服务端之后，服务端会通过计时控制模块做对应测试机的计时，如果计时的时长超过了阈值（阈值可以通过配置），我们认为测试环境可能出现一些异常情\n况，比如测试用例执行进程卡死等，所以服务端会将测试机上的执行进程杀掉。\n\n2.2.5、收集测试报告#\n\n测试机每次执行完一条用例之后会生成一个独立的测试报告，所有用例执行完之后，通过命令将测试机上的测试报告返回到服务端，并在服务端完成测试报告的整合，形成最终的测试\n报告。\n\n从测试机上返回测试报告到服务端的命令为：\n\n\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）执行前准备工作更加便捷，配置方面只需要指定测试机的user和ip，无需考虑每个测试机具体的用例执行容量；\n\n（2）自动化测试执行更加高效，硬件资源运用更加合理，只要测试机处于空闲状态就能执行自动化用例。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）通过用例管理模块获取需要执行的用例列表，并自动分配要执行的测试用例给节点分配模块，节点分配模块通过子进程使用远程控制服务，控制测试机执行测试用例，实现分布\n式并行执行测试用例。\n\n（2）测试机通过进程检测当前是否空闲，然后返回当前状态给服务端，服务端接收到测试机状态之后判断是否下发测试任务，提供了测试机执行用例的负载均衡机制。\n\n（3）如果测试机长时间处于繁忙状态，可能存在测试机环境异常情况，因此杀掉进程之后重新执行后续任务，提供了一种测试机环境异常处理的机制。\n\n（4）将测试机上生成的单条测试用例的测试报告全部返回发送到服务端，由服务端完成测试报告的汇总整合，提供了测试结果的标准化输出机制。\n\n（5）提供了一种在大规模部署执行自动化用例场景下，分布式执行测试用例并实现负载均衡的技术方案。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl Linux 下 ssh 命令实例指南：\n\nhttps://linux.cn/article-3858-1.html\n\nl Linux scp命令：\n\nhttps://www.runoob.com/linux/linux-comm-scp.html\n\nl Linux ps 命令：\n\nhttps://www.runoob.com/linux/linux-comm-ps.html\n\nl pytest: helps you write better programs：\n\nhttps://docs.pytest.org/en/6.2.x/","routePath":"/技术文档/专利交底书/一种基于Linux系统执行自动化测试用例实现负载均衡的技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、用例分配管理**","id":"221用例分配管理","depth":4,"charIndex":-1},{"text":"**2.2.2、节点分配管理**","id":"222节点分配管理","depth":4,"charIndex":-1},{"text":"**2.2.3、服务端控制测试机执行用例**","id":"223服务端控制测试机执行用例","depth":4,"charIndex":-1},{"text":"**2.2.4、测试机环境异常处理**","id":"224测试机环境异常处理","depth":4,"charIndex":-1},{"text":"**2.2.5、收集测试报告**","id":"225收集测试报告","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":35,"title":"一种基于图像识别的桌面应用控件智能标注的交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                    \n术语         全称       解释\n分帧         视频分帧     将视频分解为一帧一帧的图片。\nlabelImg   图像标定工具   LabelImg 是一个可视化的图像标定工具\nOpenCv     OpenCV   OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在Linux、Windows、A\n                    ndroid和Mac OS操作系统上。\n数据模板       数据模板     根据人工标注得到的数据，提取固定的数据格式生成的包含图片路径、元素的左上、左下、右上、右下坐标的xml格式的数据模板\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n智能自动化测试机器学习和深度神经网络算法，需要大量的图片素材进行数据标注，之后才能用于训练识别模型。智能识别旨在解决图像识别坐标定位中，桌面元素微调导致的元素定\n位失败的问题。但目前智能识别所需要的机器学习和深度神经网络算法大部分都是依赖数据的，需要大量的训练数据。由于桌面应用功能多样化、复杂化、控件数据量庞大，需要标注\n大量的素材。\n\n实际工作中，为了得到训练数据，常使用人工标注的方式获得所需要的训练数据。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n日常生产环境中，我们根据自动化用例分析出所需的桌面控件，然后截取桌面图片，然后使用LabelImg打开所截取的图片，标注用例所需要的控件。\n\n以应用启动为例，所需步骤：\n\n（1）点击打开启动器。\n\n（2）在启动器中搜索应用名。\n\n（3）双击应用名打开应用\n\n分析所需元素控件为启动器、启动器中搜索栏、搜索结果三种控件，为保证训练数据丰富，需要在不同场景下截取这三种控件进行标注，每种控件至少16张图片素材。然后使用la\nbelImg打开所截取的图片，分别标注启动器，搜索栏，搜索结果三种控件，从而获取训练数据。\n\n1.1.2、现有技术的缺点#\n\n（1）人工数据标注成本高：智能识别训练需要海量的训练数据，数据标准需要大量的人力和时间，制作训练数据的成本高。\n\n（2） 人工标注的质量不高：多人标注时，会因为标注人的主观意识不同，或对相同控件标注的命名不同等人为因素，会导致标注的数据有误差，从而训练的结果不准确。\n\n可见智能识别数据的人工标注存在成本高，且质量无法保证到缺点。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）采用自动化标注，解决人工标注的人力和时间成本。\n\n（2）采用图像识别，精确识别所需的标注的控件，保证标注的尺寸大小一致，提高标注质量。\n\n\n2.2、本发明提供的完整技术方案#\n\n打开屏幕录制软件，录制手动操作一次测试用例，然后将录制的视频进行分帧，然后对比前两帧图标相似度，剔除相似度过高的图片，在保证素材多样性的前提下，剔除重复多余的图\n片生成待标注的素材集，然后取出控件模板数据集，通过OpenCv模板匹配获取控件在待标注的素材图片中所在的左上、左下、右上、右下四处坐标，从而根据模板数据集生成标\n注数据。\n\n2.2.1、准备待标注素材图片#\n\n以应用启动为例说明：\n\n（1） 打开屏幕录制软件，实时录制屏幕。\n\n（2） 手动执行一次启动器启动应用，生成录制的视频文件。\n\n（3） 使用FFmpeg将视频分帧为一帧一帧的图片，生成待标注的素材库\n\n（4） 使用OpenCv对比前后两帧图片，若相似度大于预设阈值，则认为是相同的素材，任意删除一张，确保素材不重复。\n\n2.2.2、准备模板图片#\n\n（1） 使用截图工具分别截取启动器图标、搜索栏、搜索结果作为模板，放入模板库中。\n\n2.2.2、标注素材#\n\n（1） 循环取出模板库中的图片和待标注的素材进行模板匹配，若存在该模板，则获取模板在待标注的素材中的左上、左下、右上、右下、四处坐标。\n\n（2） 将以上四处坐标写入数据模板中，生成训练数据。\n\n后续不断的完善并更新模块库，则可以将以往的未标注上的控件均重新标注。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了人工标注所耗用的大量人力、时间成本。\n\n（2）解决了人工标注时，人主观意识所导致的训练数据质量问题。\n\n（3）解决了素材维护问题，后续只需要不断的完善并更新模板库后，可以将以往未标注控件的素材上重新标注。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）通过录制视频，分帧的方式获取待标注的素材库。\n\n（2）通过模板与待标注的素材进行图像识别，生成训练数据。\n\n（3）通过维护模板库库，即可对以往的训练数据重新标注。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl FFmpeg 视频分帧：\n\nhttps://blog.csdn.net/qq\\_33373858/article/details/83690331\n\nl OpenCv 模板匹配：\n\nhttps://blog.csdn.net/weixin\\_33946659/article/details/112288874","routePath":"/技术文档/专利交底书/一种基于图像识别的桌面应用控件智能标注的交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、准备待标注素材图片**","id":"221准备待标注素材图片","depth":4,"charIndex":-1},{"text":"**2.2.2、准备模板图片**","id":"222准备模板图片","depth":4,"charIndex":-1},{"text":"**2.2.2、标注素材**","id":"222标注素材","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"李涛、mikigo、张龙"},"version":""},{"id":36,"title":"一种基于机器学习智能识别元素控件的UI自动化测试方法","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                                                   \n缩写           全称                                    描述\nOpencv       Open Source Computer Vision Library   一个计算机视觉库，是一个基于BSD许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在Linux、Window\n                                                   s、Android和Mac OS操作系统上。。\nWebM         WebM                                  一种视频文件格式，可用于实时录制和实时读取。\nTensorflow   Tensorflow                            一个开源机器学习工具，是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现。由谷歌人工智能团队谷歌\n                                                   大脑（Google Brain）开发和维护。\nPytorch      Pytorch                               一个开源的Python机器学习库，基于Torch，用于自然语言处理等应用程序。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在Linux桌面应用UI自动化测试的实施过程中，元素控件的定位经常会依赖于图像识别，通过识别目标控件在屏幕中的位置，从而控制鼠标键盘在此位置进行操作，最后再通过\n图像识别判断用例是否执行成功。\n\n\n1.1、与本发明相关的现有技术一#\n\n1.1.1、现有技术一的技术方案#\n\n基于Opencv提供的模板匹配功能，对比目标小图和屏幕大图，计算出在屏幕中的位置。\n\n1.1.2、现有技术一的缺点#\n\n（1）使用Opencv的模板匹配功能做目标元素定位和自动化用例断言时，如果UI发生细微变化都会出现识别失败，导致自动化用例不够健壮，而自动化测试人员，需要频繁的\n去更换图片资源，增加了自动化用例的维护成本。\n\n（2）Opencv在ARM和MIPS上没有对应的官方包，存在无法使用pip安装Opencv的问题，在搭建自动化测试环境的时候，比较费时间。\n\n（3）在自动化测试项目中需要保存大量的图片资源，在自动化测试后期，对图片资源的管理和维护将成为一个难点。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n通过应用属性获取应用的元素坐标，比如：\n\n（1）Web端，可以通过获取html的标签属性，从而获取在浏览器中的位置。\n\n（2）桌面应用端，可以通过基于Accessibility对Qt应用的元素控件添加ObjectName，从而定位到元素控件的坐标。\n\n（3）App端，可以通过应用的标签属性获取到元素控件的坐标。\n\n这些都可以统称为通过属性的方式去获取坐标的技术方案。\n\n1.2.2、现有技术二的缺点#\n\n（1）定位不稳定，Web端网络请求需要时间，采用属性定位存在概率性失败的情况。\n\n（2）速度慢，通过属性定位时，其实都是通过整个属性标签的树形结构去寻找，如果属性的数量很大，并且树形结构层级很多，定位的速度会很慢。\n\n（3）元素定位方案存在局限，如果某个元素控件没有添加属性标签，采用相对定位或者索引定位的方案，会增加自动化脚本后期的维护难度。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）在UI自动化测试过程中，由于需求迭代时UI细节变化频繁和受到环境影响导致的断言准确性问题。\n\n（2）在UI自动化测试过程中，采用图像识别的定位方案时，需要频繁的维护图片资源，自动化用例维护成本高。\n\n（3）在UI自动化测试过程中，采用属性定位元素控件时不稳定、效率不高的问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n在UI自动化测试的过程中，测试机上的画面通过视频采集手段实时传输到服务器上，服务器基于机器学习和训练模型对实时传输过来的视频画面做识别。\n\n智能识别模块，通过对大量图片素材进行数据标注，用于训练智能识别模型库，然后基于TensorFlow或Pytorch等机器学习框架，识别视频中应用的元素控件，最后\n将识别的坐标返回出来。\n\n服务器通过智能化分析，如果测试结果与预期一致，将下一步操作指令通过USB模拟鼠标键盘串口设备发送给测试机，从而实现控制测试机执行自动化用例；如果测试结果与预期不\n一致将会进入中断处理及异常结果输出，继续执行后续场景，直至所有用例测试完成。\n\n\n\n图（一）智能识别自动化测试方案流程图\n\n2.2.1测试机与服务器连接及通讯方式#\n\n（1）测试机上的画面通过视频采集手段实时转发到服务器上，服务器上通过视频录制软件实时获取到测试机上的画面视频，将视频格式设置为WebM格式，可以实时录制实时读取\n。\n\n（2）测试机与服务器在同一个局域网内，采用USB模拟鼠标键盘串口设备连接，用于服务器在智能识别到目标元素之后，给测试机下发下一步操作指令。\n\n2.2.2 智能识别+UI自动化测试#\n\n智能识别主要使用Tensorflow或Pytorch流行的开源深度学习框架，实现目标检测的功能，找到目标的坐标位置（x，y），然后将获取到的坐标，作为参数传递给\n自动化测试脚本。\n\n自动化测试脚本中通过USB模拟鼠标键盘串口设备，将操作指令发送给测试机，实现鼠标和键盘的基本操作：\n\n（1） click 左键单击\n\n（2） right_click 右键单击\n\n（3） double_click 左键双击\n\n（4） drag_to 拖拽到（绝对位置）\n\n（5） drag_relative 拖拽距离（相对位置）\n\n（6） input 输入\n\n所有的基本操作使用Python语言封装接口，支持传参传递，在自动化测试执行过程中，将智能识别获取到的坐标，传递给封装的键鼠操作接口，最后执行操作脚本即可实现在测\n试机上执行测试用例步骤。\n\n比如：在智能识别一个控件的时候，识别到的坐标为（100, 100），需要左键点击时，将代码组装为：\n\n\nclick(100, 100)\n\n运行脚本，实现服务器下发指令到测试机执行点击动作。\n\n2.2.3 智能识别目标元素#\n\n智能识别元素的方案可以使用基于深度学习的目标检测方案，从而定位到，目标出现在图像的位置。\n\n目前常用的目标检测算法按照阶段分类主要有两种：\n\n一种是tow stage目标检测算法有：R-CNN、SPP-Net、Fast R-CNN、Faster\nR-CNN和R-FCN等。原理是先进行特征提取，然后对目标做预框选，最后定位位置。\n\n另一个种是one\nstage目标检测算法有：OverFeat、YOLOv1、YOLOv2、YOLOv3、SSD和RetinaNet等。原理是先进行特征提取，然后直接进行回归定位位\n置。\n\n通过训练智能识别的模型，目标检测算法就可以定位到目标控件的坐标位置。\n\n2.2.4 训练识别模型#\n\n通过对数据标注好的图片进行模型训练，可以生成智能识别所需要的模型库。\n\n2.2.5 目标元素特征标注#\n\n使用labelme或labelImg等数据标注软件对图片素材进行数据标注，比如使用labelme，使用鼠标对目标进行框选，类似于PS抠图，圈出目标图案之后保存会\n生成一个json文件，文件中保存的就是训练模型所要用到的特征数据。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）基于机器学习的技术方案，通过对大量图片资源训练智能识别的模型，提升元素识别的准确性，解决传统UI自动化测试中元素控件定位、断言不稳定性和准确性问题，提升了\nUI自动化测试在目标元素定位和断言的灵活性。\n\n（2）采用设备分离的设计方案，所有数据由服务器来处理，处理速度极快，解决传统UI自动化测试中定位元素速度慢的问题，测试用例执行慢的问题，提升了自动化测试执行的效\n率。\n\n（3）解决UI自动化测试中，受到需求迭代、环境因素导致UI变化，导致自动化用例失败的健壮性问题，减少了自动化用例代码及测试资源的维护成本。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n暂无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）采用设备分离的技术方案，通过视频采集设备将测试机上的画面转发输出到服务器，服务器捕获视频画面并进行智能识别，所有测试用例在服务器上执行，通过USB模拟鼠标\n键盘串口设备下发测试指令给测试机，从而完成UI自动化测试。\n\n（2）对国产化操作系统进行UI自动化测试时，采用基于机器学习的目标检测技术，用于自动化测试中的元素定位，再使用鼠标键盘在坐标位置操作，从而实现智能自动化测试的技\n术方案。\n\n\n4、附件：#\n\n参考文献","routePath":"/技术文档/专利交底书/一种基于机器学习智能识别元素控件的UI自动化测试方法","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":664},{"text":"**1.1、与本发明相关的现有技术一**","id":"11与本发明相关的现有技术一","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术一的技术方案**","id":"111现有技术一的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术一的缺点**","id":"112现有技术一的缺点","depth":4,"charIndex":-1},{"text":"**1.2、与本发明相关的现有技术二**","id":"12与本发明相关的现有技术二","depth":3,"charIndex":-1},{"text":"**1.2.1、现有技术二的技术方案**","id":"121现有技术二的技术方案","depth":4,"charIndex":-1},{"text":"**1.2.2、现有技术二的缺点**","id":"122现有技术二的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1测试机与服务器连接及通讯方式**","id":"221测试机与服务器连接及通讯方式","depth":4,"charIndex":-1},{"text":"**2.2.2 智能识别+UI自动化测试**","id":"222-智能识别ui自动化测试","depth":4,"charIndex":-1},{"text":"**2.2.3 智能识别目标元素**","id":"223-智能识别目标元素","depth":4,"charIndex":-1},{"text":"**2.2.4 训练识别模型**","id":"224-训练识别模型","depth":4,"charIndex":-1},{"text":"**2.2.5 目标元素特征标注**","id":"225-目标元素特征标注","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":37,"title":"4、附件：","content":"一种定位目标图片坐标的图像识别技术交底书#\n\n\n0、缩略语和关键术语定义#\n\n                                                      \n缩写              全称                                    描述\nOpencv          Open Source Computer Vision Library   是一个开源的计算机视觉库。\nRGB             红(R)、绿(G)、蓝(B)                        RGB即是代表红、绿、蓝三个通道的颜色， 强度值为0~255，比如：白色(0 0 0)，黑色(255 255 255)\nDogtail         Dogtail                               一个使用Accessibility定位Qt应用中元素控件坐标的工具，是一个基于Python的开源三方库。\nAccessibility   Accessibility                         即辅助功能，在应用中提供Accessibility接口，使得外部软件可以操作相应的功能，技术诞生的初衷是为了让身体残疾的\n                                                      人能使用计算机。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n元素的定位是自动化测试的核心内容，无论是web自动化测试还是app自动化测试都会存在元素定位不到的问题，此时可以考虑采用图像识别实现，通常采用Opencv提供的\n模板匹配技术，通过对比目标小图和屏幕大图，即可计算出小图在屏幕中的位置。\n\n\n1.1、与本发明相关的现有技术一#\n\n1.1.1、现有技术一的技术方案#\n\n基于Accessibility对Qt应用的元素控件添加ObjectName，使用Dogtail工具提供的方法去定位元素控件。\n\n1.1.2、现有技术一的缺点#\n\n（1）定位速度慢，对于元素控件继承的层级太多，在树形结构里面层级就会很深，Dogtail寻找元素的时候会去遍历树形结构里面所有的东西，导致元素定位速度慢。\n\n（2）Dogtail工具本身存在不稳定性，在寻找元素的时候，存在找不到的情况，比如右键菜单里面的选项，使用Dogtail定位时，返回坐标始终为(0, 0)。\n\n（3）如果应用中某些元素无法添加ObjectName时，只能通过索引的方式去找，不利于自动化测试用例的维护性。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n基于Opencv提供的模板匹配功能，对比目标小图和屏幕大图，计算出在屏幕中的位置。\n\n1.2.2、现有技术二的缺点#\n\n（1）使用Opencv的模板匹配函数，需要通过Opencv提供的imread函数读取图片，而imread函数只能传入图片的路径，也就是说必须要有目标小图和屏幕大\n图的本地文件，在自动化测试用例中，目标小图是提前截好的，放到一个固定位置，而屏幕大图是在用例执行的过程中实时截取的，这样就必须要将实时截取的屏幕大图保存为本地文\n件，这点就会有一些问题。\n\n在AMD平台上由于计算机处理速度相对较快，实时保存图片文件的动作不会有明显的感觉，而在ARM和MIPS平台上计算机处理速度相对较慢，用例执行的过程中，屏幕大图保\n存的文件相对于要识别的时间点是滞后的，最主要原因就在于要生成本地图片文件。\n\n（2）Opencv在ARM和MIPS上没有对应的官方包，无法使用pip安装Opencv的问题，在搭建自动化测试环境的时候，比较费时间。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）在国产化平台UI自动化测试过程中，定位元素控件时不稳定，且速度较慢。\n\n（2）自动化测试操作步骤中，需要准确获取元素控件的坐标。\n\n（3）在UI自动化测试过程中，UI界面变化大，且容易受到环境影响，断言的准确性问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n在自动化测试的过程中，通常将需要识别的按钮或控件区域截取为一个小图，然后在整个屏幕中对小图进行匹配。为了实现识别图像的目的，我们可以通过将图片的每个像素的RGB\n值，与整个屏幕中的RGB进行对比，如果小图上的RGB值与对应大图位置的RGB都相等，则匹配成功，即可返回小图在大图中的中心坐标点。\n\n\n\n图1 图像识别流程图\n\n2.2.1 读取小图和大图的RGB值#\n\n（1）小图的RGB值\n\nsmall_data = small_pic.load() #\nload()会将图片的RGB值获取到，数据格式为一个二维列表，赋值给一个变量small_data。\n\n（2）大图的RGB值\n\nbig_data = big_pic.load()\n\n2.2.2 将小图与大图的RGB值进行匹配#\n\n（1）匹配从大图的坐标（0，0）开始匹配，匹配小图里面所有的坐标点（0，0）—（small_pic.width，small_pic.height）\n\n\n\n图2 匹配启始位置\n\n（2）如果在大图的（0，0）对应的所有小图的RGB值不相等，则移动到下一个坐标点（1，0），同样匹配小图里面所有的坐标点（0，0）—（small_pic.wid\nth，small_pic.height）\n\n\n\n图3 逐个像素点移动\n\n（3）按照这样的规律将这一行每移动一个坐标点，都将小图所有的RGB与对应大图的值进行匹配。\n\n\n\n图4 移动到一行的最右边\n\n（4）如果在大图的其中一个坐标点上匹配到了小图的所有RGB值，则此时返回小图在大图中的坐标点。\n\n\n\n图5 找到在屏幕中的位置\n\n（5）如果匹配了大图所有的坐标点，都没有匹配到，则说明大图中不存在小图，匹配失败。\n\n\n\n图6 移动到最右下角都没有找到\n\n2.2.3 关键技术#\n\n根据以上的设计思路，代码实现如下：\n\n\n\n通过match_image()这个函数，传入目标小图的文件名称，即可返回在当前屏幕中的中心坐标。\n\n在UI自动化测试项目中，测试用例如果需要通过图像识别去获取目标控件的坐标，只需调用这个函数即可。\n\n2.2.3.1 小图在大图中匹配的逻辑算法#\n\n$$ smallRGB[i, j] = bigRGB[x + i, y + j] $$\n\n其中，x是大图的横坐标的遍历的值，y是大图的纵坐标的遍历的值，i是小图的横坐标的遍历的值，j是小图的纵坐标的遍历的值，RGB的取值是在(0, 0\n,0)~(255, 255, 255)之间。\n\n2.2.3.2 快速匹配#\n\n在小图中随机选取一些坐标点，如果选取的这些坐标点存在与大图中RGB值不相等的情况，则直接跳出本次匹配，进行大图的下一个坐标点的匹配，如果选取的坐标点都匹配成功，\n再进行剩余坐标点的匹配，这样可以实现小图在大图中快速匹配的效果，提升图像识别的速度。\n\n2.2.3.3 匹配度\n\n在实际应用中，我们需要对错误匹配的坐标点有一定的容忍度，这里我称为”匹配度“。比如，匹配度为90%，也就是说，只要小图中90%的坐标点的\nRGB，与大图中对应位置能匹配上，那么就判定为匹配成功。\n\n同时，我们对随机选取做”预匹配“的几个点也设置一个匹配度，这样可以进一步提升匹配效率。\n\n在实际项目中，我将匹配度设置为90%时，在近三个月的自动化用例执行过程中，每天执行857条用例，没有出现误报的情况。\n\n2.2.3.4 在UI自动化测试中的应用\n\n（1）获取到元素控件的坐标之后，使用 xdotool 或者 pyautogui 等工具，对元素进行点击、双击、拖拽、输入等动作，实现 UI\n自动化测试中的操作步骤。\n\n（2）通过判断屏幕中是否存在元素，用于 UI 自动化测试中的断言。\n\n（3）由元素控件的定位及操作，以及在关键步骤的断言，构成了 UI 自动化测试的完整解决方案。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了 UI 自动化测试中，在国产化平台系统资源不足的情况下，快速实现元素控件定位。\n\n（2）降低了自动化测试环境搭建的复杂度，同时减少了自动化测试环境搭建的时间，从而提升测试效率。\n\n（3）在 UI 自动化测试中，能准确对自动化用例执行结果进行断言。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n暂无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）将屏幕大图的RGB值保存到内存中，然后通过算法：$smallRGB[i, j] = bigRGB[x + i, y + j]$ 对比目标图片与屏幕大图\nRGB 值，从而获取到目标图片在屏幕中的坐标位置。同时，在对比图像的过程中，通过随机选取一些点进行预匹配，提高图像识别的的速度，解决了在图像对比过程中，消耗大量\nCPU 资源的问题。通过设置匹配度，提供图像识别的成功率，提高在 UI\n自动化测试中使用图像识别的稳定性，同时提升了自动化测试脚本的健壮性和稳定性，解决了在图像识别的过程中，国产化架构平台生成本地图片文件速度慢的问题，实现了在国产化\n平台上执行UI自动化测试过程中，快速、稳定的定位目标元素控件的效果。\n\n（2）通过获取到元素控件的坐标，再配合使用 xdotool 或者 pyautogui 等工具，控制鼠标和键盘进行操作，从而实现 UI\n自动化测试中模拟人工测试的操作步骤的技术方案运用。\n\n（3）通过获取到元素控件的坐标，进而可以判断目标元素是否存在，可用于UI自动化测试中的关键位置的断言方案运用。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl random:\n\nn https://docs.python.org/zh-cn/3/library/random.html\n\nl pyscreenshot:\n\nn https://github.com/ponty/pyscreenshot/tree/2.3\n\nl PIL\n\nn https://pillow.readthedocs.io/en/stable/","routePath":"/技术文档/专利交底书/一种定位目标图片坐标的图像识别技术交底书","lang":"","toc":[{"text":"0、缩略语和关键术语定义","id":"0缩略语和关键术语定义","depth":2,"charIndex":23},{"text":"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":619},{"text":"1.1、与本发明相关的现有技术一","id":"11与本发明相关的现有技术一","depth":3,"charIndex":778},{"text":"1.1.1、现有技术一的技术方案","id":"111现有技术一的技术方案","depth":4,"charIndex":797},{"text":"1.1.2、现有技术一的缺点","id":"112现有技术一的缺点","depth":4,"charIndex":880},{"text":"1.2、与本发明相关的现有技术二","id":"12与本发明相关的现有技术二","depth":3,"charIndex":1114},{"text":"1.2.1、现有技术二的技术方案","id":"121现有技术二的技术方案","depth":4,"charIndex":1133},{"text":"1.2.2、现有技术二的缺点","id":"122现有技术二的缺点","depth":4,"charIndex":1195},{"text":"2、本发明技术方案的详细阐述","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":1578},{"text":"2.1、本发明所要解决的技术问题","id":"21本发明所要解决的技术问题","depth":3,"charIndex":1596},{"text":"2.2、本发明提供的完整技术方案","id":"22本发明提供的完整技术方案","depth":3,"charIndex":1729},{"text":"2.2.1 读取小图和大图的RGB值","id":"221-读取小图和大图的rgb值","depth":4,"charIndex":1910},{"text":"2.2.2 将小图与大图的RGB值进行匹配","id":"222-将小图与大图的rgb值进行匹配","depth":4,"charIndex":2065},{"text":"2.2.3 关键技术","id":"223-关键技术","depth":4,"charIndex":2484},{"text":"2.3、本发明技术方案带来的有益效果","id":"23本发明技术方案带来的有益效果","depth":2,"charIndex":3331},{"text":"2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":2,"charIndex":3484}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":38,"title":"","content":"0、缩略语和关键术语定义#\n\n术语            全称   解释\nPyPI               Python官方的三方包存储平台，在公网上打包发布的Python三方包都是发布到此平台；\npip                Python官方默认的包管理工具，提供了对Python包的安装、卸载等功能；\nVirtualenv         常用的Python虚拟环境管理工具，它可以创建一个或多个独立的Python虚拟化环境；\nPython环境虚拟化        在一个用户自定义的目录空间，创建一个全新的、完整的Python环境（包含Python解释器、包管理器等），\n                   此Python环境完全与外界Python环境完全隔离（包括系统本身的Python环境、其他Python虚拟环境），因此我\n                   们在此虚拟环境中安装的任何三方包不会影响到系统本身的Python环境，反之亦然。用于解决多个项目使用Python包版本冲\n                   突的问题。\ndeb                一种软件包格式，deb 格式是 Debian 系统(包含 Debian 和 Ubuntu )专属安装包格式，配合 APT\n                   软件管理系统，是一种在 Linux 下非常流行的一种安装包。\nrpm                和deb一样，是Centos系统的安装包格式，也是一种非常流行的安装包。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在许多Linux操作系统上通常默认安装了Python环境，系统自带的Python环境是指的安装在系统目录（/usr/bin/）下的Python环境，在系统Pyt\nhon环境下使用pip安装的Python三方包也都是安装到系统目录下（/usr/local/lib/python3.7/site-packages）。\n\n如果我们所有的Python三方包都安装到系统目录下，就会出现多个项目使用不同Python包版本冲突的问题，比如，有两个Python项目A和B，项目A依赖包：ab\nc，版本为1.0，项目B也依赖包：abc，版本为2.0，若两个项目都在系统环境下安装abc这个依赖包，其中一个的依赖环境就会被覆盖，运行时就会因为依赖问题报错，\n这就是版本冲突。\n\n为了解决版本冲突的问题，前辈们就提出了“Python环境虚拟化”概念，在Linux上Python环境虚拟化方案有很多，比如：Virtualenv、Venv、Ca\nnda等，这些环境虚拟化方案（工具）逻辑上都是在某个目录下创建一个全新的Python环境，所有的三方包安装、卸载等操作都在此目录下进行，以此来达到于其他Pyth\non环境隔离的目的。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n以Virtualenv举例，Virtualenv是Python非常常用的环境虚拟化方案，它在初始化时会创建一个全新的虚拟环境的时候，会将Python的解释器以及\npip都同时创建好，后续用户可以使用虚拟环境里面的pip工具，对虚拟环境里面包进行管理（安装、卸载、升级等），这样就能实现虚拟环境里面的Python环境与外界P\nython环境完全隔离（包括系统本身的Python环境以及其他Python虚拟环境），从而解决了多个项目使用Python包版本冲突的问题。\n\n1.1.2、现有技术的缺点#\n\n在Python世界里，大部分的三方包发布都是通过PyPI来发布的，包格式为：whl和tar.gz，因此使用者下载三方包采用pip安装，根据前面的描述可知，这部分\n包是可以直接使用常规Python虚拟化方案进行管理的；\n\n而还有一部分三方包发布的包格式为：deb包（Debian系）、rpm包（Centos系）（下面就统一用deb包来描述），这类主要存在于Linux系统中，其对应包\n管理器是apt、yum，这些Python的deb包使用apt或yum安装后只能安装到系统环境中，无法安装到Python的虚拟环境中。\n\n也就是说，同样是Python三方包，使用来自PyPI的Python包能使用Virtualenv等工具进行虚拟化进行管理（安装、卸载、升级等），而使用apt或yu\nm安装的Python包不能被虚拟化环境管理。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n在对Linux操作系统自动化测试实践过程中，自动化测试项目所需要的依赖既包含了pip安装的Python三方包（如：Pytest、PyAutoGUI等），也存在a\npt安装的Python三方包（如：python3-pyatspi、python3-opencv等），这些包都是必须的。\n\n如果所有的依赖都安装在操作系统环境中，就会出现多个自动化项目使用Python三方包版本冲突的问题，如果为了解决这个问题采用常规的Python环境虚拟化方案又会出\n现apt安装的Python包无法安装到Python虚拟环境的问题。\n\n因此，我们要解决的技术问题是，如何在Python虚拟环境中，既能对pip安装的Python包进行管理（安装、卸载、升级等），同时也能对apt安装的Python包\n进行管理。从而能让Linux上依赖不同来源三方包的Python项目也能实现虚拟化，彻底解决多个Python项目间版本冲突问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n本技术方案通过对使用apt安装的Python\ndeb包安装过程进行拦截，将deb包安装位置动态加载到Python虚拟环境中，从而实现在Python虚拟环境中安装deb包的功能，卸载时只需要将虚拟环境中的de\nb包删除即可。\n\n\n\n图（1）不同来源Python包的安装流程\n\n2.2.1、创建并激活Python虚拟环境#\n\n基于操作系统中默认的Python环境，在用户指定目录下拷贝生成一个全新的、完全干净的Python环境，此Python环境仅包含Python解释器、Python标\n准库、pip相关模块，不存在任何Python三方包。\n\n创建并激活Python虚拟环境后，记录好此Python虚拟环境的路径，以便后续安装Python deb包时使用。\n\n2.2.2、判断Python包的来源#\n\n根据包的格式进行判断，whl包用于pip安装，deb包用于apt安装；\n\n2.2.3、动态拦截apt安装过程#\n\n若为whl包，直接调用Python默认的包管理器pip进行安装，会自动安装到虚拟环境中，由于是常规操作，这里不做过多解释。\n\n若为deb包，调用动态拦截模块进行安装到虚拟环境中，动态拦截安装的过程具体为：调用apt对deb包进行下载，但不进行安装，因为如果安装必然会安装到操作系统环境中\n，因此下载deb之后，将其进行拆包，得到此三方包的源代码，最后将所有源代码移动到虚拟环境路径中，从而实现了将deb包安装到Python虚拟环境的功能。\n\n\n\n图（2）deb包安装到Python虚拟环境过程\n\n2.2.4、Python包卸载#\n\n在Python虚拟环境中卸载包时，由于所有的三方包都是以源代码的形式存在于虚拟环境中，因此，只需将三方包的源代码删除即可，无需区分包的来源。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了传统Python虚拟化方案（工具）无法管理Python的deb或rpm包的问题，真正意义上实现了对所有Python三方包的虚拟化管理。\n\n（2）让基于Linux系统的Python项目完全实现虚拟化环境部署，彻底解决不同自动化测试项目环境依赖之间的版本冲突问题。\n\n（3）基于虚拟化环境部署，有效提升不同自动化项目环境部署的灵活性和自主性；\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）通过拦截deb包安装过程，将其动态的安装Python虚拟环境中；\n\n（2）提供一种技术方案，使得基于Linux包管理器发布的Python包，也能在Python虚拟环境中进行管理；\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nPython虚拟环境：\n\nhttps://blog.csdn.net/qq\\_45261963/article/details/114324148\n\n使用 apt 进行 Linux 包管理：\n\nhttps://zhuanlan.zhihu.com/p/510604386","routePath":"/技术文档/专利交底书/一种对使用Linux包管理器安装的Python包进行虚拟化的技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、创建并激活Python虚拟环境**","id":"221创建并激活python虚拟环境","depth":4,"charIndex":-1},{"text":"**2.2.2、判断Python包的来源**","id":"222判断python包的来源","depth":4,"charIndex":-1},{"text":"**2.2.3、动态拦截apt安装过程**","id":"223动态拦截apt安装过程","depth":4,"charIndex":-1},{"text":"**2.2.4、Python包卸载**","id":"224python包卸载","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":39,"title":"一种机器分离的应用响应性能自动化测试方案技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                              \n术语       全称                   解释\n埋点       埋点分析                 是一种常用的数据采集方法。\n分帧       视频分帧                 将视频分解为连续静止的图片。\n串口设备     USB串口转USB键鼠协议线       一种将串口数据基于 HID 协议规范打包通过 USB 口上传给计算机的硬件设备\n视频采集设备   Video Capture card   用以将模拟摄像机、录像机、LD视盘机、电视机输出的视频信号等输出的视频数据或者视频和音频的混合数据输入电脑，并转换成电脑\n                              可辨别的数字数据，存储在电脑中，成为可编辑处理的视频数据文件\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n软件响应性能是衡量应用综合性能的重要指标之一。每个应用发布之前，我们需要对其启动速度、页面响应速度做全方位的测试。本专利主要通过机器分离的方法，通过USB串口设\n备发送键鼠指令，模拟真实的鼠标键盘操作，并通过视频采集设备完成测试机录屏；在测试机不运行脚本，真实还原用户使用场景的情况下，对应用启动响应速度、界面切换响应速度\n、文件拷贝速度、文件保存速度等指标进行自动化测试。\n\n实际生产环境中，为了获得更加准确的数据，我们常使用外部设备录制操作过程，然后将录制的视频进行分帧处理，然后手动寻找首帧和尾帧，再计算整个过程的耗时。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n日常生产环境中，我们采用录屏分帧的测试方法。以应用启动为例：在电脑开机后，等待系统资源加载完成，然后使用外部设备（如手机）对准屏幕录制视频；录制开始后，我们需要\n使用鼠标键盘执行一次应用启动的过程，待应用加载完成后结束录制；视频录制完成后，再对保存的视频进行分帧操作，然后人工查找应用启动的第一帧和最后一帧，根据帧数差值，\n计算应用启动耗时。整个过程如下图 (一) 所示：\n\n\n\n图（一） 常规测试方法\n\n1.1.2、现有技术的缺点#\n\n（1）外部设备拍摄的视频不稳定。因为拍摄人员、拍摄角度、拍摄手法、视频清晰度都会不同。同时外界光线等因素的干扰，也会对视频质量产生严重影响，最终影响结果的准确性\n。\n\n（2） 视频录制、视频分帧、首尾帧查找等需要大量的人力成本，整个过程费时费力。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n在程序中增加埋点，通过埋点触发的时间差来计算时长。这个方法也就是在应用的代码上增加一个埋点，代码运行到埋点处打一个时间戳，再运行到下一个埋点处又打一个时间戳，这\n两个时间戳的差值，就是时间差值，整个流程如图（二）所示：\n\n\n\n图（二） 数据埋点\n\n1.2.2、现有技术二的缺点#\n\n（1）\n需要在代码中提前做好埋点，然后才能进行测试；而在代码中增加很多个埋点，对性能肯定是有影响的。其次上线后，不能保留埋点代码，所以导致测试版本和用户使用版本不一致。\n\n（2） 此方案是站在计算机的角度去测试时长，并没有站在用户使用眼睛感受的角度。根据实际经验来看，此方案测试结果与实际结果误差也超过了100ms。****\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）在测试机上直接执行性能测试用例脚本，脚本本身需要占用系统资源，对性能测试造成影响。\n\n（2）解决其他测试方案中人力投入大、耗时耗力、测试结果不准确的问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n通过串口设备，在服务端模拟鼠标键盘操作，通过USB接口发送给测试机，使测试机执行响应的指令；另外，通过视频采集设备，将测试机的视频信号输入到服务端，由服务端录制\n整个操作过程，并完成视频解析；最后通过机器学习，自动查找首尾帧并计算结果，将结果汇总并呈现出来。\n\n\n\n图（三） 自动化测试流程图\n\n2.2.1、设备连接#\n\n（1） 将USB串口设备主控端连接于服务器USB接口，被控端连接于测试机USB接口。\n\n（2）\n从测试机显卡接口或主板接口（含有集成显卡的主机）连接视频线，将视频线连接到视频采集设备上，再将视频采集设备连接于服务端。由此服务端可以获取到测试机的桌面视频信号\n。\n\n2.2.2、测试执行#\n\n以应用启动指标为例，我们需要执行以下过程：\n\n（1） 服务端执行代码，将生成的鼠标移动指令集、键盘输入指令集通过串口设备发送给测试机。\n\n（2） 测试机从USB接口获取到指令集。\n\n（3） 服务端获取测试机桌面视频信号，开启录屏。\n\n（4） 测试机执行接受到的鼠标键盘操作，在菜单栏点击应用图标，执行启动过程。\n\n（5） 服务端停止录屏，生成记录整个操作过程的视频。\n\n（6） 重复测试过程，录制多个视频。\n\n2.2.3、视频解析与数据计算#\n\n通过视频解析工具，将录制的视频分解为连续的图片。并通过计算前后图片的相似度，将所有图片划分为多个稳定阶段（静止画面）和不稳定阶段（连续变化过程），如图（四）所示\n：\n\n\n\n图（四） 视频解析与阶段分类\n\n以应用启动指标为例，启动过程包含鼠标右键点击应用图标-鼠标点击打开按钮-等待应用加载完成。在视频解析和阶段划分完成后，从鼠标点击到应用打开，会处于两个不稳定阶段\n——即上图的unstable，利用这样的规律，我们可以自动获取到启动过程的首帧和尾帧，然后通过计算首尾帧之前的图片帧数来计算耗时。例如：首帧和尾帧之前有10张图\n片，由于视频分解的帧率为33帧/秒，即每一帧图片的耗时为1000/33毫秒（ms），因此启动耗时为10 x 33 = 330(ms)。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了测试应用响应性能过程中需要投入大量人力、时间的问题。\n\n（2）所有脚本均在服务端执行，测试机仅通过USB串口设备控制，排除对于测试机性能的干扰，确保性能测试数据稳定可靠。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）本技术方案可应用于所有架构；通过机器分离的方式，排除对于测试机性能的干扰项，完成全流程自动化测试。\n\n（2）采用机器学习的技术方案，智能识别应用响应性能数据，解放人力物力。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl Stagesepx视频解析工具：\n\nhttps://github.com/williamfzc/stagesepx\n\nl USB键盘鼠标协议：\n\nhttps://download.csdn.net/download/qq\\_33779211/9408498\n\nl USB串口设备开发文档：\n\nhttps://blog.csdn.net/longor1991/article/details/81095896","routePath":"/技术文档/专利交底书/一种机器分离的应用响应性能自动化测试方案技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**1.2、与本发明相关的现有技术二**","id":"12与本发明相关的现有技术二","depth":3,"charIndex":-1},{"text":"**1.2.1、现有技术二的技术方案**","id":"121现有技术二的技术方案","depth":4,"charIndex":-1},{"text":"**1.2.2、现有技术二的缺点**","id":"122现有技术二的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、设备连接**","id":"221设备连接","depth":4,"charIndex":-1},{"text":"**2.2.2、测试执行**","id":"222测试执行","depth":4,"charIndex":-1},{"text":"**2.2.3、视频解析与数据计算**","id":"223视频解析与数据计算","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"张龙、mikigo、李涛"},"version":""},{"id":40,"title":"4.参考文献（如专利/论文/标准等）","content":"一种系统文件基于事物属性对其进行多维度多空间管理方法的交底书#\n\n\n0. 缩略语和关键术语定义#\n\n--------------------------------------------------------------------------------\n\n名词 全称 描述 事物 / 针对某一类有目的、有计划的事件。 抽屉 / 本文中只一种前端设计，一种页面展开收起的特性。\n\n--------------------------------------------------------------------------------\n\n\n1. 相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n\n1.1 背景技术#\n\n使用操作系统进行日常办公，过程中不可避免会产生各种各样的目录、文件。它们可能分别对应不同工作事物，或急或缓，甚至只是一次性的临时文件。随着时间的流失，再想找到某\n一个事物相关的某个文件时，可能会大费周章。\n\n甚至随手新建文件进行内容编辑后关闭，等待几小时后自己都无法定位文件位置，如果能记得文件名还能借助搜索工具确认文件位置；若不记得是否会像解密一样，不停地遍历我们常\n用的、不常用的路径，进行肉眼式搜索。\n\n\n\n图1 杂乱的文件堆放\n\n也存在部分收纳天赋的用户，会分类创建目录进行一些文件分类收纳，短时间内效果不错，但当这些目录、子目录堆积的越来越多时，你会发现如果要定位一个文件，也是层层筛选、\n层层递进。而且在工作中文件可能分散在电脑各处，例如桌面、下载目录、截图目录、企业微信自动保存目录等，不可能每次都会记得把这些文件收纳整理起来。\n\n甚至当文件累计的足够多时，我们想清理部分文件，还得担心是否是后续还会用上的文件，若打开文件通过内容确认，海量的文件足以让人崩溃。\n\n\n1.2 与本发明相关的现有技术#\n\n\n1.2.1 现有技术的技术方案#\n\n针对1.1章节中中描述的背景问题，在文件自动整理方面，存在一些现有技术，可以对文件进行自动排序，支持在桌面创建类似目录的盒子，对用户提供归纳入口，可将同类型的文\n件收纳在一起，但都是针对系统桌面文件。\n\n> 此类软件代表作：腾讯桌面管家，360桌面助手等。当然它们还存在很多其他功能，例如添加桌面标签等，但与本专利无关，就不再做介绍。\n\n\n\n> 图2腾讯桌面整理效果\n\n\n1.2.2 现有技术的缺陷#\n\n现有技术中能解决1.1章节描述问题：\n\n * 可解决文件有序归纳的问题，但仅支持在桌面范围内手动对文件进行归纳管理（创建盒子放入文件），无法在系统其他位置应用。\n\n * 可通过归纳功能对文件进行分类管理，同上条缺陷局限在桌面范围内，同时随着时间的推移有限的桌面空间总会有不够用的时候。\n\n * 提供的清理功能，仅针对一些系统临时文件，针对正常文件无法做到自动清除，还是需要人工确认才能判断该文件是否还需要。\n\n * 针对历史文件由于时间关系，已经遗忘名称、位置等，在后续需要使用时，查找定位文件十分困难。\n\n\n2. 本发明技术方案的详细阐述#\n\n\n2.1 本发明所要解决的技术问题#\n\n本发明所要解决的问题为：\n\n * 打破传统方案中桌面限制，可在系统任意位置进行文件管理，唯一的上限是磁盘剩余空间。\n\n * 基于第一点文件分散的情况，可以一键归纳所有文件，对文件进行集中管控避免遗失，例如一键把下载目录A文件、企业微信接受文件目录B文件、桌面C文件一键集中至提前\n   设定的统一目录中。\n\n * 基于第一点针对系统不同位置的文件，可打破空间局限，不用频繁切换目录也能同时访问、管理多个位置的文件。\n\n * 针对文件清理可快速判断文件属性进行自动清理，在对面堆积的大量文件时，无需人为进行繁重的确认工作，并且可以根据需求添加多个自动清理的路径与规则。\n\n * 基于现有技术的人工归档，现可自动对重要文件进行归档管理，同时赋予文件新的事物属性，在后期基于某件事物查找对应文件时，可实现快速定位。\n\n * 除了以上解决的问题外，还产生了一些额外的有益效果：\n\n * 归档文件时会基于事物属性生成报告，包含该文件与事物的生命周期、具体事项等信息，有助于后期回溯问题。\n\n * 文件生命周期内基于事物属性可进行有效的事物跟进，反应对应事物的计划、完成率等，并在配置的时间节点进行提醒。\n\n * 根据配置在文件生命周期结束时自动对其进行进一步处理：归档、清理。\n\n\n2.2 本发明提供的完整技术方案（交底书的核心部分）#\n\n本发明的技术方案，核心是基于文件定义的事物属性，通过文件与事物进行关联，对文件文件与事物完成多维度的管理，所以在本文中涉及事物的篇幅也较多，方案针对文件和事物设\n计全新的联系与交互逻辑达到2.1章节描述的效果。\n\n支持方案运行的核心功能组件包含：\n\n * 事物管理抽屉：\n   \n   * 本发明方案主要功能页面，用于事物的展示、管理、配置等，同时承担文件与事物生命周期管理与跟踪，位于屏幕右侧，通过右下角任务栏icon或快捷键呼出（如图3\n     ）\n\n * 规则配置菜单：\n   \n   * 通过该配置菜单的配置项的值进行方案运行逻辑的管控，点击抽屉页面-设置按钮呼出\n     \n     其他功能与逻辑再后续，联合核心功能做整体性补充说明。\n\n{width=\"5.759722222222222in\" height=\"6.723611111111111in\"}\n\n> 图3 入口与抽屉展示\n\n\n2.2.1 规则配置菜单#\n\n配置菜单的配置项管理着整个事物管理系统的运行逻辑，根据不同的条件、场景，可灵活的做不同配置，下面将分段展示配置菜单。\n\n2.2.1.1 工作目录配置#\n\n\n\n> 图4 工作目录配置\n\n该目录配置主要针对两方面：\n\n * 工作家目录：\n   \n   * 图片展示为该方案默认值，路径为使用频率最高的桌面目录，可点击更改按钮进行修改。\n   \n   * 整套方案系统的家目录，在创建事物时会在该处新建1个对应目录进行关联管理。\n\n * 归档目录：\n   \n   * 图片展示为该方案默认值，可点击更改按钮进行修改。\n\n * 事物状态完成后，可扭转状态为归档，此时所有关联文件自动移动至事物目录，并将事物目录转移至该目录完成归档管理。\n\n2.2.1.2 事物排序权重#\n\n用于控制事物管理抽屉中事物排序，从左往右代表着优先级从高到低，拖动按钮可调整排序，默认排序优先级为：等级 > 时间余量 > 进度 （如图5）。\n\n\n\n> 图5 事物排序权重\n\n其中详情如下：\n\n * 等级：预设4个等级，对应优先级A > B > C > D\n\n * 时间余量：数值越小，优先级越高\n\n * 进度：百分比越大，优先级越高\n\n * 例如以下优先级关系：\n\n * 任务1（等级A、时间余量1天、进度10%） >\n   \n   > 任务2（等级A、时间余量4小时、进度90%）\n\n * 任务3（等级A、时间余量1天、进度10%） <\n   \n   > 任务4（等级A、时间余量1天、进度90%）\n\n2.2.1.3 工作时间设定#\n\n主要作用是计算时间，运用与时间余量指标与提醒功能，必填项。默认值如图：\n\n * 上午/下午项点击可修改，第二个值必须大于第一个值。\n\n * 合计项为自动计算展示，不可修改。\n   \n   \n\n> 图6 工作时间设定\n\n2.2.1.4 事物状态扭转规则#\n\n主要控制事物的完成条件与状态扭转（如图7），补充说明以下事物状态，一共存在5种状态：\n\n * 进行中：未完成事物\n\n * 完成：根据条件触发，参考下方配置4触发。\n\n * 延期：触发完成节点后事物并未实际完成，可扭转为该状态，同时需要重新设定截至时间。\n\n * 归档：事物完成后可扭转的状态，扭转后事物关联文件按照配置2路径进行归档。\n\n * 清理：事物完成后可扭转的状态，扭转后事物按照后续介绍的清理规则进行清理。\n   \n   \n\n> 图7 事物状态扭转规则\n\n该配置项具体说明为：\n\n * 事物完成条件（多选）\n   \n   * 时间余量为0：默认勾选项，不可取消，效果为抵达事物截至时间时触发。\n   \n   * 事物具体事项全部完成：可选项，若勾选后事物对应的具体事项（创建任务时可设置具体事项）均完成也可触发，哪怕时间余量不为0。\n\n * 事物状态扭转（单选）\n   \n   * 手动扭转：事物状态变为完成后，需要在事物抽屉手动扭转下一步状态。\n   \n   * 自动扭转：事物状态变为完成后，自动按照配置扭转下一步状态。默认值为归档，可切换为清理（按照清理规则配置项执行）。\n\n2.2.1.5 清理规则#\n\n该配置主要控制两类清理动作：\n\n * 事物清理：针对事物状态扭转为清理后响应的操作。\n\n * 文件清理：针对未关联事物的临时文件，在触发自动清理节点时的操作。\n   \n   详细配置如下：\n   \n   \n\n> 图8 清理规则\n\n * 事物清理（单选）\n   \n   * 事物状态扭转为清理后：\n     \n     * 直接删除（默认选项）：直接对文件进行清理，执行后无法找回文件。\n     \n     * 延迟删除：移动文件至暂存目录，等待设定时间（天）完成后删除，在正式删除前可随时找回文件。\n\n * 文件清理（单选）\n   \n   * 说明：桌面目录做了特殊处理，忽略2种类型文件：应用图标、带链接文件（快捷方式）\n   \n   * 配置6（自动清理开关）\n     \n     * 关：不进行自动清理\n     \n     * 开：进行自动清理，打开开关后才展示下方具体配置项：\n       \n       * 清理频率：运行自动清理间隔，以天为单位，默认值为3天，可编辑修改。\n       \n       * 清理方式：\n         \n         * 直接删除：直接对文件进行清理，执行后无法找回文件。\n         \n         * 延迟删除（默认选项）：移动文件至暂存目录，等待设定时间（天）完成后删除，在正式删除前可随时找回文件。\n       \n       * 清理目录：\n         \n         * 自动清理只对增加的目录生效，默认为最容易产生无用文件堆积的桌面目录与下载目录。\n         \n         * 点击最后一行末尾新增按钮，可对生效目录进行扩展。\n       \n       * 清理白名单目录\n         \n         * 默认为空，点击末尾新增按钮，可对忽略目录进行扩展。\n       \n       * 清理白名单文件后缀\n         \n         * 默认为空，点击末尾新增按钮，可对忽略文件类型进行扩展。\n\n2.2.1.6 提醒规则#\n\n主要对提醒的节点和方式进行配置（如图9）：\n\n> 图9 提醒规则\n\n详细说明如下：\n\n * 提醒节点（多选）\n   \n   * 选项1：在事物时间余量为0时提醒，该选项为默认必选项，不可取消勾选。\n   \n   * 选项2：增加以天（D）为维度的额外提醒，点击输入框可编辑，勾选后生效。\n   \n   * 选项3：增加以小时（H）为维度的额外提醒，点击输入框可编辑，勾选后生效。\n\n * 提醒方式（单选）\n   \n   * 选项1：触发提醒节点时，自动弹出抽屉，并闪烁对应事物。\n   \n   * 选项2：触发提醒节点时，屏幕顶部出现弹框提醒，并且后续展开抽屉，闪烁对应事物。\n   \n   * 选项3：不做任何主动提醒动作，仅在展开抽屉时，闪烁对应事物。\n     \n     Ps. 如截图中备注，闪烁事物动作仅曝光一次后即失效。\n\n2.2.1.7 快捷键规则#\n\n本配置主要定义抽屉展示的快捷键（如图10）：\n\n * 抽屉收起时点击，展开抽屉。\n\n * 抽屉展开时点击，收起抽屉。\n   \n   \n   \n   > 图10 抽屉快捷键\n\n\n2.2.2 事物管理抽屉#\n\n本发明方案主要功能页面，用于事物的展示、管理、配置等，同时承担事物生命周期管理与跟踪，位于屏幕右侧，通过右下角任务栏icon（如图3）或快捷键呼出（如图10）。\n\n2.2.2.1 新建事物#\n\n\n\n> 图11 新建事物入口\n\n该功能用于创建事物，主要功能入口为抽屉左上角\" + \"按钮，创建事物时会自动弹框对事物特定管理规则进行设置，如新建事物名称为\"Test\"的事物（图11）：\n\n> 图11 新建事物配置项\n\n详细说明：\n\n * 事物名称（必填）：用于标识事物，会在抽屉和关联文件展示。\n\n * 事物管理（开关）：\n   \n   * 关闭状态\n     \n     * 无事物配置项，对应仅需要集中管理的常用公共文件，不需要对其生命周期进行管理。\n   \n   * 开启状态\n     \n     * 事物等级（必填）：用于标识事物的紧急程度，等级A优先级最高。\n     \n     * 事物周期（必填）：计划开始时间到结束时间，精确到时、分，第二个值必须大于第一个值，用于管理事物的生命周期于提醒。\n     \n     * 事物详情（必填）：用于管理事物的具体事项，用于管控事物在抽屉中的进度展示于事项报告生成做支撑，并辅助事物完成条件进行判断。\n       \n       * 占比：预计投入的工作量百分比，用于抽屉中进度展示，可缺失。\n\n * 所有事项都缺失时，按照百分比平均分配。\n\n * 仅填写某一项，其他未填写的按照剩余百分比平均分配。\n\n * 当填写百分比合计数值超过100%时报错。\n   \n   * 事项：该事物具体需要完成的工作项目。\n\n * + 新增事项：点击可添加一行事项\n\n * x ：点击可删除已填写事项\n\n2.2.2.2 事物面板#\n\n\n\n> 图12 事物面板\n\n事物面板主要用于展示：\n\n * 无状态事物\n\n * 状态为进行中、延期、完成的事物\n   \n   无状态事物永远展示在顶部，但最多对外展示2例，超过则收起。通过点击\"展开更多\"按钮呼出。下方则展示有状态的事物，结合2.2.1.2规则与2.2.2.1配置\n   项进行排序，接下来基于带状态的事物，讲解面板每一列的意义。\n\n2.2.2.2.1 等级#\n\n同2.2.2.1配置中描述，面板上点击可进行编辑修改，修改后触发重新排序。\n\n2.2.2.2.2 时间余量#\n\n该数值是自动计算得出并展示，点击不可修改，当延期任务结束时间时会自动重新计算并更新展示数值。\n\n不同单位的最小颗粒度为：\n\n * D（天）：1D\n\n * H（小时）：0.5H\n\n * M（分钟）：1M\n\n不同维度的展示，数据处理不同，例如：\n\n * D（天）维度：仅保留天，如 1D 5H 截断为 1D\n\n * H（小时）维度：\n   \n   * 若 M大于等于30 则转换为 0.5H ，如 10H 30M 转换为 10.5H\n   \n   * 若 M小于30 则截断 ，如 10H 20M 截断为 10H\n\n * M（分钟）维度：不做处理，如 30M 则展示 30M\n\n根据时间余量变化展示不同数值单位与颜色：\n\n * 大于等于2天，颜色-绿，单位D（天）： **3 D **\n\n * 小于2天 并且 大于等于1天，颜色-黄，单位D（天）：1 D\n\n * 小于1天 并且 大于等于1小时，颜色-红，单位H（小时）：1.5 H\n\n * 小于1小时，颜色-红，单位M（分钟）：40 M\n\n计算数值主要结合了以下变量：\n\n * 2.2.1.3配置中工作时间设定：\n   \n   * 工作日有效工作时长\n   \n   * 工作日有效工作时间段\n\n * 当前年度工作日统计列表\n\n * 计算流程见2.2.3章节-图25\n\n2.2.2.2.3 状态#\n\n * 仅展示进行中、延期、完成状态的任务\n * 针对状态为完成的事物，若2.2.1.4配置中\"事物状态扭转\"为手工扭转，在面板中展示更新按钮，点击后进行下一阶段操作选择（归档、清理）。\n\n2.2.2.2.4 进度#\n\n * 点击进度：展示2.2.2.1中所有事项，并可对每个事项的进度进行修改标记，下拉框选择，最小颗粒为5%（如图13）。\n\n\n\n> 图13 事项弹框\n\n * 通过多维计算得出结果，依赖于2.2.2.1中事项占比与当前标记的事项进度。\n   \n   * 计算公式：\n\n\n\n * 例如图13在标记事项1当前进度100%，事项2当前进度80%的场景下，使用公式计算得出当前进度为：\n\n\n\n * 点击确认按钮后弹框消失，事物\"专利文档编写\"进度更新为96%\n\n * 当2.2.1.4配置中勾选了\"事物具体事项全部完成\"，我们手动把所有事项进度设置为100%后，任务自动按照2.2.1.4中\"事物状态扭转\"配置进行。\n\n2.2.2.2.5 事物名称#\n\n * 同2.2.2.1配置\n\n * 点击效果与\"进度\"一致\n\n2.2.2.2.6 文件夹按钮#\n\n事物目录的入口，随同事物创建时建立，主要用于对存在该事物属性的文件（文件已关联该事物）进行管理。\n\n * 点击唤起事物目录，在2.2.1.1配置家目录下（如图14），该功能实现了跨空间访问、管理、整合文件。\n   \n   \n\n> 图14 事物目录\n\n * 通过图14可看出事物目录初始为空，文件与事物关联后会展示在该弹框中，关联事物的方式主要为：\n   \n   * 移动/复制/创建文件在事物家目录下。\n   \n   * 右键点击文件，在属性中\"关联事物\"项点击下拉框选择事物进行管理，下拉框仅展示状态非归档和清理的事物（如图15）。\n     \n     \n     \n     > 图15 关联事物\n   \n   * 关联成功后该文件展示在事物目录内，因是关联的事物家目录路径外的文件，所以在弹框中会额外展示（如图16）：\n     \n     \n     \n     > 图16 关联后展示\n   \n   * 在弹框内可对文件进行任意操作，点击\"归档\"按钮会一键把该路径下关联文件移动至事物家目录中。若文件正在使用无法进行归档，并给出提示：请保存文件并关闭后重\n     试。\n   \n   * 可关联类型包含文件与目录，若目录中存在文件正在使用，在进行归档时效果与上方描述一致。\n\n2.2.2.3 功能面板#\n\n\n\n> 图17 功能面板\n\n该功能主要展示常用功能入口（如图17），其中\"设置\"功能为2.2.1章节下内容，本章节主要针对其他功能进行说明。\n\n2.2.2.3.1 生成报告#\n\n报告功能是基于事物信息汇总成文字报告的功能，主要针对有状态的事物（见2.2.2.2介绍）。一共有两种报告机制，此处的\"生成报告\"按钮触发的是其中手动生成机制，这\n里对两种机制做说明：\n\n * 手动生成\n   \n   * 点击功能面板\"生成报告\"触发弹框，弹框用于做数据收集规则确认（如图18），选择规则后，点击确认按钮生成对应报告并保存（弹框选择报告保存路径）。\n\n\n\n> 图18 生成报告\n\n * 图18中涉及了4种生成规则，这里做简单说明：\n   \n   \n\n\n\n> 图19 特定事物报告生成\n\n * 自动生成\n   \n   * 该机制在任务完成后，扭转为归档状态时在事物目录自动生成，随同目录一起归档，用于后续的事物情况回溯。\n\n * 报告文件\n   \n   * 文件格式为 txt 文本格式。\n   \n   * 文件命名统一为：时间戳+事物报告.txt\n   \n   * 文件内容展示以报告生成规则选项4为例，生成测试事物、专利文档编写两个事物的报告，展示如图20：\n     \n     {width=\"5.763888888888889in\" height=\"4.688888888888889in\"}\n     \n     图20 报告内容展示\n\n2.2.2.3.2 手动清理#\n\n该功能同2.2.2.3.1章节类似，同样是清理功能的2种机制之一（自动清理、手动清理），两种机制的运行结果一致，都是针对2.2.1.5文件清理配置进行清理动作，\n唯一的区别是触发清理动作的时机节点不同。\n\n * 手动清理\n   \n   * 点击功能面板\"手动清理\"则立即触发。\n\n * 自动清理\n   \n   * 基于2.2.1.5配置中设置的时间，到点自动触发。\n     \n     \n     \n     > 图21 截取于2.2.1.5文件清理部分配置\n     \n     清理机制主要针对清理目录下未关联事物的文件，若清理目录为空则自动关闭\"自动清理开关\"，删除方式默认为延迟3天删除，延迟天数可点击输入框修改。\n     \n     已关联事物的文件会被锁定，无论是手动清理、自动清理功能都会忽略。但用户可以使用系统提供的删除功能或命令进行删除，删除后自动解除事物关联。\n     \n     当然可能同样存在一些与事物无关的目录或文件，存放在清理目录中，避免它们被删除的操作方式有很多，例如：\n\n * 存放目录或文件在清理目录之外，并发送链接至清理目录内，带链接的目录在清理时会被过滤掉。\n\n * 存在目录或文件在清理目录之内，添加至清理白名单，添加白名单有两种方式：\n   \n   * 方式1：通过 图21 中白名单配置项新增按钮添加。\n   \n   * 方式2：右键点击需要添加的文件或目录，通过右键菜单快捷添加（如图22）。\n     \n     * 右键文件：可添加该文件 或 该文件后缀。\n     \n     * 右键目录：可添加该目录。\n\n\n\n> 图22 添加清理白名单\n\n2.2.2.3.3 归档目录#\n\n该功能主要是呼出归档事物的目录，用于查看已归档事物的详细信息，目录路径对应2.2.1.1配置中归档目录路径。\n\n2.2.2.3.4 删除目录#\n\n该功能主要是呼出删除事物的目录，用于查看延迟删除事物的详细信息，目录路径对应2.2.1.5中清理方式配置中暂存目录路径。\n\n\n2.2.3 部分流程展示#\n\n结合2.2.1与2.2.2的功能说明，本章节内容主要基于以上功能展示部分流程：\n\n * 事物生命周期流程展示\n\n\n\n> 图23 事物生命周期流程\n\n * 文件自动清理流程展示\n\n\n\n> 图24 自动清理流程\n\n * 时间余量计算流程\n\n\n\n> 图25 时间余量计算流程\n\n\n2.3 本发明技术方案带来的有益效果#\n\n基于文件事物属性，借助2.2提供的完整技术方案实现了以下有益效果：\n\n * 不再像传统方案一样只能基于桌面进行管理，因为桌面为用户使用率最高的页面。本方案可基于桌面也可以基于系统任何位置进行文件管理，也能有较好的页面用户体验，打破\n   局限性。\n\n * 通过事物抽屉能够在任何场景与页面下唤起，使用与跟进文件更加方便快捷，不会中断当前页面的工作。\n\n * 针对文件分散的情况，不易管理的问题，可以通过文件的事物属性，一键归纳所有相关文件，对其进行集中管控避免遗失，例如一键把下载目录A文件、企业微信接受文件目录\n   B文件、桌面C文件一键集中至提前设定的统一目录中。\n\n * 针对需要频繁切换目录访问不同位置文件的繁琐操作，通过事物属性可打破空间局限，利用事物面板一键呼出事物目录，即可同时访问和操作多个位置的文件。\n\n * 针对文件生命周期结束后管理不当导致的后续各种衍生问题，现可自动对不同事物属性的文件进行归档管理，在不同时间段基于某件事物查找对应文件时，可实现快速定位。\n\n * 基于上述文件生命周期结束提到的自动归档功能，会基于事物属性生成报告，包含该文件与事物的生命周期、具体事项等信息，有助于后期回溯问题。\n\n * 在对面堆积的大量普通文件时，无需人为进行繁重的确认工作，基于事物属性则可以快速完成清理，且可以根据需求添加多个自动清理的路径与规则。\n\n * 通过事物属性基于事物管理逻辑，能对文件生命周期进行有效事物跟进，反应对应事物的计划、完成率等信息，并且通过配置还能：\n\n * 通过报告完成当前事物情况汇总、反馈。\n\n * 重要节点按照配置提醒方式进行提醒。\n   \n   同时丰富的配置与交互方式可以满足不同人群对文件管理的需求，打破一成不变的模式。\n\n\n2.4 针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n暂无\n\n\n3. 本发明的技术关键点和欲保护点#\n\n本发明的技术关键点和欲保护点是 章节2.2 章节所描述的一整套可运用于操作系统的文件与事物的全新设计方案，达到2.3章节提到的有益效果，大致包含：\n\n * 主流程\n   \n   * 支撑整套方案运行的配置设计。\n   \n   * 基于配置使整套方案运转的整套逻辑设计。\n   \n   * 整套方案的功能页面展示逻辑。\n\n * 子流程\n   \n   * 基于文件与事物关联关系的逻辑设计。\n   \n   * 控制文件与事物整个生命周期的管理逻辑设计。\n   \n   * 控制事物文件（存在事物属性的文件）与系统的交互逻辑设计。\n   \n   * 基于配置自动清理文件的逻辑设计。\n\n\n4.参考文献（如专利/论文/标准等）#\n\n暂无","routePath":"/技术文档/专利交底书/一种系统文件基于事物属性对其进行多维度多空间管理方法的交底书","lang":"","toc":[{"text":"0.  缩略语和关键术语定义","id":"0--缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"1. 相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1-相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":275},{"text":"1.1 背景技术","id":"11-背景技术","depth":2,"charIndex":316},{"text":"1.2 与本发明相关的现有技术","id":"12-与本发明相关的现有技术","depth":2,"charIndex":767},{"text":"1.2.1 现有技术的技术方案","id":"121-现有技术的技术方案","depth":3,"charIndex":786},{"text":"1.2.2 现有技术的缺陷","id":"122-现有技术的缺陷","depth":3,"charIndex":990},{"text":"2.1 本发明所要解决的技术问题","id":"21-本发明所要解决的技术问题","depth":2,"charIndex":1280},{"text":"2.2 本发明提供的完整技术方案（交底书的核心部分）","id":"22-本发明提供的完整技术方案交底书的核心部分","depth":2,"charIndex":1835},{"text":"**2.2.1 规则配置菜单**","id":"221-规则配置菜单","depth":3,"charIndex":-1},{"text":"**2.2.1.1 工作目录配置**","id":"2211-工作目录配置","depth":4,"charIndex":-1},{"text":"**2.2.1.2 事物排序权重**","id":"2212-事物排序权重","depth":4,"charIndex":-1},{"text":"**2.2.1.3 工作时间设定**","id":"2213-工作时间设定","depth":4,"charIndex":-1},{"text":"**2.2.1.4 事物状态扭转规则**","id":"2214-事物状态扭转规则","depth":4,"charIndex":-1},{"text":"**2.2.1.5 清理规则**","id":"2215-清理规则","depth":4,"charIndex":-1},{"text":"**2.2.1.6 提醒规则**","id":"2216-提醒规则","depth":4,"charIndex":-1},{"text":"**2.2.1.7 快捷键规则**","id":"2217-快捷键规则","depth":4,"charIndex":-1},{"text":"**2.2.2 事物管理抽屉**","id":"222-事物管理抽屉","depth":3,"charIndex":-1},{"text":"**2.2.2.1 新建事物**","id":"2221-新建事物","depth":4,"charIndex":-1},{"text":"**2.2.2.2 事物面板**","id":"2222-事物面板","depth":4,"charIndex":-1},{"text":"**2.2.2.3 功能面板**","id":"2223-功能面板","depth":4,"charIndex":-1},{"text":"**2.2.3 部分流程展示**","id":"223-部分流程展示","depth":3,"charIndex":-1},{"text":"2.3 本发明技术方案带来的有益效果","id":"23-本发明技术方案带来的有益效果","depth":2,"charIndex":9185},{"text":"2.4 针对上述技术方案，是否还有替代方案同样能完成发明目的","id":"24-针对上述技术方案是否还有替代方案同样能完成发明目的","depth":2,"charIndex":9947}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":41,"title":"一种自动化测试用例步骤中断后恢复执行的技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n术语        全称        解释\n自动化测试程序   自动化测试程序   自动化测试程序通常指的是使用Python、Shell、Java等语言编写的自动化测试代码，以实现自动执行测试用例的目的。\n类         类         基于多个同类实体的抽取的概念，在面向对象的编程设计里面，类具有方法和属性，在自动化测试用例编写是用来将一类用例组织起来，\n                    称为用例类。\n函数        函数        是一段具有一定功能的代码段。\n断言        断言        判断用例是否符合预期。\n串口线       串口线       通过串行接口传输数据的线材。\n视频采集盒     视频采集盒     坊间也称视频采集卡，它可以将客户端的视频画面转发到服务端。在视频直播领域用得很多，比如将摄像机、手机等输出的视频信号采集\n                    并输入到电脑（直播的电脑），并实时转换成电脑可识别的数字数据、可编辑处理的视频数据文件、或可实时观看的视频流。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在基于操作系统的UI自动化业务逻辑自动化用例执行过程中，每执行一次自动化测试程序我们称为一次测试会话（以下简称session或会话），在每次会话中涉及一条或多条\n用例的执行，而每条用例又涉及多个操作步骤的执行，在整个自动化测试过程中，自动化程序是不能中断的，程序中断后，中断时正在执行的用例步骤会停止，后续的用例也不会执行\n。如果自动化测试程序中断后，手动的重新把自动化测试程序启起来，自动化用例又会从头开始执行。\n\n然而，有一些自动化用例涉及与电脑重启的场景交互，也就是某条用例开始执行了一部分用例步骤，在中间某个步骤执行时需要重启电脑，电脑重新启动之后，我们就是需要自动化用\n例步骤紧接着重启时那个步骤继续开始执行，根据前面讲到的原因，我们需要一种有效的技术方案来解决这个问题。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n现有的技术方案中，采用机器分离的方式进行自动化测试，能实现用例步骤在重启测试设备时中断等待后继续执行。测试时准备2台机器，1台作为服务器，1台作为测试机，服务器\n与测试机通过串口线和视频采集盒连接，串口线用于服务器控制测试机进行键鼠操作，视频采集盒用于将测试机上的实时画面转发到服务器上，自动化测试程序在服务器上执行，通过\n识别采集盒转发过来的画面，再通过串口线控制测试机进行用例步骤的执行。\n\n在此过程中，若测试机重启，由于自动化测试程序是在服务器上执行，程序不会中断，只需要等待测试机重新启动之后，继续执行后续步骤即可。\n\n1.1.2、现有技术的缺点#\n\n上述现有技术方案，核心逻辑是通过将自动化测试程序从测试机上面分离出来，放到服务器上执行，从而解决了重启机器程序中断的问题，缺点如下：\n\n（1）环境部署困难，从需要的设备上就能看出来，比起在单台测试机上执行，多出了服务器、串口线、视频采集盒，它们之间需要进行连接部署、驱动运行，而这其中串口线的使用\n是具有一定技术门槛的，一旦出现问题非常不容易定位解决，无疑进一步增加了使用的难度。\n\n（2）所需要的设备成本更高，很明显，多出来的好几个设备，特别的服务器，着实是一个不容忽视的成本。\n\n（3）所有实现的用例场景比较单一，由于测试机上的画面是通过视频采集盒转发到服务器上，所有的逻辑判断都重度依赖于图像识别，这种相对单一的元素定位方案，是无法满足复\n杂用例场景需求的，特别是在基于Linux的国产操作系统上，实践证明，我们需要多种元素定位方案混合使用才能确保满足各种自动化测试用例场景，比如：基于Accessi\nbility属性定位，基于UI设计的元素相对坐标定位等等。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n在对操作系统进行自动化测试的过程中，自动化程序遇到不得不中断的场景下，如重启场景，需要实现自动化用例步骤执行过程中重启机器，机器重新启动之后，能再次继续紧接着重\n启前的用例步骤执行的功能。\n\n因此我们需要解决的技术问题是：在单机执行的情况下，如何在用例批量执行的过程中，能让自动化用例中间某个步骤在中断之后，还能延续中断前步骤继续执行的问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n本技术方案通过对自动化测试代码中执行到的函数进行动态添加执行标签，在每次会话过程中，只要执行到的用例步骤都会通过标签的形式记录此函数的执行状态，而标签字符串是通\n过一套组合算法对函数进行标记，从而确保每个函数标签全局唯一性。\n\n以重启场景为例，整体运行逻辑如下：\n\n首先，将自动化测试程序注册到操作系统开机自启服务中，这样只要操作系统开机，自动化测试程序就会自动执行起来。\n\n然后，在一次自动化测试用例执行时，每个用例步骤为一个函数，用例步骤执行时通过标签记录此步骤已经被执行了，记录到执行记录文件里面，如果某个用例步骤涉及重启的操作，\n虽然当前自动化程序会中断，但是执行记录文件里面已经记录了重启之前执行到哪个步骤了。\n\n最后，等重新启动之后，执行判断模块会读取执行记录文件里面的标签信息，如果自动化用例步骤所对应的函数已经存在执行记录文件中，说明这个用例步骤在重启之前已经执行过了\n，则直接跳过执行，继续判断下一个步骤，直到判断到某个用例步骤的标签不存在执行记录文件中，说明此用例步骤就是重启后应该紧接着执行的用例步骤，因此正常执行此用例步骤\n即可。\n\n这里先不考虑用例断言，因为用例断言本质上也是一个用例步骤，只是通常是做一些值的对比判断，所以，为了容易理解，上述的用例步骤执行就已经包含了用例断言的概念。\n\n\n\n图（1）用例步骤中重启中断后恢复执行的流程\n\n2.2.1、注册开机自启服务#\n\n将自动化用例执行程序注册到开机自启服务中，确保用例执行过程中，机器重启后程序能自动的被拉起执行。\n\n2.2.2、执行判断模块#\n\n执行判断模块负责在每个用例步骤执行时，读取执行记录文件，如果该用例步骤所对应的标签已经存在，说明此用例步骤被执行过，则跳过执行，反之，则正常执行。\n\n2.2.3、执行记录文件#\n\n执行记录文件里面记录的是已经执行过的用例步骤标签，标签采用一套组合算法，将用例步骤的函数对象转换为唯一的字符串，即使在同一条用例中多次调用了相同的用例步骤函数，\n其对应的标签字符串也是不同的，确保用例中的每个步骤函数的标签字符串全局唯一性。\n\n2.2.4、用例步骤函数标签字符串编码算法\n\n由于用例步骤函数是可复用的，也就是说即使是在同一条测试用例里面，可能出现多个完全相同的用例步骤函数的调用，因此我们需要有一种算法来确保每个步骤所对应的标签字符串\n的唯一性，而且标签字符串还应该具有可逆性，就是说当执行判断模块读取到某个标签字符串时，通过解码能快速的知道它是否为当前执行的用例步骤函数，这就是可逆性。\n\n用例步骤在执行时，通过以下 5 个关键信息进行编码组合：\n\n（1）用例代码的文件路径；\n\n（2）用例类的类名；\n\n（3）用例函数的函数名；\n\n（4）用例步骤的函数名称；\n\n（5）用例步骤函数所在文件的代码行数；\n\n根据以上 5 个关键信息，经过编码组合后就可以生成一个具有唯一性、可逆性的标签字符串。\n\n这里简单说明一下上述 5 个关键信息之间的关系：\n\n（1）一条自动化测试用例是写在某个用例文件（也可称为用例脚本文件或简称脚本文件）里的，用例文件的路径就包含了文件所在系统中的路径和文件名称。\n\n（2）基于面向对象的软件开发思想，在用例文件中，会以类的形式进行用例代码的编写，在类里面所定义的函数就是测试用例函数，而在测试用例函数里面是调用的用例步骤函数（\n方法）。\n\n（3）用例步骤函数所在文件的代码行数是用于区分在用例函数中，多次调用相同的用例步骤函数的情况。\n\n\n\n图（二）用例步骤函数标签字符串编码算法几个关键信息的关系\n\n代码示例如下：\n\n\n\n * test.py 是用例文件，它在操作系统中是存在一个路径的；\n\n * MyTest 是用例类类名；\n\n * test_001 是用例函数的函数名称；\n\n * click_some_element 是用例步骤函数，它来源于 page 模块的 Page 类，而且可以看出它在第 8 行和第 10 行都有调用；\n\n2.2.5、用例步骤中断后重启#\n\n如果用例步骤中某个步骤涉及重启系统，此用例在执行开始时同样会被记录到执行记录文件中，重新启动之后，由开机自启服务将自动化测试程序自动拉起，根据前面执行判断模块的\n描述可知，会直接从重启前的用例步骤的下一个步骤开始执行。\n\n这样，就实现了在用例步骤里面重启机器也能完成整个测试用例执行的功能。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了自动化测试用例步骤执行过程中，当自动化程序被中断如重启机器后，恢复中断前用例步骤继续执行的问题；\n\n（2）涉及重启设备交互的诸多性能、稳定性测试场景可以摆脱手工或部署多端测试的束缚，提升该类场景测试的自动化程度并降低实现成本；\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了自动化测试用例步骤执行过程中，当自动化程序被中断如重启机器后，恢复中断前用例步骤继续执行的问题；\n\n（2）涉及重启设备交互的诸多性能、稳定性测试场景可以摆脱手工或部署多端测试的束缚，提升该类场景测试的自动化程度并降低实现成本；\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）提供一种函数（用例步骤）对象的执行标签字符串编码组合方法；\n\n（2）提供一种在单机执行的情况下，自动化程序被中断后恢复中断前执行步骤的解决方案；\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\n机器分离自动化测试方案：\n\nhttps://zhuanli.zhangqiaokeyan.com/patent\\_6\\_106/06120113808001.html\n\nhttps://juejin.cn/post/7161999069433298974","routePath":"/技术文档/专利交底书/一种自动化测试用例步骤中断后恢复执行的技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、注册开机自启服务**","id":"221注册开机自启服务","depth":4,"charIndex":-1},{"text":"**2.2.2、执行判断模块**","id":"222执行判断模块","depth":4,"charIndex":-1},{"text":"**2.2.3、执行记录文件**","id":"223执行记录文件","depth":4,"charIndex":-1},{"text":"**2.2.5、用例步骤中断后重启**","id":"225用例步骤中断后重启","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果-1","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":42,"title":"一种自动安装镜像的技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n术语           全称                              解释\nMIPS         MIPS架构                          是一种采取精简指令集（RISC）的处理器架构\nPXE          Preboot eXecution Environment   提供了一种使用网络接口启动计算机的机制。这种机制让计算机的启动可以不依赖本地数据存储设备已安装的操作系统。\nefibootmgr   efibootmgr                      EFI引导管理器，Linux操作系统上管理启动项的工具。\nOEM镜像        定制镜像                            根据需要，满足个性化的定制，可以加入需求，实现安装过程无需人工介入，且安装好的系统符合预期需求。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在基于国产Linux操作系统的自动化测试中，需要对每日构建的最新的系统镜像进行安装，以便能在每日最新的系统上执行自动化测试。\n\n使用PXE安装系统镜像可以方便快速的实现大量测试机更新系统，通过下载每日最新的系统镜像文件，部署到PXE服务器上，测试机通过网络启动的方式重启，就可以拉取到PX\nE服务器上的镜像文件，从而实现安装最新系统。\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n在AMD和ARM平台的自动化测试中，通过PXE服务安装系统之后，下一次需要更新系统时，只需要使用efibootmgr命令，设置下一次启动以网络启动，然后使用re\nboot命令重启，即可进入网络启动，从而实现自动化无人值守安装最新镜像。\n\n在AMD和ARM架构客户机中，BIOS中硬盘启动作为第一启动顺序，安装前须要远程登录客户机将机器下一次启动修改为网络启动。重启客户机之后，客户机以网络启动方式进\n入PXE引导、安装操作系统。安装完操作系统，安装器从硬盘启动引导客户机重启，随后进入安装后配置，完成系统安装。\n\n设置下一次启动以网络启动的命令为：\n\n\n\n1.1.2、现有技术的缺点#\n\n（1）在AMD和ARM平台上，安装每日构建最新的UOS系统自动化部署流程中，有多处须要重启客户端操作。在安装完操作系统之后须要重启再进入后配置，客户端二次安装等\n操作。通过efibootmgr命令完成客户端对下次重启项的选择。\n\n（2）\nMIPS平台上没有efibootmgr命令，需要通过PXE服务安装系统时，只能重启开机手动进入BIOS设置，将启动项一修改为网络启动，然后再次重启，才能进入PX\nE服务进行网络安装系统。无法实现自动化无人值守安装最新镜像。\n\n（3） 部分机型执行efibootmgr命令之后无法准确获取到下次重启的启动号。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n（1）在对UOS自动化测试的过程中，不依赖于efibootmgr这个工具，完成部署前、部署中客户端重启引导问题。\n\n（2）解决MIPS平台无法进行自动化无人值守安装镜像的问题。\n\n\n2.2、本发明提供的完整技术方案#\n\n在进行自动化无人值守安装镜像的过程中，通过服务端流量精准控制，适时控制服务端不同种类数据流量，以便于客户端正确的完成网络引导或硬盘引导。\n\n\n\n图（一）自动安装镜像流程图\n\n2.2.1、配置启动项#\n\n在BIOS-启动里面配置开机启动顺序，将测试机启动项一设置为网络启动，启动项二为硬盘启动。进入BIOS的方法通常可以在开机时，按Delete键进入。\n\n2.2.2、网络启动，服务端控制UDP数据转发#\n\n通过ssh远程连接方式重启测试机，同时，在服务端循环检测/var/log/daemon.log日志文件里面是否存在测试机tftp发送日志，如果存在，说明客户端已\n经完成UDP数据交互，开始下载引导文件并执行安装引导流程。此时即可关闭服务端针对该客户端UDP数据的发送。\n\n添加防火墙规则，关闭客户端UDP数据转发的命令为：\n\n其中IP为测试机的IP。\n\n\n\n2.2.3、进入硬盘启动#\n\n安装完成之后会有一次自动重启，测试机重启进入启动项一网络启动时，由于已经关闭该客户端UDP数据发送，启动项一会因为超时进入启动项二，启动项二为硬盘启动，这样就能\n正常进入系统。\n\n2.2.4、解锁UDP数据转发#\n\n正常进入系统之后，只要我们没有在服务器上打开客户端UDP数据转发，测试机重启都可以正常进入系统。\n\n如果需要装机时，在服务器上打开客户端UDP数据转发，测试机重启即可进入网络装机。\n\n清空防火墙规则，打开客户端UDP数据转发的命令为：\n\n\n\n\n2.3、本发明技术方案带来的有益效果#\n\n（1）解决了自动化测试过程中，MIPS平台无法通过PXE服务自动安装系统镜像的问题。\n\n（2）解决了X86、ARM部分机器使用efibootmgr工具不生效，无法控制启动项的问题。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n（1）通过服务端流量精准控制，合理关闭指定客户端UDP数据转发，实现MIPS架构测试机无人值守安装镜像，从而实现MIPS架构对每日构建镜像的自动化安装和自动化测\n试。\n\n（2）本技术方案可应用于所有架构，实现不依赖启动项管理工具，精准控制测试机启动方式。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl PXE简介及使用说明：\n\nhttps://blog.csdn.net/jiangwei0512/article/details/99993949\n\nl OEM镜像定制说明:\n\nhttps://wikidev.uniontech.com/OEM%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6%E8%AF%B4%E\n6%98%8E\n\nl 用efibootmgr管理UEFI启动项:\n\nhttps://blog.csdn.net/mdykj33/article/details/99716705","routePath":"/技术文档/专利交底书/一种自动安装镜像的技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":4,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.2.1、配置启动项**","id":"221配置启动项","depth":4,"charIndex":-1},{"text":"**2.2.2、网络启动，服务端控制UDP数据转发**","id":"222网络启动服务端控制udp数据转发","depth":4,"charIndex":-1},{"text":"**2.2.3、进入硬盘启动**","id":"223进入硬盘启动","depth":4,"charIndex":-1},{"text":"**2.2.4、解锁UDP数据转发**","id":"224解锁udp数据转发","depth":4,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo、安东、海针"},"version":""},{"id":43,"title":"一种针对Linux系统异常命令的测试方法技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                       \n术语         全称          解释\nLinux      GNU/Linux   一种免费使用和自由传播的类UNIX操作系统。\nShell      Shell       传统意义上的Shell指的是命令行式的Shell，是操作系统最外面的一层，提供了你与操作系统之间通讯的方式，同时它又是一\n                       种程序设计语言。\n自动化测试框架    /           一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。\nShell状态码   /           执行命令的退出状态码，可体现Shell命令执行情况。\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n在基于Linux操作系统的自动化测试中，需要使用各种Shell命令对系统进行操作并测试系统响应是否符合预期。这些命令往往都可以通过自动化测试完成，通过自动化测试\n框架执行转换好的测试用例，以此完成测试。\n\n例如目前较为流行的测试框架： shUnit2 、bats 均可胜任该工作。针对 Linux 系统执行 Shell\n命令后，都会有对应的返回状态码，执行成功为0，执行失败为非0。所以针对 Shell\n命令的测试中，状态码在自动化测试框架中运用比较频繁，主要用于自动化测试用例的断言，例如判断执行的 Shell 命令，是否符合预期。\n\n状态码详情可参考：\n\n表1 Shell 状态码对应详情\n\n        \n状态码     对应情况\n0       命令成功结束\n1       通用未知错误\n2       误用Shell命令\n126     命令不可执行\n127     没找到命令\n128     无效退出参数\n128+x   Linux信号x的严重错误\n130     Linux信号2的严重错误，即命令通过SIGINT（Ctrl＋Ｃ）终止\n255     退出状态码越界\n\n\n1.1、与本发明相关的现有技术#\n\n1.1.1、现有技术的技术方案#\n\n为了更好的说明，此时使用 Shell脚本模拟一个简单的测试场景：\n\nl 步骤：向文件testfile1插入内容“True”\n\nl 预期1：文件testfile1中包含关键字“True”\n\nl 预期2：文件testfile1中不包含关键字“False”\n\nl 测试脚本内容如下：\n\n\n\n执行以上脚本结果如下：\n\n\n\n通过以上脚本【场景1】和【场景2】命令执行结果，可以看出当工具“grep”筛选到关键字返回0，未筛选到关键字会返回1，哪怕命令是成功结束的，说明“grep”会改\n变系统状态码。通过【场景3】可看到命令执行失败（日志文件缺失），但最终返回状态码1，与【场景2】结果一致。\n\n如果后续针对该场景做测试，预期结果断言为非0通过，那么【场景3】执行了错误的命令，从返回结果来看也是符合预期的，测试结果为通过。其实【场景3】最终状态码返回值与\n命令中包含管道“|”也存在关系，管道会对最终状态码产生影响，与“grep”都存在时，会产生双重干扰，下面用纯管道命令举例。\n\n例如在一条测试用例中，包含以下操作步骤：\n\nl 步骤：打印文件testfile1内容，同时把内容“True”替换为“False”展示\n\nl 测试脚本内容如下：\n\n\n\n执行以上脚本结果如下：\n\n\n\n通过【场景4】和【场景5】可以看出，当命令中包含管道“|”，状态码的返回值是以最后一个命令的返回值为准，即使管道前的命令状态码非0。所以从状态码来看，是无法识别\n出命令异常的，之前提到的【场景3】同理。\n\n上述举例的情况，在实际工作中出现概率是很大的，除了人为原因代码编写错误或经验不足以外，例如依赖的工具更新/需求变更，导致命令/参数发生变化，同样会导致正常命令变\n为异常命令。问题看似不大，却存在巨大的质量风险，因为你不知道执行通过的用例中，有一条已经无效了，用例体量大的话，日积月累下甚至会出现很多此类情况。针对此类问题，\n在人工测试时很容易发现，但是在自动化测试时，市面上现有的测试框架并不能很好的发现此类问题。\n\n\n1.1.2、现有技术的缺点#\n\n1.1.2.1、shUnit2测试框架\n\n使用目前较为流行的Shell开源测试框架 shUnit2 对1.1.1章节脚本中包含的命令进行测试，测试用例如下：\n\n\n\n执行以上测试结果如下：\n\n\n\n通过以上执行结果可以看到5条用例全部执行通过。但是【用例3】和【用例5】的执行结果是错误的，因为testfile2这个目录并不存在，这是一条异常命令，但用例的测\n试结果却是通过，这显然是一个无效测试。\n\n**1.1.2.2、**bats 测试框架\n\n使用另外一个热门 Shell 测试框架 bats 进行测试：\n\n\n\n执行测试结果如下：\n\n\n\n可以看到所有测试命令的结果均为失败，很明显测试命令中包含管道时，会影响框架对测试结果的判断，这里就限制了很多测试场景了，部分用例将命令状换后去掉管道再进行测试（\n用例4、用例5主要描述管道问题，由于无法使用，这里直接去掉）：\n\n\n\n运行结果如下：\n\n\n\n现在可以测试成功了，但是和 shUnit2\n测试框架一样，用例3的测试结果同样是错误的，未识别出异常命令。而且该框架测试场景也存在一定限制，在实际测试中使用管道的场景还是很多，比如数据的多重处理、需要人机\n交互的命令等，所以无法满足目前测试场景中复杂的变化。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n针对Linux系统Shell命令的测试中，为了解决上述技术问题，本发明提供了一种在自动化测试框架中执行测试命令的算法。经过该设计方法来执行测试命令，命令会在方法\n内部进行大量逻辑处理，重新制定状态码，快速识别异常命令并对异常命令的测试提供支撑，保留最大测试场景支持的同时，最终还能提供准确、可靠的测试结果。\n\n\n2.2、本发明提供的完整技术方案#\n\n方案流程：\n\n\n\n图1 运行逻辑主流程\n\n\n\n图2 运行逻辑子流程1\n\n\n\n图3 运行逻辑子流程2\n\n\n\n图4 运行逻辑子流程3\n\n\n\n图5 运行逻辑子流程4\n\n准备工作：\n\n针对需要测试的Linux命令的测试，需要给其命令类型定位，并给予标记，例如定义变量`case_type=True/False`。实现方式可以在调用执行命令的方法\n时传入参数，也可以在测试用例编写时直接定义等。类型设计定义为两大类型：\n\n(1) 正确命令：系统执行成功，状态码返回0的命令。\n\n(2) 异常命令：系统执行失败，状态码返回非0的命令。\n\n注：定义这个两个类型的原因，是为了满足我们日常测试中更丰富的测试场景，例如我们会针对异常命令进行测试，虽然命令报错了，但是这正是我们想要达到的预期，同时会需要对\n错误输出的文案内容做进一步测试。所以当该命令被定义为`异常命令`后，执行命令最终报错，在测试眼里反而是“执行成功”，反之如果执行成功，那么其实是“执行失败”。以\n上只是在测试场景较为简单时适用，除此之外还有一些更复杂的场景，有不同的处理逻辑，后续会有说明。\n\n--------------------------------------------------------------------------------\n\n--------------------------------------------------------------------------------\n\n方案详情：\n\n往往一条测试用例中会存在多个执行命令，这里仅用执行一条命令的流程举例，后续说明当出现多条命令时如何处理，单命令处理流程如下：\n\n 1. 在执行一条Linux命令前，先对命令进行解析，判断命令的组成内容，这里定义为4大场景：\n\n(1) 【场景1】命令中不包含`管道`与`grep`命令。\n\n(2) 【场景2】命令中不包含`管道`，但包含`grep`命令。\n\n(3) 【场景3】命令中包含`管道`，但不包含`grep`命令。\n\n(4) 【场景4】命令中包含`管道`与`grep`命令。\n\n 1. 根据解析后的命令分类进行不同处理：\n\n(1) 【场景1】如“图2 运行逻辑子流程1”中所示，处理流程为：\n\n① 执行测试命令。\n\n② 判断其状态码是否为0。\n\n1) 状态码为0，继续判断命令类型：\n\na. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nb. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n2) 状态码非0，继续判断命令类型：\n\na. 正确命令：返回状态码1，表示这是一条报错的异常命令。\n\nb. 异常命令：返回状态码0，表示这是一条正常执行完成的命令。\n\n③ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。\n\n④ 流程结束。\n\n注：这个场景是最常见与普通的场景，针对市面上现有的处理方法来说，新增的是搭配`命令类型`使用的部分，对异常命令测试的执行结果状态码做了新的定义，使测试场景更为丰\n富和灵活。\n\n(2) 【场景2】如“图3 运行逻辑子流程2”中所示，处理流程为：\n\n① 执行测试命令。\n\n② 判断其状态码是否为0。\n\n1) 状态码为0，继续判断命令类型：\n\na. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nb. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n2) 状态码非0，继续判断命令类型：\n\na. 类型为正确命令，继续判断输出内容是否为空：\n\na) 空：返回状态码0，表示这是一条正常执行完成的命令。\n\nb) 非空：返回状态码1，表示这是一条报错的异常命令。\n\nb. 类型为异常命令，继续判断输出内容是否为空：\n\na) 空：返回状态码1，表示这是一条报错的异常命令。\n\nb) 非空：返回状态码0，表示这是一条正常执行完成的命令。\n\n③ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。\n\n④ 流程结束。\n\n注：这里利用了`grep`命令的特性，当未筛选到关键字返回状态码非0，且标准输出不会存在内容，如果有输出内容则说明是错误输出，是命令执行的报错信息。\n\n(3) 【场景3】如“图4 运行逻辑子流程3”中所示，处理流程为：\n\n① 在执行测试命令前，引入命令`set`，并配置参数`-o pipefail`。\n\n② 执行测试命令。\n\n③ 判断其状态码是否为0。\n\n1) 状态码为0，继续判断命令类型：\n\na. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nb. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n2) 状态码非0，继续判断命令类型：\n\na. 正确命令：返回状态码1，表示这是一条报错的异常命令。\n\nb. 异常命令：返回状态码0，表示这是一条正常执行完成的命令。\n\n④ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。\n\n⑤ 再次调用命令`set`，并配置参数`+o pipefail`，恢复默认状态，避免对后续用例造成影响。\n\n⑥ 流程结束。\n\n注：这里运用`set`命令达到的效果是重组状态码，无论命令中有多少管道，只要有一条命令返回状态码非0，则最终状态码也返回非0；反之均为0时，最终状态码为0。这里\n避免了管道中存在命令报错，但最终状态码为0的情况，解决了管道中命令出现异常后带来的风险。\n\n(4) 【场景3】如“图5 运行逻辑子流程4”中所示，处理流程为：\n\n① 在执行测试命令前，引入命令`set`，并配置参数`-o pipefail`。\n\n② 执行测试命令。\n\n③ 判断存在的`grep`命令是否在管道最后：\n\n1) `grep`命令不在管道最后：\n\na. 判断其状态码是否为0：\n\na) 状态码为0，继续判断命令类型：\n\ni. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nii. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\nb) 状态码非0，继续判断命令类型：\n\ni. 正确命令：返回状态码1，表示这是一条报错的异常命令。\n\nii. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n注：命令中包含管道和`grep`命令，情况变的复杂，之前的处理都不再适用，这个场景下对管道的定义是各命令的处理具备连续性，若`grep`命令未筛选到结果，后续的\n命令处理均无意义，所以这类情况无论命令类型为正确/异常，最终状态定义为错误，状态码直接判断为1。\n\n2) `grep` 命令在管道最后，继续判断管道除最后一个命令以外的状态码是否都为0：\n\na. 状态码存在非0，继续判断命令类型：\n\na) 正确命令：返回状态码1，表示这是一条报错的异常命令。\n\nb) 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n注：原理同上个注释，命令中包含管道，代表各命令的处理具备连续性，若中间部分命令报错，那后续的命令处理均无意义，所以这类情况无论命令类型为正确/异常，最终状态定义\n为错误，状态码直接判断为1。\n\nb. 状态码均为0，继续判断命令最终状态码：\n\na) 状态码为0，继续判断命令类型：\n\ni. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nii. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\nb) 状态码非0，继续判断命令类型：\n\ni. 正确命令：返回状态码0，表示这是一条正常执行完成的命令。\n\nii. 异常命令：返回状态码1，表示这是一条报错的异常命令。\n\n注：流程走到这一步说明，`grep`命令之前的所有命令均执行成功，所以此时执行`grep`命令不管是否筛选出关键字，命令都算是执行成功，这里必然是正确命令，不会\n出现异常命令的情况，如果命令类型为异常命令则为类型设置错误，需要修改。\n\n④ 返回该条命令执行后重新定制的状态码与标准/错误输出内容。\n\n⑤ 再次调用命令`set`，并配置参数`+o pipefail`，恢复默认状态，避免对后续用例造成影响。\n\n⑥ 流程结束。\n\n注：相对于之前的场景，该场景最为复杂，融合了所有变量，并对其做了新的定义。其中判断存在的`grep`命令是否在管道最后的意义在于，若使用了管道说明每一个命令都是\n有意义的，如果还没进行到最后一个命令就出现了报错，或者是`grep`命令未筛选到关键字的情况，那后续的所有命令都毫无意义，这里将这种情况定义为异常，在上面的注释\n中也有说明。\n\n 2. 根据以上子流程中返回的全新状态码与输出内容，配合断言做进一步测试。\n\n 3. 根据断言结果返回测试结果，若存在一条测试用例包含多条测试命令的情况，结合重新定义的状态码进行判断：\n\n(1) 所有命令返回的状态码均为0，根据断言得出测试结果：\n\n① 每一条用例中，所有断言均通过则用例通过，状态标记为`pass`。\n\n② 每一条用例中，存在一个断言不通过，则用例不通过，状态标记为`fail`。\n\n(2) 若有其中一条命令返回的状态码非0，则该条用例状态为`error`。\n\n 4. 单条用例测试流程完毕。__\n\n_ _\n\n实验验证：\n\n最后依然采用1.1.2章节的测试点进行实际验证，代码如下：\n\n\n\n测试结果如下：\n\n\n\n图6 实际验证结果\n\n可以看到在1.1.2章节中测试无效的测试点，根据这套处理逻辑执行之后，能明显的识别出异常，规避了异常用例的测试结果为`pass`的问题。这里新增用例状态为`er\nror`，快速的识别出了用例代码质量风险，代表用例中存在测试命令异常，该条用例需要重点检查，是测试环境变化导致，还是需求变更导致命令变化等。\n\n\n2.3、本发明技术方案带来的有益效果#\n\n上述设计的执行Shell算法，运用在自动化测试框架中后：\n\n(1) 测试结果更准确，降低质量风险。\n\n(2) 能更好的识别测试命令的有效性，快速发现异常的命令，提升分析效率。\n\n(3) 支持并扩展异常命令测试场景，满足更多的测试场景变化。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n本发明的技术关键点和欲保护点是2.2章节中所阐述，设计的执行Shell测试命令的一整算法，可复用在任何Shell自动化测试框架中，达到2.3章节提到的效果：\n\n(1) 主流程：结合事先定义的命令类型，配合解析命令后得出的四大场景，给予不同子流程算法。\n\n(2) 子流程1：针对场景1设计的算法。\n\n(3) 子流程2：针对场景2设计的算法。\n\n(4) 子流程3：针对场景3设计的算法。\n\n(5) 子流程4：针对场景4设计的算法。\n\n(6) 结合主流程和子流程算法，得出全新的状态码用于对测试结果的支撑，达到2.3章节提到的目的。\n\n\n4、附件：#\n\n参考文献（如专利/论文/标准等）\n\nl Linux操作系统\n\nl Shell壳层\n\nl 自动化测试框架","routePath":"/技术文档/专利交底书/一种针对Linux系统异常命令的测试方法技术交底书","lang":"","toc":[{"text":"**0、缩略语和关键术语定义**","id":"0缩略语和关键术语定义","depth":2,"charIndex":-1},{"text":"**1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）**","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":-1},{"text":"**1.1、与本发明相关的现有技术**","id":"11与本发明相关的现有技术","depth":3,"charIndex":-1},{"text":"**1.1.1、现有技术的技术方案**","id":"111现有技术的技术方案","depth":4,"charIndex":-1},{"text":"**1.1.2、现有技术的缺点**","id":"112现有技术的缺点","depth":3,"charIndex":-1},{"text":"**2、本发明技术方案的详细阐述**","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":-1},{"text":"**2.1、本发明所要解决的技术问题**","id":"21本发明所要解决的技术问题","depth":3,"charIndex":-1},{"text":"**2.2、本发明提供的完整技术方案**","id":"22本发明提供的完整技术方案","depth":3,"charIndex":-1},{"text":"**2.3、本发明技术方案带来的有益效果**","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":-1},{"text":"**2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的**","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":-1},{"text":"**3、本发明的技术关键点和欲保护点是什么**","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":-1},{"text":"**4、附件：**","id":"4附件","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":44,"title":"基于shell的测试框架技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n                            \n名词        全称                描述\nLinux     /                 一种免费使用和自由传播的类UNIX操作系统，基于POSIX的多用户、多任务、支持多线程和多CPU的操作系统。\nShell     /                 一个命令解释器，类似于DOS下的command。它接收用户命令，然后调用相应的应用程序。\n自动化测试框架   /                 提供最基础的自动化测试功能，用于组织、管理和执行那些独立的自动化测试用例，测试完成后统计测试结果。\nSAT       Shell Auto Test   基于Shell的自动化测试框架，自定义命名为SAT\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n如今，人们的衣食住行、社会的各行各业都离不开各类操作系统、软件的正常运作和支持。小到手机里五花八门的APP：骑车、付款、购物，大到关乎国计民生的大系统：铁路运输\n的调控系统，卫星发射的操控系统，这些产品的质量，重要性不言而喻，而测试工程师则是质量的“把关者”。\n\n面对产品繁琐的测试点，测试工程师需要消耗大量的时间对其进行测试，随着产品的不断适配与迭代，工作量越来越大，怎么保质保量并且高效的完成测试任务呢？自动化测试就是其\n中一个解决方案，通过自动化的测试来代替人工手动测试，提高测试效率的同时，还可释放人工人力做其他事情。\n\n自动化测试实现的方式有很多，简单的几行代码，复杂的几万行代码，但是随着测试内容的增加、或者协同人员的增加，怎么让测试代码更容易管理、更规范、更易于维护？怎么整合\n测试用例？怎么协调测试资源？代码移植到其他系统能否复用？测试完成后是否能清晰的看到测试结果？这些都是需要面临的问题。\n\n本专利中的自动化测试框架，主要用于解决以上问题，为自动化测试提供基础运行环境，整合所有测试用例、资源统一进行测试，测试结束后有规范统一的测试报告/日志输出，用于\n定位问题。让自动化测试真正达到无人值守，完成测试准备、测试、输出测试结果全套流程。\n\n目前行业内也存在通过Shell实现的自动化测试框架：\n\n 1. shunit2\n\n 2. bats-core\n\n以上两款自动化测试框架都能做到，自动整合测试用例、执行测试、测试结束后输出测试报告。\n\n\n1.1、与本发明相关的现有技术一#\n\n1.1.1、现有技术一的技术方案#\n\n使用shunit2自动化框架进行测试，需要用户提供测试用例文件，测试文件中可包含多条用例，这里的文件命名和用例命名只要按照框架规范设置，则可以被框架自动识别。\n\n测试时可批量执行框架根目录下所有测试用例文件，也可以单独执行某一个测试文件，在测试过程中可同步在终端查看测试用例的执行进度，终端会输出每一条用例的执行结果，若执\n行失败会高亮标记，且展示对应的输出内容与提示信息，也可以在测试结束后查看终端输出的历史记录，获取测试结果。\n\n1.1.2、现有技术一的缺点#\n\n使用shunit2自动化框架针在批量执行用例时，仅会扫描框架根目录下文件是否为测试文件，并不支持扫描其他路径，若项目中涉及的测试人员、测试模块逐渐增多，那么在用\n例文件的管理会略显混乱，所有的测试文件都拥挤的存放在同一个目录中，不具备分类管理的能力。\n\n测试开始以前可以对测试环境进行初始化，保证测试用例执行的正确性，但是若当前环境中不满足某用例依赖条件，框架无法进行进一步措施，例如终止测试、标记关联用例状态。\n\n测试用例的执行状态仅有‘通过’和‘失败’，但若是功能变更导致测试命令修改，执行测试用例会报错，此时用例状态还是‘失败’，这类‘错误’状态无法被识别，需要根据失败\n用例进行分析得出结论，这里框架支持的用例执行状态不够丰富。\n\n自动化测试用例也是通过功能用例转换的，只是通过自动化的形式来执行，但在框架中自动化用例与功能用例的管理没有直接性的关联，若用例执行失败，还需要查看用例代码才能定\n位对应哪一条功能用例，较为不便。\n\n测试中和测试完成后，都能看到用例执行状态，执行状态为‘失败’的用例，可以看到其错误输出，辅助定位问题，但是结果执行状态为‘通过’，无法看到命令的标准输出，无法进\n一步验证执行状态的准确性，例如断言代码错误导致用例执行结果本来应该为‘失败’，结果最终结果为‘通过’，但通过表象无法识别，这里会存在巨大风险。\n\n测试结果输出在终端，若想保存测试结果只能通过重定向保存本地，但因为测试结果中存在关键字色彩展示，所以重定向的测试报告文件中会包含颜色代码标识，若在Linux以外\n的操作系统查看测试报告不仅没有色彩，还会影响阅读性，且在其他系统查看测试报告、归档测试报告的场景是比较常见的。\n\n\n\n图1：非Linux系统查看测试报告对比\n\n除此以外因为该框架开发者为国外研发人员，所以不管是注释，还是测试报告等内容，均不支持中文，所以在框架的使用和测试报告的阅读上不是太友好，同时也都存在一定使用、阅\n读门槛。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n使用bats-core自动化框架进行测试，总体功能与方案一差异不大，只是实现的方式和展示存在一些差异，但在测试文件管理这方便要更加灵活。\n\n该框架的测试文件后缀只要以‘.bats’结尾即可识别，对文件路径不存在强依赖情况，所以可以通过不同的测试人员、不同的测试模块，更清晰的分类管理测试文件，且不影响\n测试文件的批量执行，可以递归执行某目录下所有的测试文件。\n\n1.2.2、现有技术二的缺点#\n\nbats-core自动化框架与方案一大体上较为相似，所以方案一存在的缺点，方案二大部分都存在。\n\n除了测试文件管理的实现方式更灵活与优以外，在测试报告的保存上也更优化，重定向之后不会在文档中出现颜色代码标识，在其他系统的阅读性体现的更友好。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n本发明主要解决以下技术问题：\n\n 1. 测试文件在多项目、多人协作场景下管理混乱。\n\n 2. 测试开始前没有用例执行环境监测流程，需要测试完毕才能暴露问题，没有流程管控能力，若测试量巨大，则会消耗大量时间成本。\n\n 3. 测试用例执行状态比较单一，针对不通过用例，需要测试完成后进行深入分析定位，同样会消耗不少时间成本。\n\n 4. 自动化用例与手工用例在测试报告中不具备关联性，需要查看代码才能查出对应功能用例。\n\n 5. 无完整的测试命令结果输出日志(标准/错误输出)，在用例自检方便存在风险。\n\n 6. 框架的使用对国人缺乏友好性，例如所有页面展示元素、报告内容、说明文档、代码注释等等，均为英文，具备一定使用门槛，需要大量学习成本。\n\n 7. 框架可扩展性较低，只能通过二次开发扩展功能，在开发前同样需要消耗大量时间成本。\n\n 8. 测试完毕后感知与归档测试结果能力较弱，需要人工跟进与处理。\n\n\n2.2、本发明提供的完整技术方案#\n\n为了解决上述技术问题，本发明提供了一种新的自动化测试框架，这里命名为SAT(shell auto\ntest)，包含测试文件的合理管理、测试环境监测与控制、测试用例的执行与输出，测试日志/报告的生成与通知，使测试变得更加效率与简单，具体运行流程如下：\n\n\n\n图2：bats-core/shunit2框架与SAT框架运行流程图\n\n通过以上流程图对比差异，可以初步看出，SAT测试框架使用更友好（可视化菜单、中/英文环境），在整个测试流程中增加了更多的流程控制(运行环境监测、测试环境监测)，\n实现了更多的实用功能(测试模式、详细日志、机器人通知、邮件归档测试报告/日志)，以达到优化测试流程、提升测试效率得目的。\n\n方案设计流程：\n\n 1. 进行框架的初步配置，针对根目录下配置文件，有以下配置项：\n\n(1) 项目名称；\n\n(2) 测试人员名称；\n\n(3) 运行权限控制：root/普通用户；\n\n(4) 环境监测控制：若监测不通过，是否终止测试；\n\n(5) 语言环境控制：指定语言/自动匹配；\n\n 2. 运行一键部署工具，会针对配置文件进行扫描，自动部署与生效配置项，并自动生成对应的目录结构，用于对项目、测试人员、测试资源、用例文件的管理，使之更为清晰化\n    。\n\n 3. 框架有设计默认项目和默认测试人员，项目中包含Linux系统部分测试内容（文件系统、内核...），可直接运行测试，为用户提供一定的使用参考（README.\n    md中也有详细说明）。\n\n 4. 一键部署之后，对应的项目目录中会自动生成测试用例模板，此时用户需要根据自己的项目情况，编写对应的测试用例文件。测试用例以函数的形式存在，按照用例模板规范\n    ，用例中包含用例信息：用例标题(中/英文)、用例ID(关联功能用例)、测试人员编号、测试命令类型(正常命令、异常命令)、测试命令、断言，这些信息与功能用\n    例强关联，方便管理与定位问题。\n\n 5. 框架的测试模式支持全量测试、自定义测试，用户可根据不同使用场景，可选择不同的测试方式：\n\n(1) 全量测试：执行项目下所有测试用例\n\n(2) 自定义测试：仅执行项目下某测试人员、某模块、某条用例\n\n 6. 运行框架启动工具，进行环境检测和初始化：\n\n(1) 环境检测：检测当前用户权限是否满足框架运行条件；\n\n(2) 环境初始化：检测当前系统语言环境，加载不同语言配置。根据其他配置项，整合组件运行框架并展示菜单项。\n\n 7. 用户根据引导逐步选择菜单：\n\n\n\n图3：框架中/英文可视化菜单（菜单1为默认项目，菜单2/3为后续添加项目）\n\n 8. 根据菜单选择的测试场景，组合对应的测试用例，并对用例执行测试环境做检查(检测项可配)，列出检查结果后，若配置文件中检测控制项‘开关状态’为启用，出现检查\n    不通过项，则终止后续测试。\n\n\n\n图4：检测不通过实例（网卡检测失败，后续数字为影响用例编号）\n\n 9. 若测试环境检测通过，则正是开始执行测试用例。在执行的过程中，框架会对命令执行结果进行解析，初步分析出通过、不通过、错误三种用例执行状态。\n\n\n\n图5：执行命令解析流程\n\n 10. 同步步骤9初步解析后，再结合断言，得出最终执行状态结果。因为Linux系统有不同架构：x86、arm、mips等等，部分测试用例是区分架构的，并不通用\n     ，所以断言功能中额外支持‘不兼容’状态。\n\n 11. 得出用例执行结果后，框架会输出内容至终端，同时在后台收集命令的标准输出、错误输出、用例信息、用例执行状态等，形成详细的用例运行日志。\n\n图6：终端输出用例执行状态\n\n 12. 测试完成后整合数据，生成本地测试报告、测试日志（日志单独剥离了error状态日志，方便快速定位用例执行问题），把测试报告内容输出至终端。\n\n\n\n图6：测试结果(a/b为测试人员编号，可自定义配置)\n\n\n\n图7：本地保存测试报告/日志与截取日志部分内容\n\n 13. 触发通知事件，获取企业微信机器人接口地址、测试人员邮箱，若获取成功，则在企业微信进行通知（内容可配），整理测试报告、测试日志等附件，通过邮件发送至测试\n     人员邮箱，快速完成测试结果归档，并通过日志协助问题定位。\n\n\n\n图8：企业微信机器人通知\n\n综上，一套完整的测试流程已经完成，除此之外，框架的扩展性和易用性较好，提供了很多实用型工具与配置，以下例举了部分内容：\n\n                 \n类型   名称          说明\n配置   色彩          框架的菜单、提醒、报告等等可视化元素色彩均支持配置，满足个人审美\n配置   语言          框架语言可指定中/英文、自动匹配，满足个人阅读习惯\n配置   机器人         支持目前国内常用的企业微信、钉钉等办公软件机器人，在配置机器人地址后，测试完成时，机器人会播报测试结果，使用户能第一时间\n                 掌握测试结果，该项可缺失\n配置   邮箱          在配置邮箱后，在测试完成时，框架会自定扫描测试结果，整合测试结果文件，以附件的形式发送至配置邮箱地址，该项可缺失\n配置   框架运行日志      配置启动后，终端和本地都会输出框架运行日志，可清晰的看到框架运行原理，便于理解框架和二次开发\n配置   项目          随着项目增加，可配置默认项目以外的其他项目，配置该项后，运行部署工具，会在默认项目平级创建新项目目录，框架提供自动整合支\n                 撑\n配置   测试人员        随着自动化协作人员增加，用例文件若集中存放，会异常混乱，配置该项后，运行部署工具，会在项目/测试资源目录下自动按照测试人\n                 员创建子目录，框架提供自动整合支撑\n工具   自动部署工具      主要用于配置项目和测试人员后，一键自动增加菜单、目录结构，增加框架易用性，无需学习/查看代码，即可快速完成框架扩展\n工具   代码规范检查工具    自动扫描框架内所有shell文件，指出错误并提示修改建议，解决多人协作下，代码编写风格不规范、差异大的问题\n工具   格式规范检查工具    封装了规范的代码格式(换行、缩进等)，自动扫描框架内所有shell文件，对其格式进行自动修改，解决代码不美观、不易读问题\n工具   Git提交控制工具   Git提交控制工具：若通过Git管理框架，可一键部署自动代码扫描，针对Shell代码规范与格式做检查，若存在错误项则禁止\n                 提交，解决了代码管理约定，执行不到位问题\n\n\n2.3、本发明技术方案带来的有益效果#\n\n本发明通过“方案设计流程”部分中步骤1-13与扩展工具/配置，解决了前文提及的所有技术问题：\n\n(1) 为自动化测试中多项目、多人协作场景，使测试文件的管理更加具备层次与清晰；\n\n(2) 测试开始前支持更灵活的环境检测，自定义检测项，并增加流程控制功能，使测试流程的进行更具备逻辑性，规避无效测试；\n\n(3) 增加更丰富的测试用例执行结果状态，减少测试结束后分析定位时间，提高结果分析效率；\n\n(4) 增强自动化用例与手工用例的关联性，可通过测试结果直接明了的定位出对应的功能用例，并引入到测试报告中，减少问题定位效率；\n\n(5) 对测试用例执行结果(标准/错误输出)，进行完整的捕获，并整合为测试结果日志，为加强自检强度提供支撑，消除隐患，提高测试用例有效性；\n\n(6)\n自动识别当前系统语言环境，自动匹配中文/英文，包含提示、菜单、终端输出、测试报告等内容，自动切换中文/英文展示，同时增加可视化的操作菜单，用户只需要输出编号，即\n可完成测试，提高了对国人的友好性，降低使用门槛，提高易用性；\n\n(7) 框架增加扩展性，详情见“方案设计流程”末尾工具/配置例举部分，提升各种不同场景的适应性；\n\n(8) 测试完毕后自动生成本地测试报告，同时把测试结果通知到企业微信、测试报告邮件到测试人员邮箱，提高归档/验收效率。\n\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的#\n\n暂无\n\n\n3、本发明的技术关键点和欲保护点是什么#\n\n本发明的技术关键点包括整个测试框架的运行机制、流程控制与扩展：\n\n(1) 框架与项目、协作人员相结合的分层管理结构技术方案的设计与实现\n\n(2) 框架运行过程中流程控制时机、控制项的检查机制技术方案的设计与实现\n\n(3) 测试过程数据解析、收集与整合技术方案的设计与实现\n\n(4) 符合大环境下的测试实时汇报与归档技术方案的设计与实现\n\n(5) 框架整体易用性与扩展性(语言环境的解析与匹配、辅助工具集、自定义配置项)技术方案的设计与实现\n\n\n4、附件#\n\n参考文献\n\nl 自动化测试框架定义\n\nl Shell编程","routePath":"/技术文档/专利交底书/基于shell的测试框架技术交底书","lang":"","toc":[{"text":"0、缩略语和关键术语定义","id":"0缩略语和关键术语定义","depth":2,"charIndex":3},{"text":"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":368},{"text":"1.1、与本发明相关的现有技术一","id":"11与本发明相关的现有技术一","depth":3,"charIndex":1038},{"text":"1.1.1、现有技术一的技术方案","id":"111现有技术一的技术方案","depth":4,"charIndex":1057},{"text":"1.1.2、现有技术一的缺点","id":"112现有技术一的缺点","depth":4,"charIndex":1293},{"text":"1.2、与本发明相关的现有技术二","id":"12与本发明相关的现有技术二","depth":3,"charIndex":2132},{"text":"1.2.1、现有技术二的技术方案","id":"121现有技术二的技术方案","depth":4,"charIndex":2151},{"text":"1.2.2、现有技术二的缺点","id":"122现有技术二的缺点","depth":4,"charIndex":2351},{"text":"2、本发明技术方案的详细阐述","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":2491},{"text":"2.1、本发明所要解决的技术问题","id":"21本发明所要解决的技术问题","depth":3,"charIndex":2509},{"text":"2.2、本发明提供的完整技术方案","id":"22本发明提供的完整技术方案","depth":3,"charIndex":2930},{"text":"2.3、本发明技术方案带来的有益效果","id":"23本发明技术方案带来的有益效果","depth":3,"charIndex":5711},{"text":"2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的","id":"24针对上述技术方案是否还有替代方案同样能完成发明目的","depth":3,"charIndex":6294},{"text":"3、本发明的技术关键点和欲保护点是什么","id":"3本发明的技术关键点和欲保护点是什么","depth":2,"charIndex":6332},{"text":"4、附件","id":"4附件","depth":2,"charIndex":6576}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":45,"title":"基于视频播放器获取播放中视频资源FPS的测试技术交底书","content":"#\n\n\n0、缩略语和关键术语定义#\n\n名词    全称                  描述\n帧     Frame               一帧就是一幅静止的画面，连续的帧就形成动画\nFPS   Frames Per Second   帧率（每秒传输帧数）\n\n\n1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）#\n\n现代多媒体资源日益复杂，视频播\n放器播放视频资源最终呈现的效果存在各种差异，FPS是一项重要指标，若播放视频资源时FPS异常，用户可以直接的感受到。比如通过播放器播放一个50FPS的视频资源，\n通过显示器呈现出来只有40FPS，每秒存在10帧的差距，那么用户在观感上能察觉到视频播放卡顿、不连贯。\n\n本专利主要测试对象是针对视频播放器，测试视频资源通过播放器播放，是否达到视频资源预期FPS的新测试技术。\n\n目前行业内有多种测试方法：\n\n 1. 主观法：用户视觉，使用肉眼观察。这种方法只能测试出偏差较大的情况，精准度较低。\n\n 2. 专用设备：市面上有一些针对此场景的专用测试设备，比如\"秒发生器\"，该设备可以通过配套的摄像机检测出播放视频的FPS，且精准度有一定保证。\n\n 3. 设备辅助与计算：通过高速相机（每秒可捕捉1000-10000帧）录制视频，通过一定的算法得出播放视频的FPS。\n\n\n1.1、与本发明相关的现有技术一#\n\n1.1.1、现有技术一的技术方案#\n\n通过主观法来进行测试，只需要通过被测播放器播放不同的视频，通过肉眼进行观测，在播放过程中是否流程，是否出现卡顿、画面不连贯等问题。该方法测试起来全靠测试人员的经\n验，测试效率较高。\n\n1.1.2、现有技术一的缺点#\n\n使用方案一进行测试，适用于精度要求不高的测试场景，比如只需要保证播放功能可用，播放视频流畅即可。但是需要获得具体测试数据，做更近一步的分析时，该方法则无法满足。\n\n\n1.2、与本发明相关的现有技术二#\n\n1.2.1、现有技术二的技术方案#\n\n使用针对该场景生产的专用设备来进行测试，例如\"秒发生器\"，设备分为两部分：图像工作站、专用摄像头。\n\n原理是通过被测播放器播放视频资源，然后使用设备开始录制视频，录制时间需要大于等于120秒；通过图形工作站软件对视频录像进行单帧回放，前后两帧图片显示秒发生器中L\nED位置有差异即记为一帧，回放时间应大于等于120s；随机选取一段20s时长的视频录像，设备内部会自动计算出20s内包含的图像帧数值N,按以下公式计算出帧率数值\n：\n\n1.2.2、现有技术二的缺点#\n\n通过专用设备进行测试得出的数值精度较高，缺点也很明显，就是是对设备很依赖，如果需要到其他地点进行测试，则携带起来较为不便；甚至如果设备故障，又急需测试时，还会耽\n误测试进度；除此之外若视频时长小于120s则不可测试，当然采购设备也是一笔不小的开销。\n\n\n1.3、与本发明相关的现有技术三#\n\n1.3.1、现有技术三的技术方案#\n\n设备辅助与计算的方法，其实是一种半手工测试方法，同样需要依赖设备\"高速相机\"。原理是通过被测播放器播放视频资源，然后使用高速相机对整个播放视频进行录制，因为高速\n相机的特点，可以捕获到播放视频中每一帧的变化。视频录制结束后需要获取几个值：\n\n 1. 总帧数：录制视频中所有帧数量\n\n 2. 总掉帧数：录制视频中所有重复帧数量\n\n 3. 每秒总帧数：录制视频中某一秒时间内所有帧数量\n\n取得以上数值后根据以下公式进行运算，获得\"掉帧率\"从而计算出\"帧率值（FPS）\"：\n\n\n\n1.3.2、现有技术三的缺点#\n\n通过该方案计算的的帧率相对于技术一更为精准的多，和方案二不相上下。因为都是通过比例值运算得出的数值，最终结论都是平均FPS，但是针对视频某一段、某一秒时任然会存\n在差异。除此之外，因为依赖高速相机，所以同样会面临技术二所面临的问题。\n\n\n2、本发明技术方案的详细阐述#\n\n\n2.1、本发明所要解决的技术问题#\n\n本发明主要解决以下技术问题：\n\n 1. 针对现有技术方案，提升其测试结果精准度\n\n 2. 不依赖外部设备，适用性与易用性高\n\n\n2.2、本发明提供的完整技术方案#\n\n为了解决上述技术问题，本发明提供了一种帧率测试方法，能提高测试的准确性和通用性，具体的流程如下：\n\n\n\n> 图1：测试方案流程图\n\n准备工作：\n\n 1. 视频资源：例如30FPS视频、45FPS视频...\n\n 2. 录制工具：能调节录制视频FPS即可\n\n 3. 计时工具：毫秒级即可\n\n 4. 视频分解工具：此处使用了1个自研测试辅助工具（PerfTools）实现\n    \n    以上工具市面上满足要求的很多，就不多做介绍了，这里也说明了该方案的通用性，无需使用一些造价不菲的外部设备。\n    \n    方案设计流程：\n\n 5. 确认即将播放的视频资源FPS，启动录制工具，此时需要注意的是设置录制FPS值，必须高于视频资源FPS，才能确保完整捕获到视频资源的每一帧。\n\n 6. 启动毫秒级计时工具，此处加入该设计有两个目的（后面会细说）：\n\n(1) 协助判断重复帧\n\n(2) 协助计算帧率\n\n 3. 被测播放器开始播放视频资源，与此同时计时器与录制工具运行中。\n\n 4. 视频播放完毕，关闭播放器/计时器，结束录制并导出视频。\n\n 5. 使用PerfTools工具对视频进行分解处理，工具可以把视频分解成图像帧，并且支持设置把每一秒分解成N帧，需要注意的是数值N必须大于视频资源FPS，最佳\n    情况下，数值N=视频资源FPS*2，比如50FPS的视频资源，每秒分解100帧，这样才能确保不会丢失细节并且不会对后期的数据处理造成太大负担。\n\n 6. 根据视频播放总时长把视频分为前、中、后三期。\n\n 7. 在视频前期，获取1秒内所有图像帧，隔离保存。获取方法是利用每一帧图像中的计时器时间，定位首帧、尾帧，然后把包含首帧与尾帧范围内的所有图像帧隔离备用，确认\n    首、尾帧方法如下：\n\n(1) 确保该图像帧与上一帧有变化，即可被定义为首帧，并记录计时器时间。\n\n(2)\n使用首帧计时器时间，后推1000ms为尾帧，需要注意的是毫秒级的精度太高，并不一定能必然出现完全匹配的1000ms，取最接近的值即可，比如：989ms、998m\ns...均可。\n\n\n\n> 图2：首帧、尾帧实例\n\n 8. 使用同样的办法，在视频中、后期获取对应的1秒图像帧。\n\n 9. 依次处理每一组数据重复帧，直接剔除，需要注意的是：\n\n(1) 重复帧的定义：完全相同的图像帧。这里需要注意的是细节变化，只要存在：光线明/暗变化、局部模糊/清晰变化等等类似场景都不算是完全相同。\n\n(2) 帧间隔计算公式：\n\n(3) 计时器辅助去重：\n\na. 若相邻图像帧计时器时间相同，直接判断为重复帧\n\nb.\n若相邻图像帧计时器时间不相同，图像画面又没有明显差异，则可以通过计时器辅助判断：例如50FPS的视频资源，根据上述公式可计算出帧间隔为20ms。如果遇到光线杂乱\n不好分辨是否相同的图片，可以查看这2张图像帧计时器差异是否小于20ms，如果小于20ms则可以直接判断为重复帧。\n\n\n\n> 图3：重复帧处理流程\n\n 10. 之前有解释：，所以去重后得出剩余图像帧数量则为当前视频片段帧率。\n\n 11. 按照同样的方法得出视频中期、后期帧率，这样就计算出了视频前、中、后期视频片段帧率，该片段选取只是举例，可增加测试片段。\n\n 12. 平均帧率可通过公式计算：\n\n综上，通过以上测试方法，成功计算出了视频片段的实时帧率与平均帧率，可以从两个维度对测试结果进行分析：平均FPS是否达标、所有片段FPS是否平稳，至此整个流程完毕\n。\n\n\n\n> 图4：测试结果实例\n\n2.3、本发明技术方案带来的有益效果\n\n通过本发明测试方法\"方案设计流程\"中步骤7-10，可求出视频片段的实时FPS，因为FPS最小单位就是秒，所以这里比通过平均值求出的FPS精准度更高，同时可以根据\n视频播放过程中各个阶段的实时FPS，测试播放器播放视频的稳定性。\n\n除此之外该测试方法合理组合运用了各通用性软件，达到测试目的，无需再配套外部设备，解决了测试过程过于依赖外部设备的问题，更具备通用性，并且降低了测试成本。\n\n2.4、针对上述技术方案，是否还有替代方案同样能完成发明目的\n\n暂无\n\n3、本发明的技术关键点和欲保护点是什么\n\n本发明的技术关键点包括测试辅助工具的组合设计、测试方法（\"方案设计流程\"步骤1-12）的设计与实现。\n\n4、附件\n\n参考文献\n\n * FPS定义，https://baike.baidu.com/item/FPS/3227416?fr=aladdin\n\n * 帧定义，https://baike.baidu.com/item/%E5%B8%A7/460387\n\n * 视频定义，https://baike.baidu.com/item/%E8%A7%86%E9%A2%91","routePath":"/技术文档/专利交底书/基于视频播放器外部获取播放中视频FPS的测试技术交底书","lang":"","toc":[{"text":"0、缩略语和关键术语定义","id":"0缩略语和关键术语定义","depth":2,"charIndex":3},{"text":"1、相关技术背景（背景技术），与本发明最相近似的现有实现方案（现有技术）","id":"1相关技术背景背景技术与本发明最相近似的现有实现方案现有技术","depth":2,"charIndex":134},{"text":"1.1、与本发明相关的现有技术一","id":"11与本发明相关的现有技术一","depth":3,"charIndex":573},{"text":"1.1.1、现有技术一的技术方案","id":"111现有技术一的技术方案","depth":4,"charIndex":592},{"text":"1.1.2、现有技术一的缺点","id":"112现有技术一的缺点","depth":4,"charIndex":703},{"text":"1.2、与本发明相关的现有技术二","id":"12与本发明相关的现有技术二","depth":3,"charIndex":803},{"text":"1.2.1、现有技术二的技术方案","id":"121现有技术二的技术方案","depth":4,"charIndex":822},{"text":"1.2.2、现有技术二的缺点","id":"122现有技术二的缺点","depth":4,"charIndex":1057},{"text":"1.3、与本发明相关的现有技术三","id":"13与本发明相关的现有技术三","depth":3,"charIndex":1201},{"text":"1.3.1、现有技术三的技术方案","id":"131现有技术三的技术方案","depth":4,"charIndex":1220},{"text":"1.3.2、现有技术三的缺点","id":"132现有技术三的缺点","depth":4,"charIndex":1476},{"text":"2、本发明技术方案的详细阐述","id":"2本发明技术方案的详细阐述","depth":2,"charIndex":1612},{"text":"2.1、本发明所要解决的技术问题","id":"21本发明所要解决的技术问题","depth":3,"charIndex":1630},{"text":"2.2、本发明提供的完整技术方案","id":"22本发明提供的完整技术方案","depth":3,"charIndex":1713}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":46,"title":"Wayland键鼠模拟工具技术调研","content":"#\n\n\n1、问题#\n\n目前Wayland环境下没有一个相对完美的键鼠模拟工具，我们希望实现一个键鼠模拟工具，需要具备以下功能点。\n\n 1. 模拟键盘鼠标的动作\n 2. 获取光标位置\n 3. 需要能便捷输入中文文字\n\n\n2、术语定义#\n\n序号   术语         定义\n1    uinput     在内核中模拟一个输入设备，模拟输入操作\n2    KWayland   一个 Wayland 下支持操控键鼠的库\n3    X11        一种显示服务器协议，linux 系统上广泛使用。\n4    Wayland    一种显示服务器协议，旨在替代 X11。\n\n\n3、键鼠模拟操控现状#\n\n\n3.1、uinput#\n\nuinput（User Input）是 Linux 内核提供的一个框架，用于模拟用户输入设备，例如键盘、鼠标和游戏手柄等。通过\nuinput，用户空间程序可以创建虚拟输入设备，并模拟各种输入事件，从而实现对键鼠操控的模拟。\n\n优点\n\n原生支持： uinput 是 Linux 内核的一部分，原生支持在 Linux 系统上模拟用户输入设备，不需要额外安装软件包。\n\n灵活性： 用户空间程序可以根据需要创建不同类型的虚拟输入设备，并模拟各种输入事件，包括按键、鼠标移动、点击等，灵活性很高。\n\n与系统集成： uinput 可以很好地与系统集成，可以与 X11、Wayland 等窗口系统无缝配合，实现对图形界面的模拟操控。\n\n适用性广泛： 由于 uinput 是 Linux 内核的一部分，因此适用于各种基于 Linux 内核的操作系统和嵌入式设备。\n\n缺点\n\n权限管理： 使用 uinput 需要对设备文件 /dev/uinput 具有适当的权限，通常需要 root 或者具有相应权限的用户才能够操作。\n\n编程复杂性： 虽然 uinput 提供了丰富的功能，但是使用起来相对复杂，需要深入理解 Linux 输入系统和相关接口的工作原理。\n\n依赖性： uinput 依赖于 Linux 内核和相应的驱动程序，因此在某些嵌入式系统或者特定配置下可能无法使用。\n\n\n3.2、KWayland#\n\nKWayland 是 KDE 社区开发的一个库，用于在 Wayland 显示服务器和客户端之间进行通信。它提供了用于构建 Wayland 协议的 C++\nAPI，使开发者能够轻松地创建 Wayland 客户端和服务器端应用程序。\n\n优点\n\n原生支持 Wayland 协议： KWayland 提供了原生的 Wayland 协议支持，允许您在 Wayland\n显示服务器和客户端之间进行通信，从而实现对键盘和鼠标的模拟操控。\n\n功能丰富： KWayland 提供了丰富的功能，包括处理输入设备事件、管理窗口、渲染和图形处理等，使得模拟键鼠操控变得更加容易和灵活。\n\n跨平台性： KWayland 是基于 Qt 框架的，因此具有良好的跨平台性，能够在各种支持 Qt 的操作系统上运行。\n\n社区支持： 作为 KDE 社区的一部分，KWayland 受到了活跃的社区支持和持续的更新，可以获得及时的修复和改进。\n\n缺点\n\n依赖性： 使用 KWayland 需要依赖于 Qt 和 KF5（KDE Frameworks 5），因此需要确保系统中安装了这些依赖项。\n\n性能开销： 在某些情况下，使用 KWayland 进行模拟键鼠操控可能会带来一定的性能开销，特别是在处理大量事件时可能会影响系统性能。\n\n\n4、获取光标位置现状#\n\n\n4.1、uinput#\n\n虽然 uinput 允许创建和注入输入事件，但它不直接提供获取光标位置的功能。获取光标位置通常需要访问系统中的显示服务器的状态。\n\n\n4.2、KWayland#\n\n在使用 KWayland 时，无法通过编译后的库直接获取光标位置，Wayland 与 X11\n不同，在设计上更加注重安全和简洁，因此直接获取全局光标位置的能力被限制了。为了实现这个功能，需要在 KWayland 的源代码中进行自定义修改，这个很考验对\nKWayland 源代码和Wayland协议熟悉与理解。\n\n\n5、模拟文字输入现状#\n\n\n5.1、自定义实现输入法#\n\n自定义实现一个输入法，这样就可以达到输入各种文字的目的，但这涉及多个方面，包括输入法引擎的设计、用户界面的实现、系统集成。linux 有 3\n大输入法框架，工作量大，有难度，通过选择适当的输入法框架、合理的设计和优化，可以实现一个功能丰富、性能优良的输入法。\n\n\n5.2、通过剪贴板输入文字#\n\n在 Wayland 下，由于其设计初衷是更加注重安全性和隐私，限制了应用程序直接访问全局剪贴板的能力。这与 X11\n不同，后者允许应用程序直接访问和操作剪贴板。在 Wayland\n中，剪贴板的访问和操作通常由合成器（compositor）管理，这使得直接写入剪贴板变得更为困难。然而，通过正确的 API 和协议，仍然可以实现这一功能。\n\n在 Wayland 下，剪贴板操作主要通过 wl_data_device_manager 和 wl_data_source\n接口来实现。应用程序不能直接访问全局剪贴板，但可以在合成器允许的情况下进行剪贴板内容的设置和读取。并且由于正常 Wayland 系统为兼用 X11\n显示协议，通常存在 XWayland 服务，这使得直接使用 X11 剪贴版写入工具也可完成剪贴板写入操作。\n\n\n6、整体方案#\n\n\n6.1、工具设计#\n\n使用 uinput 模拟键鼠输入 + 光标获取\n\n优点: 直接访问内核输入子系统，提供较低延迟和高精度的输入模拟。\n\n适用场景: 需要精确模拟键鼠操作的应用，适用于所有支持 uinput 的 Linux 系统。\n\n通过剪贴板实现中文输入\n\n优点: 简单实现，通过剪贴板操作进行文本输入。\n\n难点: Wayland 环境下实现困难，由于安全性限制，可能影响用户体验。\n\n适用场景: 较低频率的文本输入，或者需要快速实现的原型系统。\n\n\n\n图1\n\n具体工具结构，采用经典 CS 结构，Python 包负责封装调用接口，Wdotoold 负责实现具体各个功能单元。\n\n\n\n图2\n\n\n6.2、工具实现#\n\nuinput 初始化实现\n\n\n\n剪贴板写入实现\n\n由于 uos 存在 Xwayland 服务，目前使用 wl-clipboard 实现剪贴板写入功能。\n\n代码孵化仓库\n\nhttps://github.com/funny-dream/wdotool.git\n\n\n7、小结#\n\n\n7.1、现有方案总结#\n\n总体实现一个模拟键鼠操作的工具，主要功能包括键鼠操控、光标位置获取和中文输入。\n\n\n7.2、后续演进#\n\n考虑兼容各种系统，后续将使用配置文件依据实际系统是否支持，按下图中 Wdotool 服务端单元组件功能进行组合配置，使用 KWayland + uinput\n实现键鼠模拟和光标获取，使用剪贴板 + 自定义输入法实现中文输入。\n\nKWayland 实现键鼠模拟和光标获取\n\n优点: 通过 Wayland 协议实现，适用于使用 Wayland 显示服务器的系统。\n\n适用场景: 运行在 Wayland 环境下的应用，需要与 Wayland 合成器协作的场景。\n\n工具提供多套配置方案，以适应不同的使用场景和平台需求。\n\n自定义输入法实现中文输入\n\n优点: 提供灵活性和可定制性，可以根据特定需求设计输入法逻辑。\n\n适用场景: 需要特定功能或行为的输入法，适用于 IBus 或 Fcitx 框架。\n\n\n\n\n8、参考资料#\n\n 1. https://www.kernel.org/doc/html/latest/input/uinput.html\n 2. https://github.com/KDE/kwayland\n 3. https://github.com/fcitx/fcitx5\n 4. https://github.com/phuang/ibus","routePath":"/技术文档/技术调研/wayland键鼠模拟工具技术调研","lang":"","toc":[{"text":"1、问题","id":"1问题","depth":2,"charIndex":3},{"text":"2、术语定义","id":"2术语定义","depth":2,"charIndex":108},{"text":"3、键鼠模拟操控现状","id":"3键鼠模拟操控现状","depth":2,"charIndex":288},{"text":"3.1、uinput","id":"31uinput","depth":3,"charIndex":302},{"text":"3.2、KWayland","id":"32kwayland","depth":3,"charIndex":894},{"text":"4、获取光标位置现状","id":"4获取光标位置现状","depth":2,"charIndex":1456},{"text":"4.1、uinput","id":"41uinput","depth":3,"charIndex":1470},{"text":"4.2、KWayland","id":"42kwayland","depth":3,"charIndex":1550},{"text":"5、模拟文字输入现状","id":"5模拟文字输入现状","depth":2,"charIndex":1722},{"text":"5.1、自定义实现输入法","id":"51自定义实现输入法","depth":3,"charIndex":1736},{"text":"5.2、通过剪贴板输入文字","id":"52通过剪贴板输入文字","depth":3,"charIndex":1883},{"text":"6、整体方案","id":"6整体方案","depth":2,"charIndex":2260},{"text":"6.1、工具设计","id":"61工具设计","depth":3,"charIndex":2270},{"text":"6.2、工具实现","id":"62工具实现","depth":3,"charIndex":2569},{"text":"7、小结","id":"7小结","depth":2,"charIndex":2710},{"text":"7.1、现有方案总结","id":"71现有方案总结","depth":3,"charIndex":2718},{"text":"7.2、后续演进","id":"72后续演进","depth":3,"charIndex":2773},{"text":"8、参考资料","id":"8参考资料","depth":2,"charIndex":3134}],"domain":"","frontmatter":{"Author":"有志"},"version":""},{"id":47,"title":"youqu3中断任务续跑功能调研","content":"#\n\n\n1 问题#\n\n背景现象：\n\n目前 youqu3 在进行测试过程当中会因为一些外在因素中断测试，例如：\n\n * 异常中断：\n   \n   * 系统 Bug 导致随机出现系统待机、断电\n   * 强制手动中断，例如连续触发 ctrl+c，框架未进行收尾动作\n\n * 正常中断：\n   \n   * 流水线超时中断\n   \n   * 手动中断，等待框架进行收尾\n\n面临问题：\n\n * 继续测试：如果后续需要继续执行未执行的用例，要么全量重跑，要么则筛选未执行的用例继续执行。但当用例数量较大时，筛选用例显得 较为麻烦。\n * 测试报告：\n   \n   * 异常中断：无法触发钩子生成测试汇总结果，需要手动统计较为麻烦。\n   \n   * 正常中断：有测试报告，但是第二次继续测试完成之后，需要手动收集两次测试结果并进行汇总。\n\n\n2 现状#\n\n基于目前梳理出的问题，处理思路：\n\n * 增加一个日志文件，实时记录用例执行过程，并在测试结束后汇总，独立于其他日志体系：\n   * 当中断时能触发续跑，基于最后一条用例位置继续执行\n   * 续跑完成后，统计测试结果汇总数据：总数/通过数/失败数/跳过数\n * youqu3 run 命令后增加子参数，用于触发执行动作，目前计划实现3个子参数：\n   * 参数1：开关参数，触发中断后续跑动作\n   * 参数2：需传入用例函数名作为参数值，在该位置开始执行测试（与参数1互斥）\n   * 参数3：需传入\"asc/desc\" 作为参数值，修改用例执行顺序，基于用例编号：升序/逆序执行\n\n备注：参数2、参数3 作为实现参数1过程中的衍生参数，参数3 升序执行用例可使执行顺序与用例 py 文件顺序一致，调试时更为顺滑。\n\n实现以上想法实现方案：\n\n * 方案1：开发 pytest 插件，在 youqu3 环境依赖中增加，部署时自动安装，在关键位置进行调用。\n\n * 方案2：基于 pytest 钩子函数，在youqu3 中各钩子内部直接实现功能。\n\n以上均能达到目的，但从维护成本和实现效率的角度来说，现阶段直接在 youqu3\n内部快速实现更为合理，而且以上功能可以归纳为用例执行控制相关功能，在框架内部实现也更合适。\n\n退一步说，如果后续继续扩展的更丰富后，需要抽离成插件也可以，综合考虑所以最终决定采用方案2。\n\n\n3 技术方案#\n\n方案在 youqu3 的执行流程如下：\n\n\n\n\n3.1 整体设计#\n\n基于 youqu3 目前结构进行功能开发，主要涉及以下部分的修改：\n\n1、命令行参数新增：基于新增功能，增加对应参数，涉及文件cli.py\n\n2、参数异常校验：基于参数传递的值做异常判断，涉及文件run.py\n\n3、钩子功能开发：在不同的钩子内部实现日志输出、用例列表重组、用例执行控制，涉及文件plugin.py\n\n3.1.1 命令行参数新增#\n\n在cli.py 增加3个参数，用于触发章节2中提到的对应功能，代码如下：\n\n\n\n以上代码实现增加 youqu3 命令行参数并增加 help 提示信息：\n\n * 执行用例开始位置：--start-case {用例函数名称}\n\n * 中断续跑：--interrupt-continue\n\n * 执行用例顺序：--order_execution {升序/降序}\n\n3.1.2 参数异常校验#\n\n在run.py文件中在构造函数__init__中新增对象属性，同时在方法 generate_cmd 中进行命令组装，代码如下：\n\n\n\n在 run 方法中增加参数值的异常校验，代码如下：\n\n\n\n以上便完成了参数相关的所有开发。\n\n3.1.3 钩子功能开发#\n\n在 youqu3 中钩子函数主要集中在文件plugin.py 中，所以后续的功能实现主要在这里完成。\n\n3.1.3.1 执行日志#\n\n该功能主要用于实时记录用例的执行结果，分别包括setup、call、teardown 三个阶段的结果，最小颗粒为函数。\n\n也就是说在用例 test_music_123456.py 中存在多条用例：test_music_123456_1、\ntest_music_123456_2，在执行时都会被记录。\n\n主要作用包括：\n\n * 在测试中断后，能基于日志确定中断位置\n\n * 基于日志能解析出最后一条执行的用例，并在续跑中当做标记，在执行前删除掉用例列表已经执行的部分\n\n * 在续跑完成后，能整合之前中断的一次、多次续跑的测试结果，并给出汇总数据\n\n完成以上功能开发，主要运用了以下钩子：\n\npytest_addoption： 定义新增的三个自定义参数\n\n\n\n**pytest_sessionstart：**日志文件初始化\n\n\n\npytest_report_teststatus: 实时记录用例执行结果\n\n\n\npytest_sessionfinish： 测试完成基于日志，输出汇总数据：total、passed、failed、skipped\n\n\n\n3.1.3.2 中断续跑#\n\n该功能主要实现，测试中断之后的下一次测试会话，能继续执行未执行的用例，同时不会重复执行已执行的用例。\n\n这里对已执行的定义是：完整执行了 call、setup、teardown 三个阶段的用例。\n\n实现该功能的主要阶段是在youqu3 收集到所有需执行用例之后，对用例列表进行改写，基于 3.1.3.1\n章节中实现的执行日志解析出最后一条执行的用例，以下一条用例作为起始点开始进行测试，主要在钩子pytest_collection_modifyitems 中实现。\n\n\n\n其中用例执行顺序是继承于最后一次测试，若解析出的用例与执行列表最后一条用例一致，则说明上一次的任务并未中断，则终止续跑。\n\n3.1.3.3 指定用例起始位置#\n\n该功能主要用于指定测试会话起始位置，基于传入的测试用例函数名称。\n\n应介入阶段与中断续跑一致，所以同样在钩子pytest_collection_modifyitems 中实现。\n\n\n\n本章节与3.1.3.2章节在实现逻辑上相同，底层逻辑都是指定用例开始位置，只是不同功能开始的位置有所差异，所以均使用函数\nsection_items_by_letsgo 进行实现：\n\n\n\n在指定开始位置后，若标记用例不存在与执行列表则会抛异常，终止测试。\n\n需注意的是：用例 test_music_123456.py 中存在多条用例：test_music_123456_1、 test_music_123456_2\n\n * 传值test_music_123456_2 ：则只会执行test_music_123456_2\n\n * 传值test_music_123456：报错，因为它并非函数名称，可替换为test_music_123456_1\n\n3.1.3.4 测试用例排序执行#\n\n该功能主要实现，将测试用例基于用例编号 为标记，升序 or 逆序执行，主要在钩子pytest_collection_modifyitems 中实现。\n\n\n\n函数sort_items_by_letsgo 用于接收--order-execution的值，对用例列表进行排序改写，函数代码如下：\n\n\n\n该功能是其实只需要升序功能，因为升序之后测试结果与pycharm 中用例文件顺序一致，还可搭配指定位置进行批跑，在用例批量适配阶段定位和调试都非常顺滑。\n\n\n4 实验验证#\n\n本章节将创建一个简易的 youqu3 工程，对新增参数进行实际效果验证，看是否满足预期。\n\n\n4.1 创建工程与用例#\n\n用例目录结构如下：\n\n\n\n该结构仅作为验证作用，覆盖了不同阶段的测试结果与顺序关系。\n\n\n4.2 执行日志#\n\n执行命令：youqu3 run -w mars\n\n查看日志 report/logs/last_result.log 内容:\n\n\n\n**行首：**标注了用例执行顺序， pytest 表示是默认执行顺序\n\n**夹层：**用例执行结果：passed/failed/sikpped\n\n**行尾：**用例汇总数据：总数/通过数/失败数/跳过数\n\n其中用例执行结果和汇总数据都包含：\n\n * 函数维度\n * py 文件维度\n\n\n\n特殊情况\n\n其中存在一些用例，call 阶段通过，但是在 teardown 阶段失败，这类用例定位很明确，理论上是通过的，所以需要快速处理 teardown 部分的问题。\n\n所以在函数维度结果后方是passed，快速定位这类用例可搜索：\n\n\n\n留底追溯\n\n在本地测试环境下可能需要追溯之前测试的内容，所以在会话结束阶段 last_result.log 会以时间戳命名，在同级 json 目录进行留底：\n\n\n\n\n4.3 修改用例执行顺序#\n\n通过 4.2 章节可看出 pytest 默认执行顺序：\n\n * <Function test_a>\n * <Function test_b>\n * <Function test_mycase_11>\n * <Function test_mycase_111>\n * <Function test_mycase_11652>\n * <Function test_mycase_123>\n * <Function test_mycase_222>\n\n现在我们基于用例编号，对用例执行列表的排序进行修改，执行命令加入参数 --order-execution ，再查看用例执行顺序的变化\n\n执行命令：youqu3 run -w mars --order-execution \"asc\"\n\n查看日志 report/logs/last_result.log 内容:\n\n\n\n执行命令：youqu3 run -w mars --order-execution \"desc\"\n\n查看日志 report/logs/last_result.log 内容:\n\n\n\n\n4.4 指定用例开始位置#\n\n为了更直观，这里结合参数 --order-execution \"asc\" 进行用例指定.\n\n执行命令：youqu3 run -w mars --order-execution \"asc\" --start-case \"test_mycase_222_2\"\n\n查看日志 report/logs/last_result.log 内容:\n\n\n\n??\n\n\n4.5 中断续跑#\n\n这里手动模拟中断场景，再使用开关参数 --interrupt-continue 进行续跑。\n\n执行命令：youqu3 run -w mars --order-execution \"asc\"，在执行用例时使用 ctrl + c 中断测试，终端输出：\n\n\n\n查看日志 report/logs/last.log 内容:\n\n\n\n执行中断续跑命令：youqu3 run -w mars --interrupt-continue\n\n在对用例列表前后增加了打印信息，终端输出：\n\n\n\n查看日志 report/logs/last_result.log 内容:\n\n\n\n通过终端输出与日志输出可看到，中断续跑实际效果，完全满足特性：\n\n * 仅续跑未执行过的用例\n\n * 汇总多次测试结果\n\n\n5 小结#\n\n通过章节4的验证，可看出目前已解决当前面临的问题，后续遇到测试中断的情况，可以基于中断续跑功能进行补测，并快速获取汇总的测试结果。\n\n日志汇总虽然是作为中断续跑的支持功能，但标准的 json 格式输出可被其他功能或平台读取数据。\n\n而在开发中断续跑与日志汇总两个功能过程当中，基于日常使用场景，顺势实现了用例排序、指定测试起始位置，后续基于顺序控制用例执行范围，还可以有更多的扩展，例如：\n\n * 指定用例执行结束位置\n * 指定用例执行顺序中特定范围\n * ......\n\n如果用例控制这一块 内容后续足够丰富后，也可以抽离出来做成 pytest 公共插件与框架解耦，在需要的时候进行安装调用。\n\n\n6 参考资料#\n\npytest 官方文档","routePath":"/技术文档/技术调研/youqu3中断任务续跑功技术能调研","lang":"","toc":[{"text":"1 问题","id":"1-问题","depth":2,"charIndex":3},{"text":"2 现状","id":"2-现状","depth":2,"charIndex":364},{"text":"3 技术方案","id":"3-技术方案","depth":2,"charIndex":983},{"text":"3.1 整体设计","id":"31-整体设计","depth":3,"charIndex":1016},{"text":"3.1.1 命令行参数新增","id":"311-命令行参数新增","depth":4,"charIndex":1186},{"text":"3.1.2 参数异常校验","id":"312-参数异常校验","depth":4,"charIndex":1381},{"text":"3.1.3 钩子功能开发","id":"313-钩子功能开发","depth":4,"charIndex":1510},{"text":"4 实验验证","id":"4-实验验证","depth":2,"charIndex":3057},{"text":"4.1 创建工程与用例","id":"41-创建工程与用例","depth":3,"charIndex":3113},{"text":"4.2 执行日志","id":"42-执行日志","depth":3,"charIndex":3172},{"text":"4.3 修改用例执行顺序","id":"43-修改用例执行顺序","depth":3,"charIndex":3597},{"text":"4.4 指定用例开始位置","id":"44-指定用例开始位置","depth":3,"charIndex":4083},{"text":"4.5 中断续跑","id":"45-中断续跑","depth":3,"charIndex":4271},{"text":"5 小结","id":"5-小结","depth":2,"charIndex":4619},{"text":"6 参考资料","id":"6-参考资料","depth":2,"charIndex":4927}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":48,"title":"Avocado和YouQu对比调研报告","content":"#\n\nAvocado 是一个基于 Linux 的自动化测试框架，使用 Python 语言编写构建，具有许多特色功能；YouQu 也是基于 Linux\n的自动化测试框架，同样也是使用 Python 语言编写构建。\n\n本文主要探寻 Avocado 引以为傲的特色功能，与 YouQu 框架进行对比，看看哪个框架更加适合现代化的自动化测试。\n\n以下将从几个方面分别对各功能进行对比：\n\n\n驱动方式#\n\n\nAvocado#\n\nAvocado 使用命令行方式驱动，使用子命令 run 执行用例；\n\n\n\n远程执行也有插件支持。\n\n\nYouQu#\n\n这点和 YouQu 不谋而合，YouQu 也是命令行方式驱动，本机运行的子命令也是 run ；\n\n\n\n这里申明，YouQu 在设计时绝对没有参考 Avocado ，纯属巧合，只能说英雄所见略同。\n\nYouQu 除了 run 子命令，还支持其他的子命令，如： remote, pmsctl, csvctl, startapp ；\n\n详细用法情况查看：http://youqu.uniontech.com/框架功能介绍/执行管理器/\n\n\n小结#\n\n驱动方式都采用了类似的功能设计，都支持自定义扩展驱动功能。\n\n\n多种格式的测试报告#\n\n\nAvocado#\n\nAvocado 默认支持 XML、JSON 格式的测试报告，至于 HTML 格式的测试报告需要安装插件\navocado-framework-plugin-result-html；\n\nAvocado 的 HTML 报告是这样的：\n\n\n\n\nYouQu#\n\nYouQu 默认支持 XML、JSON、HTML格式的测试报告。\n\nYouQu 的 HTML 报告是这样的：\n\n\n\n\n\n\n小结#\n\nAvocado 官方是这样评价它的 HTML 报告的：\n\n截图自官网\n\n\n\n。。😅\n\n我只能说 Avocado 这个报告还有很大的进步空间，尊重并祝福。\n\nYouQu 的测试报告除了 UI 界面好看、信息展示全，还加入了用例失败录屏、失败截图、用例执行日志等等，建议 Avocado 尽快使用 YouQu\n的测试报告插件。\n\n\n收集系统数据#\n\nAvocado 自带一个 sysinfo 插件，能自动收集一些系统运行数据，如：cpuinfo、meminfo等；\n\nYouQu 自带一个 --top 参数，可以自动收集系统运行时的 top 命令的数据；\n\n这个功能可以辅助做测试用例失败分析，但是个人认为自动化框架收集系统数据还是有局限，而使用 Prometheus、Zabbix、Grafana\n等专业的监控工具更好。\n\n所以，此功能我个人认为，聊胜于无吧，就不做展开分析了。\n\n\n批量运行用例#\n\n\nAvocado#\n\nAvocado 提供了通过标签筛选测试用例执行的功能；\n\n用例标签#\n\n用例标签的标注方式是在用例代码中用例类说明或用例函数说明 里面来标注，必须使用 :avocado: tags= 这样的范式写标签。\n\n\n\n筛选用例执行#\n\n使用 --filter-by-tags 参数指定标签的名称，支持多种逻辑组合；\n\n * 执行包含某一个标签的用例： --filter-by-tags=net\n * 执行包含不某一个标签的用例：--filter-by-tags=-net\n * 执行同时包含多个标签的用例：--filter-by-tags=disk,slow,unsafe\n * 执行包含 disk 标签或包含 net 标签的用例：--filter-by-tags=disk --filter-by-tags=net\n\n\nYouQu#\n\n用例标签#\n\nYouQu的用例标签是在一个 CSV 文件里面去写，方便维护者使用 Excel 打开进行编辑：\n\nCSV 文件标签示例：\n\n脚本ID     PMS用例ID   用例级别   用例类型   设备类型   一二级BUG自动化   上线对象   跳过原因       确认修复   废弃用例   ...\n679537   679537    L1     FUNC   PPL    BUG         CICD   skip-XXX                 \n\n标签支持无限扩展，标签支持自动生成和自动维护，维护起来非常方便，不需要到茫茫多的 py 用例脚本中去改标签，使用 Excel 打开就能快速的维护标签 。\n\n筛选用例执行#\n\n通过参数 -t 或 --tags 指定不同的标签进行用例筛选执行，而且标签支持使用 and/or/not 逻辑进行组合，比如：-t 'L1 and FUNC'\n表示执行带有 L1 且 带有 FUNC 标签的用例，使用非常符合语义对吧。\n\n而且还支持通过指定关键词进行用例筛选，使用参数 -k 或 --keywords 指定关键词，关键词也支持使用 and/or/not\n逻辑组合，关键词有很多，比如：py 文件的名称、用例类名称、用例函数名称、名称中的部分字符等等都是关键词。\n\n而且的而且，标签和关键词两个参数可以同时使用，可以组合出任意的用例集合，只有想不到没有办不到。\n\n\n小结#\n\nAvocado\n这样的标签管理方式是非常难以维护的，因为标签分布在各个脚本的注释中，如果后期要进行批量的修改，维护者将会非常痛苦而且非常耗时，你可以想象一下，在几千各 py\n文件中，挨个打开修改一个注释，人都麻了。我只能说非常的 Old school。\n\n而 Avocado 的用例筛选执行方式，官方文档用了大量的篇幅和示例来介绍其用法，基本能满足业务使用要求，但是使用比较麻烦，参数传递不够优雅。\n\nYouQu 的用例标签化管理是独有的专利方案，所有的标签在一个 CSV 文件里面去维护，可维护性非常高，而且标签支持自动生成自动维护；\n\n基于此标签化管理方案，YouQu 支持灵活的用例组织方式，而且标签参数支持使用 and/or/not\n逻辑组合，非常符合语义，根本不需要对使用方法做大量文档说明，使用者就能立马 get 到它的用法。\n\n\n高级日志记录功能#\n\n\nAvocado#\n\n特点是能记录所有的日志，生成日志文件。\n\n\nYouQu#\n\n全自动日志系统，只需要一个装饰器，自动输出全部日志，并保存到日志文件。《YouQu 日志系统》\n\n\n小结#\n\nAvocado 的日志模块看似平平无奇，实则司空见惯，而 YouQu 的日志系统，全自动输出日志系统。\n\n\n配置#\n\n\nAvocado#\n\nAvocado 存在多个配置文件：\n\n * /etc/avocado/avocado.conf 这是一个系统级别的配置文件，对所有用户生效；\n * /etc/avocado/conf.d/*.conf 这个目录下也可以放配置文件，也是一个系统级别的配置文件；\n * ~/.config/avocado/avocado.conf 用户级别的配置文件；\n\n用户配置文件的配置项可以覆盖系统级别的配置文件的配置项。\n\n测试执行时配置项的优先顺序：\n\n命令行参数 > 用户配置文件 > 系统配置文件；\n\n\nYouQu#\n\nYouQu 的配置文件只有一个，setting/globalconfig.ini ，提供一个全局配置对象 conf，使用此对象可以访问全局配置里面的所有配置；\n\n比如：\n\n\n\n基于 YouQu 的子项目里面会有一个局部配置文件 config.ini，提供一个配置对象 config，使用此对象可以访问 局部配置 + 全局配置\n的所有配置；\n\n比如：\n\n\n\n局部配置的值可以覆盖全局配置值；\n\n测试执行时配置项的优先顺序：\n\n命令行参数 > 局部配置 > 全局配置；\n\n\n小结#\n\n两个框架的配置体系整体设计思想是类似的。\n\nAvocado 的系统配置可能存在多个，看似可配置项很多，实际不好管理，YouQu 的配置理念是 All in One，简洁优雅永不过时。\n\n\n自定义依赖项#\n\n\nAvocado#\n\nAvocado\n的依赖的概念实际上是用例前置条件（setup）的概念，简单讲就是这条用例执行之前可能需要处理以下依赖环境，比如装一些个三方包或者获取测试资源等等。\n\n依赖项定义方式是在用例类说明里面写注释：\n\n\n\n固定格式 :avocado: dependency= ，和标签管理那里一样，维护性太差。\n\n\nYouQu#\n\nYouQu 的前置条件处理支持了非常灵活的写法，参考 Pytest Fixture 写法，除了生孩子，你可以在前置条件里面做任何想做的事情；\n\n除此之外，尽管 YouQu 致力于将用例需要的所有依赖项在环境部署阶段都初始化好，但 YouQu 仍然支持子项目对测试环境部署进行定制依赖项 。\n\n\n小结#\n\nAvocado 对于依赖项的处理是用字符串硬编码，分布在各个用例脚本里面，而 YouQu 的环境依赖处理，在灵活性和易维护性上无可比拟；\n\n\n总结#\n\n对比功能点      AVOCADO   YOUQU\n驱动方式       😄        😄\n测试报告       ✗         ✓ 略胜三筹\n收集系统数据     😄        😄\n批量运行用例     ✗         ✓ 略胜三筹\n高级日志记录功能   ✗         ✓ 略胜三筹\n配置         😄        😄\n自定义依赖      ✗         ✓ 略胜三筹\n插件         ✗         ✓ 略胜三筹\n\nAvocado 基于 unitttest 来管理和驱动用例执行，YouQu 基于 Pytest 来管理和驱动用例执行，Pytest 比 unittest\n本身具有技术优势，从技术上讲 YouQu 是天然兼容 Avocado 的用例的，反之则不然，再加上 YouQu\n在此之上加入了许多自研功能，比如：用例标签化管理方案、全自动日志系统、用例失败录屏，在整体技术架构上不能说是更胜一筹，只能说是属于两个时代的产品。\n\nAvocado 还支持一些内置插件和三方插件，但插件这块且不提 YouQu 有自己的生态插件，咱就说 Pytest 社区就有海量的插件，Avocado\n可以说完全不再一个级别，相当于是地球人遇到三体人。\n\nAvocado 主打 Linux CLI 测试这块，底层方法模块在 Linux 内核、命令这块确有独到之处，底层方法基于 Python 与 Linux\n进行交互，易于移植，但框架技术架构上没有任何优势；\n\nYouQu 主打在 Linux 操作系统桌面应用 UI、接口自动化这块，添加一些 Linux CLI 相关底层功能很容易，在框架技术架构、\n以及各功能方面几乎是全面碾压 Avocado。","routePath":"/技术文档/技术调研/《Avocado和YouQu对比》调研报告","lang":"","toc":[{"text":"驱动方式","id":"驱动方式","depth":2,"charIndex":190},{"text":"Avocado","id":"avocado","depth":3,"charIndex":198},{"text":"YouQu","id":"youqu","depth":3,"charIndex":259},{"text":"小结","id":"小结","depth":3,"charIndex":484},{"text":"多种格式的测试报告","id":"多种格式的测试报告","depth":2,"charIndex":521},{"text":"Avocado","id":"avocado-1","depth":3,"charIndex":534},{"text":"YouQu","id":"youqu-1","depth":3,"charIndex":662},{"text":"小结","id":"小结-1","depth":3,"charIndex":731},{"text":"收集系统数据","id":"收集系统数据","depth":2,"charIndex":901},{"text":"批量运行用例","id":"批量运行用例","depth":2,"charIndex":1128},{"text":"Avocado","id":"avocado-2","depth":3,"charIndex":1138},{"text":"用例标签","id":"用例标签","depth":4,"charIndex":1177},{"text":"筛选用例执行","id":"筛选用例执行","depth":4,"charIndex":1253},{"text":"YouQu","id":"youqu-2","depth":3,"charIndex":1505},{"text":"用例标签","id":"用例标签-1","depth":4,"charIndex":1513},{"text":"筛选用例执行","id":"筛选用例执行-1","depth":4,"charIndex":1834},{"text":"小结","id":"小结-2","depth":3,"charIndex":2133},{"text":"高级日志记录功能","id":"高级日志记录功能","depth":2,"charIndex":2510},{"text":"Avocado","id":"avocado-3","depth":3,"charIndex":2522},{"text":"YouQu","id":"youqu-3","depth":3,"charIndex":2554},{"text":"小结","id":"小结-3","depth":3,"charIndex":2612},{"text":"配置","id":"配置","depth":2,"charIndex":2671},{"text":"Avocado","id":"avocado-4","depth":3,"charIndex":2677},{"text":"YouQu","id":"youqu-4","depth":3,"charIndex":2936},{"text":"小结","id":"小结-4","depth":3,"charIndex":3179},{"text":"自定义依赖项","id":"自定义依赖项","depth":2,"charIndex":3278},{"text":"Avocado","id":"avocado-5","depth":3,"charIndex":3288},{"text":"YouQu","id":"youqu-5","depth":3,"charIndex":3452},{"text":"小结","id":"小结-5","depth":3,"charIndex":3607},{"text":"总结","id":"总结","depth":2,"charIndex":3683}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":49,"title":"可用于UOS桌面应用性能自动化工具的调研","content":"#\n\n\n相关术语#\n\n缩写          全称                           描述\nSSIM        Structural SIMilarity        结构相似性，是一种衡量两幅图像相似度的指标。\nPSNR        Peak Signal to Noise Ratio   峰值信噪比，是一种评价图像的客观标准。\nKeras       Keras API                    一个用 Python 编写的高级神经网络 API。其目的是支持友好、快速的实验\nStagesepX   stage sep(aration) x         轻量化的、基于图像处理与机器学习的、全自动的视频分析工具\n\n\n问题#\n\n我们知道，应用界面响应速度是衡量应用综合性能的重要指标之一。\n\n在传统的生产过程中，人们通常采用以下方法来获取应用性能数据：\n\n * 数据埋点\n   \n   在应用运行的过程中，分别打上起点和终点，通过差值拿到耗时数据。\n\n * 掐表\n   \n   在鼠标点击应用后按下秒表，等待应用加载结束后，停止秒表，从而得出耗时数据。\n\n * 肉眼观察\n   \n   通过肉眼观察的形式，得到用户感知最真实的数据。\n\n * 录屏分帧\n   \n   这也是最常见的一种方案。测试人员拿手机或录屏工具录制好视频，通过分帧工具对视频分帧，一帧一帧去查看整个过程，查找首尾帧，最后通过帧数来计算耗时。\n\n在我们日常应用的性能测试过程中，测试人员大多采用录屏分帧的方法，该方法存在两个问题:\n\n 1. 耗时巨大。追其原因，是因为在我们测试过程中，需要测试的系统架构较多、操作繁琐，长时间的数据收集和分析会占用大量的时间。\n 2. 数据的准确性也可能存在不稳定的因素。原因是由于测试人员拍摄视频时，拍摄设备的曝光度不同，会导致对首尾帧的判断出现误判。甚至有时候，因为测试人员的主观判断\n    ，对于测试数据的误差达到了20%以上。\n\n\n现状#\n\n如果我们想要提高测试效率，减少工作中的冗余杂乱，必然需要寻找一种性能测试方案来解决性能测试的资源消耗问题。\n\n而且就目前的性能测试趋势来说，测试人员以后需要覆盖的性能平台越来越多，而且需要测试的性能指标也越来越多，这对于仅仅只靠人力测试的方式来说是致命的，不管是增加人力\n，还是增加测试时间来说，都无疑增加了项目成本，所以我们需要探索一个即能节约时间，也能节省人力的方案。\n\n当前受到大家认可并且广泛使用的，有如下几个方案：\n\n方案一：继续沿用传统测试方式，录制视频分帧计时\n\n这是现在最精准的性能测试方案，具体的操作流程如图1所示：\n\n![](/可用于UOS桌面应用性能自动化工具的调研.assets/图1 录屏分帧流程.svg)\n\n这里就拿冷启动来举例，整个过程如图2所示：\n\n![image-20210311193848186](可用于UOS桌面应用性能自动化工具的调研.assets/图2 冷启动过程.png)\n\n等我们一次次拍摄完毕后，我们才会使用解帧工具进行分帧操作，然后再一张张图片的找到首尾帧，过程看似比较简单，但是其实是比较繁琐且复杂的。\n\n这种方法的优点就是不会占用系统资源，不会影响测试结果的准确性，可是事实上这种方式可能会导致数据的不稳定性，首先对于拍摄设备来说，每个人使用的手机不同，录制视频的\n质量不同，拍摄角度、拍摄手法也不同，录制视频时，摄像头会因为屏幕的光线和外界的灯光，使录制出来的视频辨认程度大大降低，实际拍摄效果如图3所示：\n\n![image-20210311194411329](可用于UOS桌面应用性能自动化工具的调研.assets/图3 低辨识度效果.png)\n\n这张图是看图启动时分帧结果中，UI界面出现的第二张图片，从图上可以看到很多细节都不能看见，本着对性能测试的精准性考虑，这张图就不能作为尾帧来使用，因为看图出来时\n，手机摄像头要重新聚焦屏幕，致使无法确定看图是否界面已经加载完毕，这样就导致分帧出来的结果会存在较大的偏差，不能得到最真实的启动数据，所以我们就需要选择界面很清\n晰的图片选来使用，清晰的效果如图4所示：\n\n![image-20210311200159058](可用于UOS桌面应用性能自动化工具的调研.assets/图4 高辨识度效果.png)\n\n这种情况我们通过统一的规范要求来进行避免，使用统一的三脚架，统一的拍摄手法，统一的选图标准，来提升测试结果的准确性；我们通过日常实践证明，这确实可以提升性能测试\n数据的准确性；可是缺点也是很显而易见的，使整个性能测试周期延长，影响项目进度。\n\n其实整个测试过程中，不仅仅是拍摄过程需要大量的时间，数帧也需要大量的时间，性能测试采用的分帧策略是1秒钟的视频分帧成33张图片，一帧图片的误差的时间只有33.3\nms，对于准确度毫无疑问是很精准的。对于冷热启动来说，耗时少图片数量也少，一般视频长度也就5秒钟左右，只需要查看一二百多张图片就能完成找帧的工作，但是性能测试中\n也有很多很耗时的指标，视频长度往往需要十几秒，甚至几十秒，那么图片的基数就会变得很大，那么找帧工作就会很耗时，如图5所示，看图性能测试指标中的加载40MB图片的\n性能素材目录：\n\n![image-20210312094400713](可用于UOS桌面应用性能自动化工具的调研.assets/图5 看图性能素材.png)\n\n从图上可以很直观的看到目录中的总文件数为4004项，要从这些图片中找到首尾帧，不用想肯定是一件很耗时的事情，而且测试人员通常是每一个指标，拍摄至少7组视频，也就\n是说一个平台上面相当于就有28000张图片需要进行首尾帧的筛选，可见这个过程是一个很繁琐的工作。\n\n多媒体所有的应用，或多或少都会有比较耗时的指标，整个性能测试测试下来，每个应用在每个平台上所需要查看的图片均在40000张及以上，像文管这种指标繁多的应用，甚至\n是有十几万张图片需要筛选。\n\n所以纵观整个方案一，优点是精准度较高，但是最明显的缺点就是耗时巨大。\n\n方案二：使用time命令启动应用，直接得到性能数据\n\nLinux本身就提供了time命令，可用于性能测试的启动时间测试，还可以测量内存、I/O等的使用情况。我们可以直接使用命令time来开启应用，比如开启看图测试看\n图的启动时间，如图6所示：\n\n![image-20210312130549426](/可用于UOS桌面应用性能自动化工具的调研.assets/图6 time命令获取应用启动时间.png)\n\n在图中我们可以清晰的看见三个时间项，分别是real真实时间，user用户时间，sys系统时间，启动时间我们可以理解为用户时间加上系统时间，从图中可知是97毫秒，\n这个方法可以很快速的获取应用的启动时间，避免了录屏分帧的时间消耗，比方案一节约了不少时间上的消耗。\n\n可是这个数据其实是不真实的，也是不准确的，我们依据方案一中的看图冷启动来看，分帧录屏与time命令之间差距为100ms左右，这对于毫秒级别的速度来说误差已经很大\n了，通过命令来开启应用，实际上与在桌面双击打开，以及dock栏打开完全是不一样的，我们知道从不同地方去调起应用，都是通过不同的接口，在调用接口之前，桌面或doc\nk栏需要先将自己的程序跑完，然后才会调用接口，跟终端的代码执行时间肯定是不一样的，我们用户真实感受的时间，应该是图7所示的代码执行顺序：\n\n![image-20210318134004406](/可用于UOS桌面应用性能自动化工具的调研.assets/图7 time命令获取启动时间流程.png)\n\n只有从桌面或者dock栏来测试应用的启动时间，才是最贴近用户使用的，而这个time命令最大的缺点就是与用户使用场景是有冲突的，所以只从这一个方面看来就并不是很适\n用当前的性能测试策略。\n\n其次，这个命令只能单一的启动程序，不能做一些其他较为复杂的操作，可我们的性能指标，不仅仅只是冷热启动，还有各式各样的操作，所以这种测试方法就显得很不实用，不能覆\n盖所有的测试场景，所以这种方案也不是目前的最优解。我们简单的来看一下文件管理器和相机的性能测试指标，如表2所示：\n\n相机文件管理器                     相机\n文管首次启动应用响应时间（ms）            首次启动应用响应时间-插摄像头（ms）\n文管非首次启动应用响应时间（ms）           非首次启动应用响应时间-插摄像头（ms）\n回收站非首次启动响应时间（ms）            首次启动应用响应时间-不插摄像头（ms）\n复制2G大小文件（盘内）（ms）            非首次启动应用响应时间-不插摄像头（ms）\n复制2G大小文件（盘外）（s）             摄像头切换，画面预览展示时间（ms）\n复制一个包含1000个文件的文件夹（盘内）（ms）   启动内存占用值-插摄像头（MB）\n复制一个包含1000个文件的文件夹（盘外）（s）    启动CPU占用（占比趋势）\n启动内存占用值（MB）                 \n启动CPU占用率（占比趋势）              \n\n可以很直观的看出，我们不仅仅需要冷热启动的时间，更需要其他用户可能使用到的功能上的性能指标，所以time命令测试性能的方式太过于局限化和理想化，并不能贴近实际生\n活，更不能代表用户的体感，当然这种方式也不是很无用，测试人员在平常测试中可以当成一个性能参考值。\n\n所以纵观整个方案二，其实并不太适合现在的性能测试环境，唯一的优点就是能立马获取启动时间，其他的缺点也是显而易见，无法适应更多的测试指标，无法保证测试结果的精准度\n。\n\n方案三：在程序中增加埋点，通过埋点触发的时间差来计算时长\n\n这个方法也就是在应用的代码上增加一个埋点，代码运行到埋点处打一个时间戳，再运行到下一个埋点处又打一个时间戳，这两个时间戳的差值，就是时间差值，整个流程如图8所示\n：\n\n![image-20210312163002792](可用于UOS桌面应用性能自动化工具的调研.assets/图8 埋点获取启动时间流程.png)\n\n这个方法首先需要开发更改代码，在相应的地方增加埋点，然后再进行测试，这个方法其实和方案二比较相似，都是站在计算机的角度去测试时长，并没有站在用户只会使用眼睛感受\n的角度，此方案还有一个缺点就是性能测试版本与用户使用版本是不一样的，这也导致了测试指标可能是不真实的情况，版本都不是一个版本，又从何处去保证性能是一个性能呢，而\n且纵观之前的测试数据来说，数帧时间与埋点时间差值也是超过了100ms，所以也是十分不准确的。\n\n其次，计算机执行代码是一行一行执行的，增加了很多个埋点在其中，对性能肯定是有影响的，从根本上就不能保证这个时间的准确性，而且计算机渲染也有时间问题，应用代码执行\n到了开启的那一行，可是渲染可能只渲染了一个窗口框架出来，这样肯定是有时间差距的，与time命令一样，与用户的感受是背道而驰的。\n\n只是这个方案比time命令好的就是，它可以适应所有的性能指标，需要什么就在固定的位置增加埋点，通过时间差确实可以获得近似真实的性能值，之前测试性能指标确实也用了\n一段时间这种方法，可是最后之所以没有使用，就是因为使用应用的性能测试版本获得的性能测试结果，与真实用户使用的应用版本的结果偏差较大，所以经过实践，这种方法确实不\n是最优解，最多也就只能当成参考值。\n\n所以纵观整个方案三，优缺点与方案二类似，可以解决耗时问题，可是对于更加重要的准确度却是力不从心，也不太适合现在的性能测试环境。\n\n总结： 现目前这三种方案，都是各有优劣，方案二和方案三缺点很相似，最主要都是精准度不高。三个方案的优缺点如表3所示：\n\n方案   优点     缺点\n1    精准度高   耗时长\n2    耗时短    覆盖性能指标少，无法贴近用户习惯，精准度不高\n3    耗时短    精准度不高\n\n在目前的测试环境下，方案二和方案三，明显不符合性能数据精准度的要求，对方案一进行优化，解决其耗时长的问题，是目前我们迫切需要的，所以使用图像处理技术优化方案一的\n耗时问题，是目前来说的最优解。\n\n\n技术方案#\n\n经过调研，我们决定采用一种基于图像处理与机器学习的自动化视频分析方案\n——StagesepX。StagesepX是一个轻量化的、基于图像处理与机器学习的、全自动的视频分析工具。它完全开源，并且提供了丰富的可定制性，能够根据你的实际\n需求分析视频并将其拆分为一系列阶段。在此之后，你可以清晰地得知视频包含了几个阶段、以及每个阶段发生了什么。而这一切都是自动完成的。\n\nStagesepX整个测试过程包括以下几个阶段：\n\n 1. 录制测试视频\n 2. 视频分帧\n 3. 判定稳定区间\n 4. 训练模型\n 5. 预测分析\n\n它可以实现全自动处理视频并且给出我们需要的数据。StagesepX通过我们录制的视频，来训练一个可用的模型。利用该模型，可以对我们日常测试中录制的视频进行预测分\n析，从而得到一个我们想要的结果。我们可以用一个简单的流程图来描述我们整个测试过程，如图9所示：\n\n![image-20210315102017036](/可用于UOS桌面应用性能自动化工具的调研.assets/图9 StagesepX工作流程.png)\n\n\n整体设计#\n\n在StagesepX的应用过程中，每个阶段将承担不同任务。我们需要了解每个阶段StagesepX到底做了哪些工作，我们将怎样去运用它。\n\n录制测试视频#\n\n不管是运用常规的性能测试方法，还是运用自动化去进行冷热启动的性能测试，我们都需要进行视频录制。在日常测试中，我们通常采用外部设备来进行录制。对于我们肉眼来说，我\n们可以主动判断当前帧的情况，决定其能否作为首帧或尾帧。而对于机器来说，外部设备录制的视频由于光线、清晰度、抖动等因素，会对SSIM值产生严重的影响。因此，我们需\n要更加稳定的视频。\n\n我们对Linux平台下的视频录制工具做了大量的调研，先后验证了UOS截图录屏、FFmpeg、SimpleScreenRecorder、Guee等工具的录屏效果以\n及开启工具后是否会对我们应用本身的启动造成影响。调研结果显示：UOS截图录屏因为使用了FFmpeg，在MIPS平台和ARM平台启动录屏功能后，CPU占用分别达到\n了200%和120%，导致系统卡顿，影响应用本身启动性能；而直接使用FFmpeg，无法在MIPS架构下完成录屏，大量的丢帧导致视频不能正常使用；SimpleSc\nreenRecorder占用大量的资源，对我们应用本身启动产生严重的影响。最后我们采用了UOS商店的第三方录屏软件Guee（在X86架构也可以使用UOS截图录屏\n，为方便获取实验数据，这里统一使用Guee进行实验验证），该应用在MIPS平台启动录屏后，稳定状态CPU占用约为70%，综合来说对应用的影响最小。\n\n我们在各架构下，选取了4个UOS应用，分别使用外部录屏工具和Guee工具在相同的条件下进行录屏，分帧后对两者的结果进行对比，确保录制的视频能够被我们使用。如图1\n0所示，为对比结果：\n\n![image-20210313140043366](可用于UOS桌面应用性能自动化工具的调研.assets/图10 外部设备与Guee录屏结果对比.png)\n\n从结果来看，在各架构下使用Guee工具录屏，对于各应用有一定的影响，但是在我们可接受的范围内。\n\n视频分帧和判定稳定区间#\n\nStagesepX将一个视频文件分成不同的阶段，并保存在本地文件夹中，每个文件夹被认为是一个\"稳定阶段\"。而处于\"稳定阶段\"内的图像，又被认为是非变化状态的。判\n定\"稳定阶段\"的标准是根据设定的SSIM值，如果两张图片的SSIM值小于我们到设定值，则被认为是稳定的，将被归类在同一个文件夹。举个例子，我们将一个录制好的视频\n文件，通过StagesepX进行处理，具体实现过程如下：\n\n\n\n分割以后，我们可以进入到本地文件夹，查看分帧结果，大致呈以下状态，如图11所示：\n\n![image-20201127223209052](/可用于UOS桌面应用性能自动化工具的调研.assets/图11 StagesepX分类结果.png)\n\n我们可以看到，StagesepX将我们的视频分解为不同的文件夹，每一个文件夹是一个阶段。在每一个文件夹内，又包含不同的图片，图片名称包含了视频帧率、图片编号以及\n该图片对应视频时间的时间戳。在每个阶段内，所有图片的变化都被认为是\"相对稳定的\"。但是通过我们的实际观察，情况并非如此。用通俗的话来讲，它讲视频文件切得过太过于\n\"细\"了。很多我们认为应该在一个阶段的图像，被它分为了两个阶段。为什么会发生这种情况呢？因为在StagesepX工作过程中，主要通过对比相邻图片的ssim值来进\n行划分。在我们肉眼观察中，两张图片也许很相似，但是机器很容易发现其中的区别，所以这两张图片被分为了2个阶段。这个时候，我们需要使用人工的方式，对所有图片进行主观\n上的划分，将其分为我们认可的不同阶段，后续我们会结合实际例子进行说明。\n\n那么为什么我们要将图片进行分类呢？这就是StagesepX的下一个阶段——模型训练\n\n模型训练#\n\n上面我们将分割的图片进行了手动分类，接下来需要实现下一个步骤——模型训练。在训练过程中，我们使用了由Python编写的开源人工神经网络库Keras来进行模型的建\n立。由于我们只使用了Keras的最基本的功能，就不过其进行更深的介绍；而至于SVM分析方法，由于其精准度没有Keras高，所以我们不做过多的概述。\n\n训练的过程如下，我们需要利用Keras读取我们分类好的图片，来训练一个简单的模型，并将其保存在本地。\n\n\n\n训练成功后，我们可以在本地看到生成了对应的keras_model.h5文件，如图12所示：\n\n![image-20201127231457018](可用于UOS桌面应用性能自动化工具的调研.assets/图12 模型训练结果.png)\n\n通过查询我们知道，H5文件是一种用于存储科学数据的一种文件格式和库文件，用以存储和组织大规模数据。有机会我们可以对其进行更深入的了解，这里暂时不做更多描述。\n\n模型训练好以后，我们可以录制一个视频，来验证模型的可用性和准确性，然后我们就可以开始进行正式的测试了。\n\n预测分析#\n\n使用Keras，加载我们训练好的模型，然后加载我们需要的测试素材。Keras会按照模型对我们的测试素材进行处理，将其分为多个\"稳定阶段\"。测试的过程如下所示，我\n们只需要加载我们训练的模型，来对即将测试的视频进行预测分析。\n\n\n\n至此，StagesepX完成了一次工作周期。我们可以从生成的report.html查看应用的变化情况，获取我们想要的数据。如下图所示：图片记录了我们执行点击操作\n后，右键菜单逐渐消失的过程，直到应用界面完整的加载出来，并且保持稳定。如图13所示：\n\n![image-20201127235314988](可用于UOS桌面应用性能自动化工具的调研.assets/图13 报告中记录的应用启动变化过程.png)\n\n另外，StagesepX记录了应用启动的过程，并以不同的阶段进行展示。同时记录了每一个阶段的变化情况和耗时。我们可以从下图中，看到区间的变化以及耗时情况，如图1\n4所示：\n\n![image-20201127235349053](可用于UOS桌面应用性能自动化工具的调研.assets/图14 应用启动变化状态及阶段耗时.png)\n\n\n关键技术#\n\n视频预处理#\n\n由于拍摄设备的不稳定和不确定性，会出现录制的视频出现帧不稳定的情况，具体表现为每一帧的时长不恒定，我们可以通过以下图片进行简单的理解，如图15所示：\n\n![](/可用于UOS桌面应用性能自动化工具的调研.assets/图15 帧数变化例子.svg)\n\n可以看到，通过软件录屏时，软件对图像进行抓帧。都是一帧图像，但是其实际时长并不是恒定的，这会影响机器的分析结果，导致我们最终的数据出现误差。为了解决这个问题，我\n们需要先通过FFmpeg对视频进行预处理。而经过FFmpeg处理的视频，只对其fps进行了重整，对于整个测试过程来说，是没有任何影响的。具体方法如下：\n\n\n\n经过处理的视频，都以稳定的帧数进行呈现，更加利于我们的测试工作。\n\nHook方法#\n\nHook的作用是忽略图像某一区域的变化。忽略之后，该区域不作为判定稳定性的依据。举个例子，UOS应用中，影院会播放视频。我们每次录制的视频，可能会导致Stage\nsepX认为其出现了多个不稳定阶段，而播放的视频往往不是我们的关注点。这个时候，我们就可以使用Hook方法将视频区域屏蔽。实现方式如下：\n\n\n\n相对应的，StagesepX提供了CropHook函数，该函数的作用是只关注图像某一区域的变化，并将该区域判定为稳定阶段的依据。使用方法与上面相同。\n\n更多参数的介入#\n\n参数名称             作用                                                             默认值    取值范围\nblock            block                                                          2      [1, +∞)\n                 能够对每帧进行切割并分别进行比较，计算出更加敏感的ssim值。block值默认为2，即切为4宫格；若为4，即切为16宫格\n                 ，以此类推；为1即不做切割，全图比较\nthreshold        根据ssim判定阶段是否稳定的阈值，越高则越严格（判定为稳定的区间更少）                           0.95   [0, 1]\npsnr_threshold   利用 psnr                                                        None   (0,1)\n                 进行增强型的检测，设定后，它将对被认为stable的区间进行二次检测。例如，设定为0.5时，稳定区间的条件将变为：ssi\n                 m > 0.95 and psnr > 0.5\noffset           offset主要用于弥补在变化过程中，有一些变化不大的相邻帧被判定为稳态，导致连续变化过程被切割成多个部分的情况。如果将   None   [0, +∞)\n                 offset设置为2，StagesepX会自动拟合在变化过程中长度小于等于2的稳定区间，使变化过程能够完整呈现\nprune            prune被用于去除重复阶段。设置为0.9时，如果两个stage相似度超过0.9，他们会合并成一个类别            None   (0,1)\nlimit            limit 能够过滤掉一些过于短的阶段（你可以用它忽略一些持续时间较短的变化）。例如填入5，持续区间短于 5*step    none   [1, +∞)\n                 的会被忽略\ncompress_rate    影响保存图片的缩放倍数，影响我们分析最后结果。默认为0.2，即将图片缩放为0.2倍                      0.2    (0, +∞)\n\n\n实验验证#\n\n\n视频录制#\n\n以UOS相册应用为例，我们使用Guee工具，在MIPS平台录制一个应用的启动过程。录制完毕后，使用FFmpeg对视频进行预处理，使其恒定为30FPS。\n\n\n视频分帧#\n\n通过我们预先写好的代码来对uos_demo.mp4进行分帧。分帧结果如图16所示：\n\n![image-20201128012655572](可用于UOS桌面应用性能自动化工具的调研.assets/图16 分帧结果.png)\n\n\n人工分拣#\n\n分帧好的图像素材，并不符合我们的预期。通过我们平常的测试经验，可以知道，在相册应用的启动过程中，分为以下几个稳定阶段：\n\n * 桌面停留阶段：此阶段，鼠标在桌面停留，不做任何操作。\n\n * 唤起dock栏右键菜单：此阶段，通过鼠标右键，点击dock栏相册图标，唤起右键菜单，不做其他动作。\n\n * 应用加载完成：此阶段，应用界面加载完成，并保持稳定状态。\n\n根据以上经验，我们通过人工，将分解的视频文件分为以上3个稳定阶段。分拣后的效果如图17所示：\n\n![image-20201128013400741](可用于UOS桌面应用性能自动化工具的调研.assets/图17 分拣后的稳定阶段.png)\n\n\n模型训练#\n\n我们通过分拣好的素材，利用Keras将其训练成测试模型。需要提到的是，在训练过程中，并没有可用的参数。所以我们只要保证模型能训练成功即可。如图18所示：\n\n![image-20201128013635943](可用于UOS桌面应用性能自动化工具的调研.assets/图18 模型训练结果.png)\n\n训练好的模型将保存在本地，供我们使用。模型训练也是整个过程中最简单的一步。\n\n\n结果预测#\n\n经过多轮试验，我们发现：使用不同的参数，SSIM值都会发生改变，直接影响StagesepX对于“稳定区间”的判断，导致测试结果发现误差。最后，我们找到了最佳的参\n数配置组合：\n\n\n\n\n\n\n\n\n\n同时，为了不影响我们分析结果，我们将compress_rate参数调整到了0.4，方便我们对图像进行分析。\n\n利用以上参数，我们对uos_test.mp4进行测试。最终生成报告文件report.html\n\n\n结果分析与数据提取#\n\n通过浏览器打开report.html，我们可以看到以下结果，如图19所示：\n\n![image-20201128020311924](可用于UOS桌面应用性能自动化工具的调研.assets/图19 应用启动变化过程.png)\n\n根据我们的测试经验，我们需要的数据是：从点击【打开】按钮后，到界面加载结束的时间。\n\n通过分析结果，我们可以看到，应用加载过程中第一个不稳定阶段为鼠标在桌面移动的阶段。此阶段由于鼠标不断移动，StagesepX认为该阶段不稳定。\n\n第二个不稳定阶段为dock栏右键点击应用后，右键菜单弹出的过程。这个阶段有较为明显的变化。\n\n第三个不稳定阶段为鼠标点击【打开】按钮后，直到页面加载完成的过程。我们通过截取此阶段详细图来了解一下该过程，如图20、图21所示：\n\n![image-20201128021601300](可用于UOS桌面应用性能自动化工具的调研.assets/图20 点击启动后的变化过程.png)\n\n![image-20201128021615033](可用于UOS桌面应用性能自动化工具的调研.assets/图21 应用加载过程.png)\n\n通过图片，我们可以看到点击【打开】按钮后，dock栏右键菜单逐渐模糊，到应用主界面加载完成的过程。而这正是我们所需要的！\n\n既然了解了此过程，我们只需要写一段代码，对html文件的数据稍加提取\n\n\n\n\n\n通过打印第三个unstable的数据，我们得到了以下结果，如图22所示：\n\n![image-20201128022056650](可用于UOS桌面应用性能自动化工具的调研.assets/图22 测试结果.png)\n\n对比传统测试的结果(230ms)，我们发现，通过StagesepX获得的数据，与我们预期的结果仅有一帧(30ms)的差距。这是一个让我们感到惊喜的结果！\n\n\n小结#\n\n通过StagesepX实现自动化的视频处理，可以很大程度上提高我们的测试效率。目前测试人员完成一个应用的性能测试，需要依次在各个架构进行测试，耗费1-2天的时间\n。如果使用StagesepX来完成任务，可以多个架构任务并行，这样完成任务大概只需要消耗1/2的时间；同时可以解放更多的人力，投入到其他测试工作中。从测试结果来\n看，它产出的结果能够满足我们测试人员的需要，解决了我们以下难题：\n\n * 效率低下，投入时间太高。\n\n * 重复劳动，获取测试数据。\n\n从长远来看，StagesepX具有以下优缺点：\n\n编号   优点                  缺点\n1    可二次开发，定制性强          对于机器的CPU、内存要求较高\n2    具备实现多架构同时性能自动化的能力   视频解析时间较长\n3    测试数据稳定可靠，不带有主观偏见    需要较多的测试素材来构建、完善测试模型\n\n诚然，StagesepX是个比较成熟的工具，经过实验论证，有实现性能自动化测试的能力，但是前期视频的录制仍然是我们当前的难点和痛点。我们调研了所有的多媒体应用，\n在MIPS和ARM架构，使用第三方视频录制工具会对部分应用性能产生较大的影响，如影院、相机等这类资源占用较高的应用。目前我们初步有了新的解决方案：使用视频采集卡\n。利用采集卡，将A电脑的视频信号，输出到B电脑，利用B电脑的性能，来处理接受到的视频信号，实现不占用A电脑资源的录屏。如图23所示：\n\n![image-20210313161954272](可用于UOS桌面应用性能自动化工具的调研.assets/图23 采集卡工作流程.png)\n\n当然，这其中也许会有其他问题，如：Linux系统的支持、驱动问题等，都等待我们去深入调研。\n\n\n参考资料#\n\n图像分类、AI 与全自动性能测试\n\n全自动化的抖音启动速度测试\n\nStagesepX源码","routePath":"/技术文档/技术调研/《可用于UOS桌面应用性能自动化工具》调研报告","lang":"","toc":[{"text":"相关术语","id":"相关术语","depth":2,"charIndex":3},{"text":"问题","id":"问题","depth":2,"charIndex":332},{"text":"现状","id":"现状","depth":2,"charIndex":845},{"text":"技术方案","id":"技术方案","depth":2,"charIndex":5068},{"text":"整体设计","id":"整体设计","depth":3,"charIndex":5544},{"text":"录制测试视频","id":"录制测试视频","depth":4,"charIndex":5620},{"text":"视频分帧和判定稳定区间","id":"视频分帧和判定稳定区间","depth":4,"charIndex":6424},{"text":"模型训练","id":"模型训练","depth":4,"charIndex":7158},{"text":"预测分析","id":"预测分析","depth":4,"charIndex":7627},{"text":"关键技术","id":"关键技术","depth":3,"charIndex":8121},{"text":"视频预处理","id":"视频预处理","depth":4,"charIndex":8128},{"text":"Hook方法","id":"hook方法","depth":4,"charIndex":8456},{"text":"更多参数的介入","id":"更多参数的介入","depth":4,"charIndex":8694},{"text":"实验验证","id":"实验验证","depth":2,"charIndex":9787},{"text":"视频录制","id":"视频录制","depth":3,"charIndex":9795},{"text":"视频分帧","id":"视频分帧","depth":3,"charIndex":9880},{"text":"人工分拣","id":"人工分拣","depth":3,"charIndex":10001},{"text":"模型训练","id":"模型训练-1","depth":3,"charIndex":10310},{"text":"结果预测","id":"结果预测","depth":3,"charIndex":10507},{"text":"结果分析与数据提取","id":"结果分析与数据提取","depth":3,"charIndex":10715},{"text":"小结","id":"小结","depth":2,"charIndex":11507},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":12267}],"domain":"","frontmatter":{"Author":"张龙"},"version":""},{"id":50,"title":"命令行用例转换自动化测试调研","content":"#\n\n\n相关术语#\n\n缩写    全称                     描述\nSAT   Shell Automated Test   使用Shell实现的自动化测试\n\n\n问题#\n\n目前基于UOS专用设备系统的测试中，包含命令行模式测试和图像化页面测试，在命令行模式对应的用例中，有部分用例执行起来较为简单（操作单一、交互性弱），但是在执行起\n来却相当繁琐。\n\n而且在实际测试过程中需要覆盖多个架构进行测试，重复工作较大，一条用例最多会被执行6遍，详情数据如下：\n\n问题       内容                                                             此类用例数量   完整用例数量   此类用例占比\n执行繁琐     执行命令行模式相关用例时，需要在命令行手动执行命令，然后通过命令输出结果与预期结果对比，得出用例执行结论，过程中需要不断   283      517      54.73%\n         的输入——验证——输入——验证......。\n重复工作量大   测试过程中需要覆盖架构：AMD（Intel）、MIPS、ARM、SW，除此之外有时还需要验证AMD（兆芯）、虚拟机场景，   1698     3102     54.73%\n         综上所述，一条相同的用例，在进行全量测试时最少需要重复执行4次，最多需要重复执行6次。\n\n以上表格统计的用例数量并不能代表执行命令的数量，因为每一条用例可能包含多条执行命令，所以执行命令条数是远远大于用例条数的；除了以上目前问题（执行繁琐及重复工作）\n外，还存在以下影响效率的问题：\n\n * 专用设备系统没有图形页面，相对于桌面版裁剪了大部分功能，用例的查看与执行是在不同设备上操作，所以无法粘贴命令，只能手动输入。\n\n * 若用例负责人请假/离职，更换测试人员进行测试，因为对用例不熟悉，需要依次查看用例文档预期内容。\n\n\n现状#\n\n以上指出的问题，解决方案为把这54.73%的用例(后续称这54.73%的用例为：A类用例，另外一部分用例称为：B类用例)，从人工执行转换为自动化执行（自动执行命\n令、自动验证输出结果、自动生成测试报告），这样除了在全量测试时减少工作量，提升测试效率；还能在回归测试、边缘测试时多覆盖一定的测试范围。\n\n在Linux系统上实现自动化，首先想到的是通过Shell实现，把所有用例写到一个脚本中自动执行并判断结果即可，例如：\n\n\n\n执行以上Shell脚本即可完成对该条命令的测试，根据用例内容设计测试命令，并把命令结果赋值给变量，最后通过判断变量的情况得出结论。该方法能实现，但是当命令达到几\n百条并且后期还会继续增加时，那不管是代码编写还是后期维护都会越来越困难，会产生大量的代码冗余、内容无清晰等问题，所以该方案结论是测试内容少的时候可满足，但无法长\n远。\n\n这样看来我们需要的是一个自动化测试框架，满足自动处理/执行测试用例、自动验证输出结果、自动生成测试报告。就目前常见的自动化测试框架来说均可满足需求，确定了以下2\n个方案：\n\n * unitest：Python标准库中的单元测试框架，支持批量导入/执行用例、提供断言、初始化环境、环境清理、通过第三方库生成测试报告等。\n\n * 自行设计框架：根据目前需求，基于Shell自行编写一套适合项目的自动化测试框架\n\nShell框架和Python框架对比，Shell可直接执行系统命令，Python只能通过os、subprocess库来调用linux系统命令，在脚本的编写和调式\n都不如Shell简洁、方便。使用简单场景【查询音乐应用进程状态】的Shell、Python代码作为对比：\n\n * Python\n\n\n\n * Shell\n\n\n\n通过以上对比可发现，在Linux系统上，实现一个相同的功能，Shell编写的代码要更为直接、简洁，命令越多越复杂这个优势越明显，对于几百条用例编写代码来说更偏向\n于使用Shell。\n\n除此之外Python通过第三方库生成的测试报告格式为HTML，但是针对当前项目中的裁剪系统来说，不带GUI页面所以并不支持查看HTML的文件；Shell框架生成\n的测试报告不带图形化内容，可直接在被测系统上直观的看到测试结果并进行验证，所以对查看测试结果来说Shell框架更适合当前项目。\n\n该类测试需要的测试框架不需要很复杂，轻量级的即可，通过自行设计能更自由，更贴合项目，所以最终选定通过Shell自行设计自动化测试框架方案。\n\n\n\n\n技术方案#\n\n通过Shell实现设计自动化测试框架，命名为SAT，通过SAT主要实现现状部分所描述的需求：自动处理/执行测试用例、自动验证输出结果、自动生成测试报告。\n\nSAT自动化测试框架运行流程图如下：\n\n\n\n\n整体设计#\n\nSAT总体可以划分为下面几个模块：\n\n * 用例模块（case）：存放转换为自动化测试用例的代码，最小单位为函数，该框架支持多个用例模块文件。\n\n * 方法封装模块（method）：存放一些公用方法函数，比如：断言、测试报告等。\n\n * 启动测试模块（run_repor）：存放启动测试的主代码，对用例模块文件进行批量处理并生成测试报告。\n\n * SAT目录结构如下：\n   \n   \n\n用例模块（case）#\n\n实际项目中每个人负责的模块与用例不同，所以自动化测试用例需要自己编写负责部分，不像其他模块中的代码都是公用的，那么在编写格式上需要做统一的约定。格式统一之后，每\n人完成自己部分的用例文件，在启动测试时只要汇总全部用例模块文件，即可完成所有人的测试用例执行：\n\n * 用例模块文件命名统一，测试人员A、B的用例模块文件：case_a.sh、case_b.sh。\n\n * 测试用例最小单位统一：每一条测试用例为一条函数，通过函数来管理用例。\n\n * 用例函数命名统一，测试人员A的第1、2条用例：test_a1(){}、test_a2(){}。\n\n * 用例函数元素统一，需要包含变量：title、case_id、断言函数。\n\n方法封装模块（method）#\n\n该模块主要用于存放公共方法函数，其他模块直接调用即可，使代码更为清晰简洁，并减少冗余。封装的函数主要实现以下功能：\n\n * 用例断言：判断用例执行结果与预期是否一致，给出对应输出结果。\n\n * 用例处理：批量处理不同的用例模块文件：执行不同的用例模块文件，输出用例执行结果。\n\n * 用例统计：统计用例执行的数据：统计执行用例数量、通过用例数量、失败用例数量、失败用例编号。\n\n * 测试报告：结合以上全部内容输出本地文档，方便测试结果归档保存。\n\n启动测试模块（run_repor）#\n\n该模块为执行测试的主模块，主要是对测试开始前环境做初始化并运行测试，主要包含：\n\n * 模块初始化：导入方法模块；根据对用例模块文件的分析，导入对应的模块文件。\n\n * 变量初始化：针对一些数据统计相关的函数做初始化赋值：用例数量、用例通过/失败数量、定义数组变量等。\n\n * 运行测试：调用测试执行函数、测试报告生成函数、提示用户测试报告生成路径。\n\n\n关键技术#\n\n这里主要选取部分关键功能的设计与实现做说明：\n\n * 测试用例\n\n * 初始化\n\n * 断言\n\n * 执行测试\n\n * 测试报告\n\n测试用例文件功能#\n\n测试用例文件为管理用户用例的最小单位，每次测试至少包含1份测试用例文件，即可开始正常测试。可放入的测试文件数量无上限，可无限累加。\n\n查看测试人员A的用例模块文件 \"case_a.sh\" 部分内容：\n\n\n\n通过以上代码可看出，用例函数中包含：\n\n * 执行用例信息：用例标题、用例编号\n\n * 命令执行结果\n\n * 命令执行预期结果\n\n * 断言判断结果\n   \n   完成该条用例的测试后，针对用例末尾的assert类断言函数内部，做了特殊处理，可以收集以上所有数据为最终的测试报告提供数据支撑。\n\n初始化功能#\n\n该功能是为后续测试提供良好的运行环境，以下为初始化函数代码：\n\n\n\n通过代码分析，初始化/清理环境函数设计内容及流程：\n\n * 测试开始前执行初始化函数，为后续测试提供环境支持\n   \n   * 公共区域：针对框架本身的初始化\n     * 判断用户执行测试时是否是root用户，因为部分系统命令需要root权限，若非root用户则提示用户并退出\n     * 导入公共函数文件，提供公共函数的调用\n     * 初始化变量（变量赋值、定义变量类型），为最终的测试报告提供数据支撑\n     * 扫描测试用例文件，收集数据（包含多少份文件、每份文件包含多少条用例），为最终的测试报告提供数据支撑\n   * 独立区域：针对各测试人员，存放各自独立维护的初始化函数（比如测试人员a的，初始化函数：setup_a）\n\n * 测试结束后执行环境清理函数\n   \n   * 公共区域：针对框架本身的环境清理\n     \n     * 清理/释放测试过程中生成的垃圾文件或资源占用（该内容暂时缺失，因示例中用例暂未涉及）\n     * 根据用例执行情况返回状态：用例均为pass返回0，用例存在fail返回1，后期可配合CI/CD使用\n   \n   * 独立区域：针对各测试人员，存放各自独立维护的清理函数（比如测试人员a的，环境清理函数：teardown_a）\n\n断言功能#\n\n该功能实现的是在每条用例执行之后，对用例执行结果与预期结果对比，判断用例执行结果（通过/失败），并且对结果进行输出与数据收集。\n\n断言对比的方法多种多样，这里拿部分举例，详情见下方代码：\n\n\n\n通过代码分析，初始化设计内容及流程：\n\n * 通过判断用例的执行结果与预期结果是否一致\n * 判断输出结果，通过输出pass，失败输出fail（如底部截图）\n * 针对fail的用例id至数组变量，便于在拿到测试报告后验证复盘\n * 代码末尾的case_pf函数针对以上所有数据做了数据处理与收集（递增通过/失败/执行用例数量），为最终的测试报告提供数据支撑\n\n\n\n测试执行功能#\n\n该功能主要是实现不同用例模块中，用例的批量执行：\n\n具体代码如下：\n\n\n\n通过代码可看出，这里除了实现用例的批量执行外，还包含了一些其他设计：\n\n * 获取测试开始时间\n\n * 初始化测试报告文件（创建、命名、赋值路径）\n\n * 针对测试结果输出做了双向处理：输出至终端、输出至本地测试报告文件\n\n * 针对测试结果的输出样式做了排版，使之更为美观\n\n * 展示即将测试的用例数据（如底部截图）\n\n * 依次执行每个测试文件中的用例\n\n * 执行用例中test_result函数是处理用例执行结果，使之格式化输出\n\n\n\n测试报告功能#\n\n该功能主要实现测试结果的展示，通过分析测试结果获取失败用例信息，验证并提交Bug。同时还有一个重要作用是针对这次测试结果做归档，便于在不同时间查看本次测试结果，\n具体实现代码如下：\n\n\n\n通过分析代码，该功能工作流程为：\n\n * 通过辅助函数case_pf、test_result分散在测试过程中关键位置，收集测试过程中产生的关键数据\n * 获取测试结束时间\n * 通过测试过程中收集到的数据，汇总整理成结果呈现给用户（如底部截图）\n * 测试结果同样双向输出至：终端、本地测试报告文件\n\n\n\n\n实验验证#\n\n\n现状与方案初步对比#\n\n * 手工执行模拟：\n   \n   * 执行步骤1：命令行中输入命令touch /opt/test2.txt\n   * 验证步骤1：查看步骤1输出结果，验证结果与用例中预期是否一致\n   * 执行步骤2：命令行中输入命令stat /opt/test2.txt\n   * 验证步骤2：查看步骤2输出结果，验证结果与用例中预期是否一致\n   * 执行步骤3：命令行中输入命令cat /opt/test2.txt\n   * 验证步骤3：查看步骤3输出结果，验证结果与用例中预期是否一致\n   * 执行步骤4：命令行中输入命令ls -l\n   * 验证步骤4：查看步骤3输出结果，验证结果与用例中预期是否一致\n   * 执行步骤5：命令行中输入命令touch /opt/test2.txt\n   * 验证步骤5：查看步骤3输出结果，验证结果与用例中预期是否一致\n   * 执行步骤6：命令行中输入命令ls -l\n   * 验证步骤6：查看步骤3输出结果，验证结果与用例中预期是否一致\n\n通过手工执行以上用例，大致估算完成每个步骤（输入命令、验证结果、用户思考）的耗时为10秒，那么执行完这条用例需要的耗时为==60==秒。\n\n * 自动化执行模拟\n\n\n\n通过上面的例子可看出，测试人员手工执行耗时==60秒==的用例，若通过自动化执行该条用例，耗时只需要==6豪秒==（后续按0.01秒算），A类用例有283条，假\n设每条用例的平均耗时为60秒，那么执行耗时对比如下：\n\n\n\n通过差异数据对比，可看出A类用例从手工转化为自动化后可大量提升执行效率，相比手动执行耗时的==16980秒==，自动化执行耗时的==2.83秒==可忽略不计。\n\n完整的全量测试流程中耗时分布大致为：\n\n * 执行全测试用例：占比60%（按平时测试经验，A类用例与B类用例，执行耗时占比大致为1:4）\n\n * 分析失败用例，提交Bug单：占比15%\n\n * 验证异常情况:5%\n\n * 发散交互性测试:10%\n\n * 回归Bug，针对Bug进行边缘测试，处理Bug单:10%\n   \n   计算效率提升率：\n   \n   \n   \n   结合以上数据，可得出结论实现自动化技术后，每次全量测试，==A类用例部分==执行耗时可比之前手工测试提升效率==15%==，且能够较好解决当前面临的问题。\n\n\n模拟一次完整测试#\n\n为了演示SAT的工作流程，这里拿一个实际场景举例，本次测试需要自动化执行：测试人员A的用例5条、测试人员B的用例1条，无需执行测试人员C的用例：\n\n执行流程如下：\n\n * 收集测试人员A、测试人员B最新的测试用例文件，放入目录SAT/case/下\n\n * SAT目录下启动终端，运行命令su进入Root\n   \n   * 因部分命令需要root权限，使用sudo+命令需要提示用户输入密码，不友好。\n   * 若用户使用普通用户权限运行，则给出对应提示：请已root用户运行该脚本，点击Enter退出，并关闭。\n\n * 初始化环境：导入依赖文件、扫描测试用例文件并分析数据、变量初始化赋值/定义\n\n * 终端输出即将测试的内容\n\n * 开始测试并输出每条测试用例的执行结果\n\n * 所有用例执行完毕，整理测试过程中获取的数据\n\n * 生成测试报告：测试起止时间、电脑架构、执行用例数量、通过/失败用例数量、失败用例编号、本地测试报告存放路径\n\n * 根据测试报告中失败用例编号，验证复盘并提交BUG单\n\n * 测试完成\n\n输出结果如下：\n\n\n\n\n依赖库相关信息#\n\n库名称   版本号   描述   所使用开源协议\n暂无               \n\n\n实验代码存放地址#\n\n * gitlab\n\n\n小结#\n\nSAT实现的自动化测试，通过实验验证部分得出的结论，可看出每次全量测试，A类用例部分执行部分效率可提高15%。而且每次回归测试时，除了Bug回归和边缘测试，也可\n以自动化执行一次A类用例，就用例覆盖面来说提升了54.73%。同时解决了当前所面临的问题：\n\n * 手工测试时针对A类用例时，繁琐的输入、验证\n\n * 覆盖多个架构测试时，大量的重复性工作\n\n除此之外SAT是自行设计的，有较高的扩展性，可根据后续项目的变动对框架内容作出对应调整（优化、新增功能），而且框架是通用的，不同项目间也可以同时使用，只要按照约\n定编写测试用例代码，把用例文件放在在SAT/case/目录下，即可运行测试。\n\n再往后说，随着SAT内容越来越丰富，创新性越来越多时，可把该方案转换为对应的创新性发明专利。\n\n\n参考资料#\n\n * Linux Shell编程\n\n * 自动化测试框架","routePath":"/技术文档/技术调研/《命令行用例转换自动化测试》调研报告","lang":"","toc":[{"text":"相关术语","id":"相关术语","depth":2,"charIndex":3},{"text":"问题","id":"问题","depth":2,"charIndex":89},{"text":"现状","id":"现状","depth":2,"charIndex":831},{"text":"技术方案","id":"技术方案","depth":2,"charIndex":1891},{"text":"整体设计","id":"整体设计","depth":3,"charIndex":1999},{"text":"用例模块（case）","id":"用例模块case","depth":4,"charIndex":2200},{"text":"方法封装模块（method）","id":"方法封装模块method","depth":4,"charIndex":2525},{"text":"启动测试模块（run_repor）","id":"启动测试模块run_repor","depth":4,"charIndex":2767},{"text":"关键技术","id":"关键技术","depth":3,"charIndex":2965},{"text":"测试用例文件功能","id":"测试用例文件功能","depth":4,"charIndex":3038},{"text":"初始化功能","id":"初始化功能","depth":4,"charIndex":3300},{"text":"断言功能","id":"断言功能","depth":4,"charIndex":3885},{"text":"测试执行功能","id":"测试执行功能","depth":4,"charIndex":4172},{"text":"测试报告功能","id":"测试报告功能","depth":4,"charIndex":4441},{"text":"实验验证","id":"实验验证","depth":2,"charIndex":4698},{"text":"现状与方案初步对比","id":"现状与方案初步对比","depth":3,"charIndex":4706},{"text":"模拟一次完整测试","id":"模拟一次完整测试","depth":3,"charIndex":5700},{"text":"依赖库相关信息","id":"依赖库相关信息","depth":3,"charIndex":6184},{"text":"实验代码存放地址","id":"实验代码存放地址","depth":3,"charIndex":6239},{"text":"小结","id":"小结","depth":2,"charIndex":6262},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":6614}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":51,"title":"应用于桌面应用压力测试的模拟输入工具调研报告","content":"#\n\n\n相关术语#\n\n术语            解释\nInputDevice   支持 linux 管理不同类型、不同原理、不同的输入信息的输入设备软件体系\nMEM           MEM 是一个内存显示程序，显示所有内存驻留程序的占用情况\n输入子系统         输入子系统核心层（Input Core）、驱动层和事件处理层（Event Handler）\n\n\n问题#\n\n随着文件管理器（以下简称\"文管\"）的使用者越来越多，厂商和社区反馈了越来越多反复操作后出现概率概率性 BUG，为了对 BUG 进行复现，就需要进行压力测试。\n\n在我们日常压力测试过程中，文管测试组需要使用现有的设备进行问题复验和场景压测，设备和人力资源有限，因此，在复现和验证这些问题的过程中，存在着如下问题：\n\n 1. 耗时巨大，追其原因，是因为在测试过程中，测试复现时反复操作的顺序不同、频率不够、操作慢都可能导致Bug无法复现，整个复现周期相对较长，人力和时间耗费较多\n    。\n\n 2. 无可靠性，在遇到概率性 BUG\n    进行回归的时候，我们无法确定需要测试多少次才能确保问题已修复，而且有可能人力压力测试无法达到复现条件，没有数据支撑测试结论。\n\n因此，探索一种良好的压力测试方案，是迫在眉睫的，可以更准确的验证及回归问题，并且减少人力资源和提升测试效率。\n\n\n现状#\n\n基于上述问题，当前市面上对于应用压测存在如下几个方案：\n\n方案一：使用 Python 脚本进行场景压测\n\n使用 Python 编写压测脚本，需要使用第三方库 PyAutoGUI 和 Dogtail，PyAutoGUI 是一个纯Python 的 GUI\n自动化工具，可以用程序自动控制鼠标和键盘操作模拟用户操作行为，多平台支持（Windows，OS X，Linux）\n\n在编写脚本之前，我们首先需要准备环境，即安装 PyAutoGUI 和 Dogtail 库。\n\n开始编写一个简单压测场景脚本：循环一直新建文件夹。\n\n\n\n一个场景压测，往往不会这么简单，列举部分文管场景压力测试项如下：\n\n压测场景                压测步骤                                                           压测次数/时长\n循环执行创建，删除文件         1.在桌面/文管空白处，右键菜单2.点击“新建文件夹“3.选择新建文件夹右键”删除“                     8H\n重复打开 1000 张图片的文件夹   1.在桌面选择包含 1000 张图片的文件夹2.关闭文管                                   8H\n重复搜索目录中的文件          1.打开文件管理器，进入test目录中2.点击搜索按钮3.在输入框输入 \"test\"，进行搜索4.关闭文管          8H\n重复同时执行 10 个复制文件任务   1.在 dock 栏目右键打开 2 个文管窗口2.在 A 窗口中，选择文件右键-复制3.在 B                8H\n                    窗口中，右键粘贴4.快速粘贴 10 次5.删除B窗口的文件\n重复向桌面复制文件           1.在dock栏目打开文管2.选择一个“音乐”目录 CTRL+C 复制文件3.在桌面粘贴文件4.关闭提示弹窗5.关闭文管   8H\n\n可以很直观的看出，这些测试项的操作都较复杂。\n\nDogtail 是 Python 的三方库，它使用 Accessbility 技术与桌面应用程序通信。代码通过提前设置好的 Accessbility\n标签进行操作，但 Accessbility 标签需要开发人员提前在应用程序中添加，在下图一中看到，1021 的文管中就不存在标签，部分版本基线中该方法并不适用。\n\n\n\n通过 Dogtail 和 PyAutogui 来控制键盘、鼠标来进行应用的操作，在 Python 代码遍历寻找应用程序上可用的 Accessbility\n节点时候，过程需要 1-2S 左右，之后再执行其他操作，这个过程耗时较长，失去了压力测试本身的意义。\n\n纵观整个方案一，缺点是显而易见的，例如无法测试所有的应用版本、无法满足压力测试暴力操作的要求。\n\n方案二：使用 shell 脚本进行场景压测\n\n这个方案使用 Xdotool 工具模拟键盘、鼠标操作，Xwininfo\n工具来获取窗体属性，此方法通过窗体固有属性，找到对应坐标，之后来进行键盘鼠标操作，整个流程如下图所示：\n\n\n\nUOS 系统自带了Xdotool和Xwininfo工具，这个方法其实和方案二比较相似，方案二使用 Dogtail 定位元素位置、PyAutoGUI\n来操作键盘、鼠标，使用wininfo 获取窗体属性计算坐标，通过 Xdotool 控制键鼠操作。\n\n编写shell脚本，使用 Xodtool 工具进行简单操作，运行代码，查看图三，能看到与上述 Python 脚本同样的操作，shell脚本运行时间接近快了1s。\n\n\n\n\n\n使用 shell 脚本编写：重复向桌面复制文件，并且每次输出桌面和文管的窗口 ID(寻找窗口 ID 来获取坐标)\n测试场景，多次运行后，在下图四能看到，同一个场景同一套代码同一个机器，运行结果，极其不稳定，容易报错找不到窗口。\n\n\n\n纵观整个方案二：运行环境简单、但是运行结果不稳定。\n\n总结： 现目前这两种方案，各有优劣，都是现阶段较主流的方案，优缺点如表三所示：\n\n方案   优点                    缺点\n1    可自动化、场景覆盖多            无法适用所有版本，环境复杂、键鼠操作比较慢达不到压测效果\n2    可自动化、运行环境简单，能适用所有版本   不稳定\n\n在目前的测试环境下，方案一由于 Python 在使用第三方库的时候，程序响应往往都需要 1-2s 时间，运行速度较慢，而且无法满足所有版本的压测需求。方案二使用\nshell 脚本编写压测脚本，在运行 Xdotool 工具时候容易出错，Xdotool 工具对键鼠的操作已经算是比较快的工具了，但是在特殊 BUG\n上，鼠标操作速度还是有所欠缺，如：异步线程出错，在测试过程中，经常性会遇到这样的小概率问题、同样的操作，有时候能复现问题有时候又不能复现，BUG\n复现条件极其苛刻，需要更快的操作增加 复现概率，如下表列举部分的 BUG，在回归 BUG 就需要快速的键鼠操作。\n\nBUG编号   描述                                                        严重程度   优先级\n29689   【文件管理器】【5.1.1.63-1】【sp2】桌面空白处右键，选择“壁纸与屏保”，再快速在右键，桌面黑屏     2      2\n26972   【文件管理器】【5.1.1.39-1】在列表试图下，快速来回切换排列顺序，再点击上级栏目，文件管理器崩溃      2      2\n26100   【文件管理器】【5.1.1.33-1】4K屏幕，2.75缩放，在桌面空白处快速多次点击右键，桌面崩溃        2      2\n25591   【文件管理器】【5.1.1.31-1】鼠标左右键，快速连续一起按，桌面黑屏                     3      3\n24478   【sp1】【文件管理器】【5.1.0.8-1】拖动文件到其他目录下，快速敲击键盘“ctrl+z”出现不正确提示   4      4\n21172   【文件管理器】【5.1.0.8-1】左侧栏目快速切换，右键闪退。                          2      2\n\n因此，我们需要对方案二进行优化，找到能解决键鼠操作速度不够快和容易出错不稳定的方案。\n\n\n技术方案#\n\n在用户使用桌面应用时候，都是通过键盘与鼠标输入设备与软件交互。\n\n我们对现状中的方案二进行优化，也参考了 Xdotool 和 Xwininfo 工具的逻辑，设计一款新的应用程序，程序名称为\napp-wininfo-m，计划解决上述键鼠操作速度不够快和容易出错不稳定的问题。\n\n对于键鼠操作速度不够快的问题，了解到 Linux 输入子系统，可以通过设备驱动程序写入键鼠事件驱动设备文件来对 USB 键盘输入和鼠标移动进行操作。\n\n一个输入事件，如鼠标移动或者键盘按键事件，到达用户空间传给应用程序，如下图四流程\n\n\n\n事件处理层为不同类型硬件提供了用户访问及处理接口。在 /dev/input 目录下显示的是已经注册在内核中的设备编程接口，用户通过 open\n这些设备文件来打开不同的输入设备进行硬件操作，当打开设备 /dev/input/mice 时，会调用到事件处理层的 Mouse Handler\n来处理输入事件，这也使得设备驱动层无需关心设备文件的操作，因为 Mouse Handler 已经有了对应事件处理的方法。\n\n对于容易出错不稳定的问题，是 Xdotool 这个工具在经过长时间运行后获取窗口 ID 值出错，目前我们能接触到的 UOS 系统图形化界面都是基于 X11\n协议，Xlib 是 X11 协议的 API 实现，另外用于代替 Xlib 的新型 API 为 XCB。下图五 Xlib\n告诉我们每个窗口和像素图都有自己的坐标系，通过坐标系的位置，可以鼠标定位操作应用。\n\n\n\n\n整体设计#\n\napp-wininfo-m 自上而下的模块结构呈现如下图七：\n\n\n\n当按照这种模式设计，每个业务都比较统一有序和模块化，再扩展其他功能更加方便，不会影响到原有的功能。\n\n * keyboard-event：处理用户传入类型为 EV_KEY 的事件，将事件写入到 “/dev/input” 目录下的键盘设备文件中，上报事件和同步给\n   input 子系统中。\n * mouse-event：处理用户传入类型为 EV_REL 的事件，将事件写入到 “/dev/input” 目录下的鼠标设备文件中，上报事件和同步给\n   input 子系统中。\n * mouse-position：基于 xlib 实现获取鼠标的位置，给 app-action 层提供数据支持，监视鼠标的位置变化。\n * app-attribute：提供一个基于 xlib 获桌面应用窗口属性的集合，具体需要其他的接口，可根据实际需要自由扩展。\n\napp-action 的设计理念是一个 wrapper，从功能需求上来看，app-action 提供以下功能：\n\n * 坐标：主要业务是窗口坐标和鼠标指针位置的获取，根据用户传入的 PID 查到应用的窗口ID，获取窗口属性。\n * 键鼠：主要业务是对设备驱动文件写入键鼠事件，来进行鼠标移动、点击和键盘输入。\n\napp-wininfo-m程序运行流程如下：\n\n\n\n对应用使用者提供了友好的说明文档，程序已经帮助实现了需要的操作，使用者只需要根据说明文档传入对应的参数，执行需要的操作。以及添加简单崩溃的断言服务，通过对\ncoredump 日志监控，判断经过压力测试的应用是否出现崩溃现象，并输出结果提供给测试人员。\n\n\n关键技术#\n\n坐标服务#\n\n在坐标获取业务中，获取不同应用的坐标位置，在之前我们获取坐标的方式是通过 Xdotool 获取到Window_ID，再通过 Window_ID 使用工具\nXwininfo\n获取坐标。需要进行多个步骤操作后才能获取到坐标，在代码编写上步骤复杂，而且获取的结果不够稳定，因此找到了一个获取坐标的新方法，基本操作流程如下：\n\n根据应用的进程寻找应用的坐标位置：\n\n传入的 PID，再调用 app-wininfo-m 程序，如果 PID 不存在，则不会返回窗口的坐标等属性，如果 PID 存在，就返回窗口的坐标等属性。\n\n\n\n在编码过程中，获取窗口的坐标引入 Xlib 的头文件 #include 获取结构体：XGetWindowAttributes() 函数返回指定窗口到当前属性\nXWindowAttributes 结构。\n\n\n\n了解到 Xlib 函数，就可以围绕 XGetWindowAttributes() 函数来获取窗口属性，经过以下流程，就完成窗口的属性获取了。\n\n * 传入进程判断，获取窗口，伪代码如下\n   \n   \n\n * 对鼠标进行移动点击，程序要知道鼠标的位置，获取鼠标位置的代码如下：\n   \n   \n\n * 窗口属性的获取，伪代码如下:\n\n\n\n操作服务#\n\n在 Linux\n系统中，万物皆文件，我们的键盘和鼠标都是设备文件，经过调研，通过对设备文件写入，就可以对键盘和鼠标进行操作，这个操作是硬件操作的最快的方法，其基本流程如下：\n\n\n\n在编码过程中，对设备文件写入生效，需要引入子系统头文件 #include 获取到结构体：\n\n\n\n通过 write() 函数对 /dev/input 目录下设备文件写入，伪代码如下：\n\n\n\n最终，通过公式移动到鼠标想要的位置，如移动到应用左上角的位置（ X1，Y1 ），鼠标位置（ X2，Y2 ），鼠标相对位置 rel_x，rel_y 相对移动位置。\n\n\n\n对于键盘的操作，与上面操作类似，就需要修改参数，代码如下：\n\n\n\n\n实验验证#\n\n根据技术方案调研的结果，需要对整体设计的方案和一些技术细节进行验证，为此设计以下实验：\n\n\napp-wininfo-m 可行性和兼容性验证#\n\napp-wininfo-m\n的目的是对桌面应用坐标定位，通过输入设备的设备文件操作鼠标键盘，本次实验将按照整体设计中的方式，生成一个可以运行的程序执行文件，以通过进程获取到应用坐标，并且鼠\n标点击关闭窗口为例进行演示。\n\napp-wininfo-m 应用程序参数文件说明：\n\n参数   说明\n-m   鼠标移动位置，参数一：坐标Ｘ轴，参数二：坐标Ｙ轴，参数三：１点击鼠标左键，２鼠标中键，３鼠标右键\n-p   通过传入的进程号查找应用窗口的属性，查看所有进程下的窗口，并输出窗口属性\n-k   键盘输入，如：-k KEY_A，键盘输入A\n\n【实验环境】\n\n * 系统：UOS 20 1030\n * 架构：X86 、ARM64、MIPS64EL\n\n【实验步骤】\n\n * 安装环境\n\n 1. app-wininfo-m 代码编写完毕，在 Qt Creator 中构建制执行文件为 demo。\n\n * 编写测试脚本\n   \n   使用 shell 方式来运行 demo 程序，编写的代码如下\n\n\n\n * 运行结果\n\n查看下图运行结果，看到 通过进程获取到应用坐标，并且鼠标点击关闭窗口 演示操作的例子完美运行成功，app-wininfo-m 程序的整体方案是正确的。\n\n\n\n以上述例子运行，进行不同系统架构测试，测试结果如下：\n\n系统架构       测试结果\nMIPS64EL   正常运行\nX86        正常运行\nARM64      正常运行\n\n\napp-wininfo-m 稳定性验证#\n\n压力测试对稳定性要求很高，设计以下测试项，对 app-wininfo-m 程序的关键点进行稳定性验证。\n\n测试项                     测试说明                              时长    结果\n获取10个应用窗口属性             打开多个10个应用，对10个窗口属性获取，demo程序稳定     24H   通过\n同一个应用打开10个窗口，获取所有窗口属性   选择文管，打开10个窗口，获取10个窗口属性，demo程序稳定   24H   通过\n鼠标移动                    使用demo控制在桌面随意移动，demo程序稳定          24H   通过\n长时间获取鼠标位置               桌面随机一定，一直获取鼠标位置，demo程序稳定          24H   通过\n点击鼠标左键                  使用demo程序，鼠标随机一直标右键，demo程序稳定       24H   通过\n点击鼠标右键                  使用demo程序，鼠标随机一直标左键，demo程序稳定       24H   通过\n键盘输入                    使用demo程序，控制键盘一直输入，demo程序稳定        24H   通过\n\n经过上面的测试项，demo 程序满足了稳定性\n\n\napp-wininfo-m 操作性能验证#\n\ndemo 程序在设计当初考虑了极限的压力操作场景，准备了一下实验，进行验证结果，代码如下：\n\n\n\n使用 time 命令运行 shell 脚本，下图就是 demo 程序运行速度。\n\n\n\n由上图九可知 demo 程序运行速达到 1.844s，对比方案二的 2.315s 速度，明显超过 Xdotool 工具的运行速度。\n\n\n小结#\n\n本文针对压力测试工具提出技术方案，整体设计中通过对设备文件写入操作和使用 xlib\n库开发了定位和操作服务，解决了方案二获取坐标不稳定和操作速度不够快的问题，基本上能满足现有压测场景的使用要求，同时提供简单崩溃断言的服务。\n\napp-wininfo-m\n工具作为我们自己开发的工具，未来可以根据需求进行功能扩展，如在“进行搜索的压力测试”，目前只能验证搜索出现崩溃这样的问题，无法验证搜索结果是否正确，现有市面上仍\n然没有这样功能的工具，我们可以在 app-wininfo-m 工具中定制开发。\n\n一个新开发工具，往往要经过无数次的版本迭代和优化，接下来的方向，就是对工具进行以下功能扩展和优化。\n\n扩展功能           优化\n模拟拖拽操作         优化鼠标移动计算方式\n元素定位           优化 app-wininfo-m 代码\n图像定位           优化数据输出方式\n增加断言方式（如：搜索）   优化键盘输入传值方式\n模拟触摸操作         \n\n\n参考资料#\n\n * xdotool 介绍\n * xｗininfo 介绍\n * xlib 介绍\n * input 子系统","routePath":"/技术文档/技术调研/《应用于桌面应用压力测试的模拟输入工具》调研报告","lang":"","toc":[{"text":"相关术语","id":"相关术语","depth":2,"charIndex":3},{"text":"问题","id":"问题","depth":2,"charIndex":185},{"text":"现状","id":"现状","depth":2,"charIndex":580},{"text":"技术方案","id":"技术方案","depth":2,"charIndex":3298},{"text":"整体设计","id":"整体设计","depth":3,"charIndex":3952},{"text":"关键技术","id":"关键技术","depth":3,"charIndex":4675},{"text":"坐标服务","id":"坐标服务","depth":4,"charIndex":4682},{"text":"操作服务","id":"操作服务","depth":4,"charIndex":5221},{"text":"实验验证","id":"实验验证","depth":2,"charIndex":5530},{"text":"app-wininfo-m 可行性和兼容性验证","id":"app-wininfo-m-可行性和兼容性验证","depth":3,"charIndex":5583},{"text":"app-wininfo-m 稳定性验证","id":"app-wininfo-m-稳定性验证","depth":3,"charIndex":6237},{"text":"app-wininfo-m 操作性能验证","id":"app-wininfo-m-操作性能验证","depth":3,"charIndex":6874},{"text":"小结","id":"小结","depth":2,"charIndex":7057},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":7509}],"domain":"","frontmatter":{"Author":"海林"},"version":""},{"id":52,"title":"获取影院播放视频FPS方法","content":"#\n\n\n相关术语#\n\n缩写    全称                  描述\nFPS   Frames Per Second   每秒传输帧数\n\n\n问题#\n\n目前基于Uos影院应用测试中，有一个功能点一直没覆盖到：验证影院播放视频呈现的FPS（帧率）。\n\n比如影院，在播放一个50帧率的视频资源，通过显示器呈现给用户的观感是否有达到50FPS，这是目前需要解决的问题：找到对应的测试方法。\n\n\n现状#\n\n针对于以上描述问题，方案分为两个方向：\n\n * 通过外部获取：例如FPS监控软件，直接使用FPS检查工具针对播放中视频检测FPS\n * 通过内部获取：了解影院播放功能的设计逻辑，手动计算获取，通过播放视频时，抽取视频几段位置，分别获取每帧播放完毕时的耗时，计算出平均帧率，经过验证此方法可满\n   足当前需求。\n * 通过计算获取：获取单位时间内帧数图片与耗时，计算出当前播放帧率\n\n经调研基于linux做FPS检测的工具很少，目前只找到2款工具：Unigine\nHeaven、GLgears，但这2款工具在FPS测试方便均是针对显卡，并不满足我们的需求（应用播放视频呈现的帧率），所以pass掉。\n\n暂定使用内部获取方案与计算获取的方案，后续会进行数据比对与测试流程比对，确认最终方案。\n\n\n技术方案#\n\n要通过内部获取的方案，首先需要确认目前测试部硬件环境，然后对影院FPS相关逻辑进行了解分析，最后找到对应的测试切入点。\n\n\n测试范围#\n\n目前测试部搭配的显示器刷新率统一为60Hz（ 每秒钟刷新60次\n），通过字面上的意思可以得出结论：若播放80帧的视频，每一秒钟切换80张图，但是显示器每一秒才刷新60次，那么视频每一秒包含的80帧中，必然有部分帧是显示不出来\n的，这就是所谓的丢帧。所以在测试资源上目前支持测试60FPS以下的视频资源。\n\n除了显示器以外显卡对FPS也有一定影响，比如目前我们测试机配置的显卡，针对50帧以上的4K高分辨率视频存在解码性能问题，也会影响测试结果。除开性能以外显卡有一个\n配置项垂直同步，当打开后显卡输出的FPS与显示器刷新率会一致，这个选项对用户场景来说基本是默认开启的，所以我们不考虑关闭此配置项的情况。\n\n这里说一下视频播放的原理，视频播放理论由连续不断的图片切换呈现出的效果，例如在测试中所说的50帧率视频，其实就是在每一秒的时间内连续切换了50张不同的图片，每一\n张图片为1帧，所以FPS表现为：50帧/秒。人的肉眼在查看超过30帧的画面，在视觉感知上就较为流畅，所以视频资源最少需要达到30FPS。\n\n结合以上内容可确定目前可测试的视频资源范围为：\n\n * 普通视频：==30FPS-60FPS==\n * 4K高清视频：==30FPS-50FPS==\n\n\n原理确认#\n\n内部获取方案（方案1）#\n\n遍历影院与FPS相关的功能，决定从进度条做为切入点，因为进度条递增1秒理论上就是视频FPS。通过和影院开发（谢鹏飞）沟通后了解了一些技术概念与影院内部设计逻辑，\n证明该方案是可行的。\n\n业界对于音视频同步一般是三种策略：\n\n策略           详情\n音频和视频同步到时钟   以外部时钟为参考对象，视频和音频均以时钟时间为准\n音频去同步视频的时间   以视频时间为基准，判断音频快了还是慢了，从而调整音频的播放速度，其实是一个动态的追赶与等待的过程。\n视频去同步音频的时间   这个方案的原理刚好与方案2的原理相反。就是以音频时间为基准，判断视频是快了还是慢了，从而调整视频的播放速度。\n\n举个例子：60FPS的视频，实际播放出来只有30FPS，那不同的同步策略会有什么不同的展示？下面能很直接看出差异：\n\n * 正常情况下60FPS视频，实际播放达到60FPS，耗时1秒播放完60帧\n\n * 音频去同步视频时间：耗时2秒播放完60帧\n\n * 视频去同步音频时间：耗时1秒播放完30帧，其中30帧被丢掉\n\n咱们影院采取的同步策略为视频去同步音频时间，所以若播放视频FPS未达到视频资源FPS，那么呈现出来的效果是：==播放过程中会丢帧==。\n\n那么进度条递增1秒则代表完成了1秒的音频播放，同时完成了1秒时间内帧的播放，播放了多少帧则代表当前播放FPS，所以在后续的测试中进度条的变化时主要的参照物。\n\n计算获取方案（方案2）#\n\n该方案的重点在于==时间==与==帧图像==，只要能获取影院播放视频每秒消耗的时间和帧图像，即可计算出当前位置的FPS。比如30FPS的视频在播放过程中，任意截\n取一秒内播放的帧图像数量，并去掉重复的帧图像，最后剩余图片数量预期应该是30张，那30即为当前播放帧率。\n\n该方案的难点在于怎么定位一秒的播放时长来截取该范围帧数图像。\n\n\n关键技术#\n\n这两种方案中都会采用到的关键测试技术是视频分帧，它能做到把每一秒视频分解为任意数量的帧图像，通过对帧图像的分析与筛选，达到我们测试的目的。\n\n\n视频资源#\n\n这两种方案都会受到视频资源的影响，比如某些视频资源本身在某一段时间画面就是静置的，则无法使用该方法进行测试，因为视频本身就有重复帧。\n\n我们无法保证每个视频资源都没有重复帧，那么我们可以自己制作符合要求的视频资源，这里可使用显卡FPS测试工具glxgears，运行glxgears会产生3个不同转\n动的齿轮，因为开启了垂直同步所以齿轮动画稳定在60FPS，通过视频录制软件录制齿轮动画为不同FPS资源：30FPS、49FPS，这些资源作为测试数据完美解决视频\n本身出现重复帧的情况。\n\n为了满足“计算获取帧率方案”，在录制视频时安装了一个毫秒精度的计时器==stopwatch==，录制过程中计时器会和齿轮动画同时运行，后期则通过计时器数值来定位\n“ 每秒 ”的范围。同时也可以印证“内部获取帧数方案”的可行性。\n\n * glxgears运行动画及实时帧率\n\n\n\n * 已完成录制视频资源：\n\n\n\n * 录制的视频截图\n\n\n视频分帧#\n\n视频分帧的原理是把一个录制好的视频按照一定的规则分解成图片，比如一个30FPS的视频：\n\n * 每秒分出10帧，每秒会得到10帧不同图像\n * 每秒分出30帧，每秒会得到30帧不同图像\n * 每秒分出60帧，每秒会得到30帧不同图像和30帧重复图像\n\n\n实现支撑#\n\n综上所述要进行测试前，需要准备以下内容：\n\n * 测试视频资源：目前已录制了30FPS、49FPS视频资源（录制工具无法录制出60FPS视频，暂时忽略该FPS资源），已上传至seafile【成都-测试团队\n   / 成都-测试团队 / 测试资源 / 视频资源 / 定制FPS】\n\n * 视频录制/图片查看工具：可通过工具‘PerfTools’辅助，首页【编号1】可自动安装视频录制、图片查看工具**（如下图）**\n\n * 视频分帧：可通过工具‘PerfTools_3.3’辅助，3.3版本新增了自定义分帧图片数量功能，首页【编号2】。\n\n * 影院更新至测试对应版本\n\n * 工具截图：\n\n\n\n * 分帧流程截图：\n\n\n\n\n实验验证#\n\n验证测试资源#\n\n进行实验验证前，对测试资源进行一轮验证（后续测试直接使用测试资源即可），确保测试视频资源FPS是达到标准的，因为后续无需其他测试人员再操作，该部分只展示原理与数\n据。\n\n重点说明：==因为视频资源是通过录制的方式生成的，所以录制本身也可能出现丢帧的情况，以下经过验证过的时间均为正确位置，所以在之后的测试中，截取的三组数据均必须为\n验证后的时间位置==\n\n操作步骤简介\n\n * 通过测试工具PerfTools对30/49视频进行分帧，分帧图像数量与视频一致即可\n   * 这里有做过分帧图像数量验证：30FPS视频分帧图像数量分别为30和60，得出的结论一致，所以这里分帧图像数量设置成视频FPS即可\n * 通过计时器截取时间范围，选取三个时间区域，每个时间区域范围为“1s”，这里选择计时器做参考有2个原因：\n   * 影院外计时器不受影院内部逻辑影响，对验证结果更有说服力\n   * 计时器精度为毫秒级，更能体现细节\n * 把多组时间区域的图像帧分别复制到对应文件目录\n * 依次查看每个目录，去掉重复帧（参考图像与计时器时间，若时间未变化则为重复帧）\n * 统计数据并分析，数据如下： | 测试视频资源 | 时间区域(计时器时间) |进度条对应时间 | 去重帧数量 | | :--: |\n   :---------------: | :----------: |:----------: | | 30FPS视频 | 00:00:03.051 ——\n   00:00:04.053 |3s-4s | 30 | | 30FPS视频 | 00:00:08.021 —— 00:00:09.021 |8s-9s |\n   30 | | 30FPS视频 | 00:00:11.027 —— 00:00:12.026 | 11s - 12s |30 | | 30FPS视频 |\n   00:00:12.026 —— 00:00:13.012 | 12s - 13s |30 | | 30FPS视频 | 00:00:22.021 ——\n   00:00:23.018 |22s - 23s | 30 | | 49FPS视频 | 00:00:05.018 —— 00:00:06.025 | 05s\n   - 06s |49 | | 49FPS视频 | 00:00:08.003 —— 00:00:09.000 | 08s - 09s |49 | |\n   49FPS视频 | 00:00:12.002 —— 00:00:13.001 | 12s - 13s |49 | | 49FPS视频 |\n   00:00:14.020 —— 00:00:15.019 |14s - 15s | 49 | | 49FPS视频 | 00:00:20.019 ——\n   00:00:21.019 |20s - 21s | 49 |\n\n通过以上数据验证，可看出得出的帧数量与视频测试资源FPS一致，证明以上原理可靠，在==后续的测试中，不管是【内部获取FPS方案】还是【计算获取FPS方案】使用以\n上时间区域即可，为了可以通用，取得时间区域都是整点==。\n\n获取监控视频#\n\n要获取影院播放视频呈现的FPS，首先需要在影院播放测试视频资源时，对该过程进行视频录制监控，最后再对监控视频进行分帧处理，对分解为帧图像的数据进行进一步的分析。\n\n在录制视频时，同样加入了计时器==stopwatch==，用于后期数据分析，下面将录制：影院播放**测试视频资源（30FPS）**的监控视频，步骤如下：\n\n * 关闭所有不相关应用与窗口\n\n * 运行计时器stopwatch\n\n * 运行影院并打开视频资源（30FPS），在00:00:00位置暂停\n\n * 运行PerfTools工具，执行【编号1】启动视频录制软件，设置录制帧率为30，开始录制\n\n * 影院开始播放视频、计时器开始计时\n   \n   * 注意：鼠标移动至底部工具栏（此处为重点，因为鼠标移动至附近，进度条才不会消失，我们需要监控进度条时间变化）\n   * 视频资源内展示时间，后续称为==A时间==\n   * 视频资源外展示时间，后续称为==B时间==\n   * 理论上截取1秒时间区域，通过A时间与B时间进行验证，均需等于1秒\n\n * 影院点击播放键，\n\n * 视频播放完毕，停止录制\n   \n   \n\n获取影院播放视频帧率#\n\n视频分帧#\n\n下面将针对录制好的监控视频（影院播放30FPS测试资源）进行数据分析，得出测试结果，两种方案前期步骤一致，如下：\n\n * 运行PerfTools工具：\n   * 执行首页【编号2】\n   * 执行子菜单【编号1】—— 输入监控名称 —— 输出自定义帧率30 ** —— 完成分帧（见插图）**\n * 进入目录【监控30FPS_30fps】，说明：监控30FPS为视频名称；30fps为分帧数量，验证一致则代表视频资源分帧正确\n * 右键点击图片选择使用nomacs打开（相比系统自带看图软件，切换图片更流畅）\n * 根据验证测试资源部分时间区域，选取至少3组区域的数据，根据各自的分析方法得出FPS\n * 多组数据间求平均值得出最终结果\n\n内部获取FPS方案（方案1）分析\n\n以下数据主要基于==进度条对应时间==得出，计时器时间A是作为一个重要参考项，==首帧与尾帧都是根据影院进度条对应时间来定位==，用第一组数据举例：\n\n * 首帧为影院进度条变为00:00:03不在变化那一帧\n * 尾帧为影院进度条变为00:00:04不在变化那一帧\n\n==方案1数据：==\n\n数据组   选取时间A范围     时间A实际范围（首帧和帧数图像上时间）            进度条对应时间     首帧    尾帧    去重后帧数量\n第一组   3s-4s       00:00:03.320 —— 00:00:04.287   3s-4s       164   200   29\n第二组   12s - 13s   00:00:12.326 —— 00:00:13.346   12s - 13s   448   478   28\n第三组   22s - 23s   00:00:22.353 —— 00:00:23.318   22s - 23s   748   777   25\n\n通过以上数据求平均值，得出最终的FPS： （29+28+25）/3 ≈ 27.3帧\n\n计算获取FPS方案（方案2）分析\n\n该方案数据主要基于==进度条与时间B==得出，首先选定时间A的范围，然后在得出首/尾帧：\n\n * 首帧：以进度条时间范围起始点定位首帧，同时获取帧图像上时间B时间，作为起始点时间\n\n * 尾帧：以时间B起始点时间为准，起始点时间向后推1000ms，则为尾帧\n\n起始点与结束点范围区间耗时为1000ms，也就是时间B的时间范围永远为1000ms（因为录制精度的问题，可能有微量误差），获取时间B尾帧时顺便记录时间A的时间，\n后续做参考，具体格式如下：\n\n数据组   进度条时间范围             时间A实际范围                 计时器时间B                  首帧            尾帧            去重后帧数量\n第一组                                                                                                   \n第二组   * 已验证数据表格中进度条时间区间   * 通过确认首/尾帧，获取图像上时间A区间   * 进度条范围起始点 —— +1000ms   * 时间B起始点帧编号   * 时间B结束点帧编号   \n第三组                                                                                                   \n\n为了与方案1相互印证，以下选取时间A范围取值改为与方案1一致，以方案1中时间A实际范围的起始点为时间B的起始点，再后推1000ms获得结束点。总结一下就是，首/\n尾通过时间B范围确定，但是时间B的起始点是通过方案1的起始点确认的，这样就能保证测试的范围是同一范围，方便做数据对比分析。\n\n==方案2数据：==\n\n数据组   选取时间A范围（预期结果）                  时间A实际范围                        计时器时间B                         首帧    尾帧    去重后帧数量\n第一组   00:00:03.320 —— 00:00:04.287   00:00:03.320 —— 00:00:04.154   00:00:06.292 —— 00:00:07.320   164   194   24\n第二组   00:00:12.326 —— 00:00:13.346   00:00:12.326 —— 00:00:13.346   00:00:15.760 —— 00:00:16.764   448   478   28\n第三组   00:00:22.353 —— 00:00:23.318   00:00:22.353 —— 00:00:23.318   00:00:25.763 —— 00:00:26.752   748   778   25\n\n通过以上数据求平均值，得出最终的FPS： （24+28+25）/3 = 25.6帧\n\n同时把方案1的数据拿下来，把进度条对应时间根据首/尾帧改为时间B范围，与以上方案2数据做进一步印证。\n\n==方案1加入“时间B范围”后数据：==\n\n数据组   选取时间A范围     时间A实际范围（首帧和帧数图像上时间）            时间B范围（供对比，与首/尾帧无关）             首帧    尾帧    去重后帧数量\n第一组   3s-4s       00:00:03.320 —— 00:00:04.287   00:00:06.292 —— 00:00:07.493   164   200   29\n第二组   12s - 13s   00:00:12.326 —— 00:00:13.346   00:00:15.760 —— 00:00:16.764   448   478   28\n第三组   22s - 23s   00:00:22.353 —— 00:00:23.318   00:00:25.763 —— 00:00:26.729   748   777   25\n\n通过以上数据可以看出，第二组与第三组数据得出的结论吻合，但是第一组数据有出入，进行进一步分析如下：\n\n * ==方案1==比==方案2==的尾帧多了6帧，经过验证这6帧中有5帧时有效帧，若方案2加5帧则数据吻合\n\n * 通过==方案1==中时间A与时间B分析，时间A（视频内时间）耗时967毫秒，时间B（视频外自然时间）耗时1201毫秒，也就是说针对第一组数据中进度条递增1\n   秒的耗时超过了1秒，所以尾帧要比方案2多出6帧，同时这里也证明了方案1会有存在误差的情况\n\n * 通过==方案2==中时间A与时间B分析，时间A（视频内时间）耗时834毫秒，时间B（视频外自然时间）耗时1028毫秒，也就是说自然时间1秒内，影院只播放了\n   834毫秒的资源，存在丢帧情况，与结果24帧吻合\n\n\n定案#\n\n\n最终结论#\n\n通过以上数据分析，最终得出以下结果：\n\n * 方案2精度更高，方案1有时会存在误差\n * 方案1与方案2测试结果差距1.7帧：\n   * 方案1：25.6帧\n   * 方案2：27.3帧\n\n最终结论是，使用方案2进行测试可解决目前面临的问题，获取影院播放视频呈现的FPS值。\n\n同时需要注意的是：==真实测试时，发现这种帧率不稳定情况，可额外多做2组数据，增加精确度，同样需要在“验证测试资源部分”的表格中选择时间区域==。\n\n测试方法最终调整#\n\n定案使用最终方案进行测试后，有部分细节需要调整，最终流程如下：\n\n * 获取测试资源视频（不变）：seafile【成都-测试团队 / 成都-测试团队 / 测试资源 / 视频资源 / 定制FPS】\n\n * 获取监控视频（不变）\n\n * 视频分帧（不变）\n\n * 选取有效时间区域，参考==验证测试资源==部分表格中进度条对应时间区域，至少三组，若结果不稳定则酌情增加\n\n * 分帧后图像数据处理：\n   \n   * 首帧：参考==验证测试资源==部分表格中，==进度条==对应时间，起始点为首帧（记录该帧图像上时间A、时间B）\n   * 尾帧：首帧中时间B后推1000ms，有时会上下浮动，取最接近那一帧为尾帧（记录尾帧时间A、时间B）\n   * 每一组图像集合==复制==到其他文件夹中，不可删除原文件（需留底）\n\n * 重复帧处理（不变）\n\n * 记录表格：\n   \n   数据组   进度条时间范围     时间A实际范围   时间B实际范围                        首帧   尾帧   去重后帧数量\n   第一组   3s-4s                 00:00:06.292 —— 00:00:07.493             \n   第二组   12s - 13s             00:00:15.760 —— 00:00:16.764             \n   第三组   22s - 23s             00:00:25.763 —— 00:00:26.729             \n\n * 数据分析：\n   \n   * 主要是通过时间B范围，筛选出非重复帧数量\n   * 时间A是顺便记录，出现问题后用作参考，不容缺失\n   * 非重复帧数量取平均值得出结果\n\n\n参考资料#\n\n * 音视频同步原理及实现\n * 垂直同步\n * 丢帧\n * 显示器刷新率与FPS","routePath":"/技术文档/技术调研/《获取影院播放视频FPS方法》调研报告","lang":"","toc":[{"text":"相关术语","id":"相关术语","depth":2,"charIndex":3},{"text":"问题","id":"问题","depth":2,"charIndex":74},{"text":"现状","id":"现状","depth":2,"charIndex":197},{"text":"技术方案","id":"技术方案","depth":2,"charIndex":549},{"text":"测试范围","id":"测试范围","depth":3,"charIndex":618},{"text":"原理确认","id":"原理确认","depth":3,"charIndex":1157},{"text":"内部获取方案（方案1）","id":"内部获取方案方案1","depth":4,"charIndex":1164},{"text":"计算获取方案（方案2）","id":"计算获取方案方案2","depth":4,"charIndex":1783},{"text":"关键技术","id":"关键技术","depth":2,"charIndex":1965},{"text":"视频资源","id":"视频资源","depth":3,"charIndex":2044},{"text":"视频分帧","id":"视频分帧","depth":3,"charIndex":2463},{"text":"实现支撑","id":"实现支撑","depth":3,"charIndex":2597},{"text":"实验验证","id":"实验验证","depth":2,"charIndex":2916},{"text":"验证测试资源","id":"验证测试资源","depth":4,"charIndex":2923},{"text":"获取监控视频","id":"获取监控视频","depth":4,"charIndex":4249},{"text":"获取影院播放视频帧率","id":"获取影院播放视频帧率","depth":4,"charIndex":4753},{"text":"视频分帧","id":"视频分帧-1","depth":4,"charIndex":4766},{"text":"定案","id":"定案","depth":2,"charIndex":7740},{"text":"最终结论","id":"最终结论","depth":3,"charIndex":7746},{"text":"测试方法最终调整","id":"测试方法最终调整","depth":4,"charIndex":7967},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":8752}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":53,"title":"针对PMS用例数据检查与自动化工程CSV文件数据同步的方法调研报告","content":"#\n\n\n1 相关术语#\n\n缩写          全称                           描述\nPMS         /                            项目管理软件，本文中主要体现在测试用例管理上。\n爬虫          /                            一般是基于 Python 编写的一段自动抓取互联网信息的程序，从互联网上抓取对于我们有价值的信息。\nCSV         Comma-Separated Values       逗号分隔值文件格式，本文中该格式文件用于管理自动化测试工程测试用例。\n配置化测试       /                            根据不同测试场景，配置不同的用例组合情况进行测试，例如只测试核心用例，跳过其他类型用例测试。\nJSON        JavaScript Object Notation   一种轻量级的数据交换格式。\nUrllib      /                            Python 标准库，用于操作网页 URL，并对网页的内容进行抓取处理。\nPandas      Python data analysis         一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具。\nDataFrame   /                            一个表格型的数据结构，它含有一组有序的列，每列可以是不同的值类型。\n\n\n2 问题#\n\n\n2.1 问题背景#\n\n在应用 UI 自动化测试工程中每一个测试应用均存在一个或多个 CSV 文件，主要用于管理自动化测试用例，每一行数据代表一条测试用例：\n\n\n\n其中 CSV 文件中每一条用例都与 PMS 某一条用例存在关联关系，例如图1中用例 id 为1的自动化用例在 PMS 中展示：\n\n\n\n通过图1与图2可以得出两者关联关系：\n\n> CSV 文件用例id：对应 PMS 用例标题自定义标签[001]\n> \n> CSV 文件用例来源：对应 PMS 用例标题自定义标签[acp1/2/3/4]\n> \n> CSV 文件用例标签：对应 PMS 用例标题自定义标签[core/smoke]\n> \n> CSV 文件用例等级：对应 PMS 用例优先级字段\n> \n> CSV 文件中存在的用例在 PMS 中，自动化相关的关键字需更新为：\n> \n>  * 执行方式：自动化执行\n>  * 是否已自动化：是\n\n\n\n\n2.2 问题详情#\n\n为了保证用例数据的准确性，PMS 字段、标题标签需要随时更新，同时 CSV 文件数据也需要同步修改来保证数据的一致性。但目前实际项目中出现诸多更新不及时的问题：\n\n> PMS 用例转换为自动化用例后，关键字：执行方式、是否已自动化未更新字段。\n> \n> PMS 用例转换为自动化用例后，未增加自动化 id 标签。\n> \n> PMS 用例等级发生变化后，未同步至自动化工程 CSV 文件。\n> \n> PMS 用例标签发生变化后，未同步至自动化工程 CSV 文件。\n> \n> CSV 文件删除用例后，PMS 用例信息未同步。\n> \n> CSV 文件新增用例后，未同步至 PMS 用例标题。\n> \n> CSV 文件新增标签后，未同步至 PMS 用例标题。\n\n以上情况日积月累下，存在问题的用例数量会越来越多，就目前通过以上示例条件做数据筛选，得出结论存在问题数量为2000左右。其中问题数量占比与解决重心为：\n\n * PMS 与 CSV 两端数据不匹配 - 占比25%（重要）：\n   \n   * PMS 已实现自动化用例，在自动化工程所需标签再变更后，未同步至自动化工程 CSV 文件，导致影响了配置化测试的有效性，需要重点解决该问题。\n\n * PMS 用例数据/字段错误 - 占比75%（次要）：\n   \n   * 除以上问题外，主要是 PMS 用例数据关键字、状态等不正确，不会影响自动化测试结果，但会影响手工测试与数据统计，需解决但不是那么急迫。\n   \n   * 例如用例状态未审核导致测试单无法关联、未修改自动化字段导致统计自动化用例数据错误。\n   \n   总结本章节描述的问题核心为 PMS 端数据与自动化测试工程中 CSV\n   文件中数据不一致，手动修改效率太过低下，且会影响当前工作任务；若不进行处理，问题则会积累的越来越多，进入恶性循环。所以目前需要一种能够快速同步两端数据使其\n   一致的方案。\n\n\n3 现状#\n\n针对上一章节提出的问题解决流程如下：\n\n\n\n通过流程描述，核心涉及 PMS 项目管理系统用例数据 与 自动化测试工程 CSV 文件，该 CSV\n文件数据设计非市面上现存设计方案，为根据项目情况与需求而设计出的结构。\n\n需要对两端数据进行同步，是特定场景下的需求，所以不存在现存的解决方案，基于实际情况预想了两个方向的解决方案，接下来对预想方案进行对比分析。\n\n\n3.1 方案描述#\n\n方案1：\n\n * 通过 PMS 功能进行批量数据获取，借助 Excel 进行数据分析、检查。\n\n * 人工进行数据对比并同步差异数据至 CSV 文件。\n\n * 通过本地 Excel 文件进行人工修改后批量上传至 PMS。\n\n方案2：\n\n * 通过爬虫程序进行批量数据获取，保存至本地过程中进行数据分析与检查。\n * 保存完成后以应用为维度，对比双端数据，同步差异数据至 CSV 文件。\n * 通过步骤1检查结果进行数据修改，根据项目情况可选择：\n   \n   * 导出 PMS 用例，根据步骤1分别对应用检查结果进行针对性用例数据修改，批量上传至 PMS 完成修改。\n   \n   * 根据步骤1的检查结果调用 PMS 用例接口，批量完成用例信息修改。\n\n\n3.2 方案对比#\n\n多维度对比详情如下：\n\n * 准备耗时\n   * 方案1：手工操作+ PMS 项目管理工具 WEB 现有功能，无需准备时间\n   * 方案2：需要消耗开发程序的时间\n * 易用性\n   * 方案1：需要了解自动化工程 CSV 文件设计、 PMS 使用方法、校验规则、同步规则\n   * 方案2：需要了解程序运行参数/配置\n * 高效性\n   * 方案1：大部分工作依赖手工完成，用例技术越大，效率越低\n   * 方案2：自动化完成，用例基数越大，效率越高\n * 复用性\n   * 方案1：可同时对多个应用使用\n   * 方案2：可同时对多个应用使用\n * 扩展性\n   \n   * 方案1：不具备扩展价值\n   \n   * 方案2：可用于其他领域，例如周期性用例质量监控。同时若后期 PMS 标签、CSV 文件设计出现增量/变化，可在原有设计的基础上进行功能扩展支持。\n\n\n3.3 对比结论#\n\n      准备耗时   易用性   高效性   复用性   扩展性\n方案1   优      劣     劣     持平    劣\n方案2   劣      优     优     持平    优\n\n两套方案综合对比下来，除了方案2在前期准备耗时上处于劣势，在其他方面整体优于方案1，所以最终选择方案2。\n\n\n4 技术方案#\n\n\n4.1 整体设计#\n\n方案2涉及爬虫和数据处理，首先语言定位为 Python 无可争议，核心库选择： urllib + pandas 的组合；核心流程为：数据获取 -> 数据清理\n-> 数据检测 ->数据同步 -> PMS 端数据修改。\n\n核心原理：\n\n * 使用 urllib 进行 PMS 数据爬取，爬取到的数据是 ASCII 编码 + JSON 数据格式，转换为中文。\n * 制定用例检测规则与错误类型，在获取到 PMS 用例数据后逐一对每一条用例进行正确性检测。\n * 通过 pandas 进行后续数据处理工作：\n   * 爬虫数据设置索引、多权重排序、去重、填充空数据等，结合检测结果保存至本地。\n   * PMS 数据与自动化工程 CSV 文件数据进行关键项数据抽取与比对\n   * 根据比对结果，同步存在差异的数据至自动化工程 CSV 文件\n * 通过用例检测结果，参考错误类型对 PMS 数据进行修改（二选一）：\n   * 逐一修改后，使用 PMS 批量上传功能\n   * 抽取问题用例，分析错误类型，使用 PMS 用例编辑接口回填正确数据\n\n\n\n整体方案中执行流程设计方案如下：\n\n\n\n工具暂命名为 pms_label_manage ，整体目录结构设计如下：\n\n\n\n如上文所述，工具行为通过配置文件 manage_config 进行管理，使其可配置性与易用性都更高。\n\n以下示例为设计的配置文件爬虫部分配置项：\n\n\n\n\n4.2 关键技术#\n\n4.2.1 数据爬取与检测#\n\nurllib 库是 Python 标准库，用于操作网页 URL，并对网页的内容进行抓取处理，主要对象是 PMS 项目管理 中用例部分的内容数据。\n\n4.2.1.1 准备工作#\n\n需要通过抓包的方式对登录、用例接口进行了参数摸底，制定后续对应接口的请求参数，并且根据参数内容收集项目、应用在数据库中的具体\nid。这部分内容略过，本章节主要聚焦数据爬取、检测与同步。\n\n4.2.1.2 数据爬取#\n\n流程是：通过 PMS 登录接口进行登录 -> 保存cookie信息 -> cookie放入请求头并调用用例接口 -> 获取返回数据 -> 处理数据。\n\n4.2.1.2.1 登录接口逻辑#\n\n * 设计流程为：\n\n\n\n * 实现代码：\n\n\n\n通过以上实现方案完成了 PMS 登录环境的内容。\n\n4.2.1.2.2 用例数据获取#\n\n通过用例接口调试时发现，用例接口返回数据为 ASCII 编码 + JSON 数据格式，所以需要进行中文转换，接口返回数据如下：\n\n\n\n除此之外还发现 JSON 数据格式不规范，例如上述数据中 \\\"setModule\\\":true 缺少引号，这类问题均需要处理。\n\n因为每次任务并非都是单一应用，存在同时同步10多个应用的场景，所以在数据获取这一阶段设计流程为：根据任务应用列表建立循环 -> 每次循环爬取一个应用的数据 ->\n数据编码转换为 中文 -> 处理 JSON 数据格式问题 -> 执行下一次循环应用数据爬取。\n\n部分关键实现代码如下：\n\n\n\n4.2.1.2.3 数据检测#\n\n通过以上数据获取与处理后，成功的把数据转换成了中文，下面截取数据中某一条用例数据信息做展示：\n\n\n\n通过以上 JSON 数据可以看出，爬取的用例信息较为完整，已全面覆盖自动化工程 CSV 文件字段，并且其他更加丰富的信息可以用作用例正确性检查。\n\n根据项目实际情况调研，一共制定了以下用例检测的错误类型：\n\n\n\n根据上文制定的错误类型设计不同的判断条件，如下方部分代码：\n\n\n\n通过以上代码可看出，每解析一条用例就能通过用例的各个字段对用例进行检测，当存在异常时输出对应错误项文案至列：检测异常，用于辅助后续的 PMS 数据修改。\n\n4.2.2 数据同步#\n\n使用 pandas 对 PMS 数据数据做进一步处理，并进行数据比对与同步：\n\n4.2.2.1 PMS数据处理#\n\n * 把从标题中提取出的自动化用例 id 设置为索引。\n\n * 根据索引列进行排序，基于配置文件中权重 csv_crawler_sort = 用例id,用例等级 ，优先基于用例 id 升序排列，用例 id\n   相同时则基于用例等级做二次升序排序。\n\n\n\n * 基于索引列去重，仅保留排序在前的用例行数据（此处理是因为目前自动化测试用例存在关联多条 PMS 用例的情况，CSV\n   文件保留优先级高的用例数据作为同步对象）。\n\n * 基于配置项 ecsv_local_update 提取 PMS 用例数据为 DataFram 类型的二维数据表。\n\n二维数据表输出：\n\n\n\n4.2.2.2 本地 CSV 文件备份#\n\n备份本地 CSV 文件，以便于数据回溯与回滚，备份过程当中发现 csv 文件存在格式错误与用例 id 编号类型不一致的问题（ int / float\n），所以这里增加了格式检测与数据类型统一的处理，实现代码如下：\n\n\n\n通过以上代码完成了两个目的：\n\n * 检测 CSV 文件格式，若出现异常则跳过，并在终端给出提示，推动维护人员进行修改。\n\n * 检测 CSV 文件用例 id 字段的数据类型，自动完成修改，达成文件标准统一化。\n\n4.2.2.3 PMS 数据与本地 CSV 数据同步#\n\n * 本地 CSV 文件数据提取为 DataFrame 数据表，并与 PMS 数据设置相同列索引用例id。\n\n * 基于本地 CSV 数据索引进行循环，同时获取两张数据表数据并进行需更新列的比对。\n\n * 同步对比不相等的值至本地 CSV 文件。\n\n部分代码如下：\n\n\n\n上方代码循环执行完毕后，代表本地 CSV 文件数据已经在本地同步完成。\n\n4.2.2.4 完成数据同步#\n\n提交 CSV 文件修改至云端仓库，完成最终的数据修改。\n\n4.2.3 PMS数据修改#\n\n基于 PMS 数据的检测结果，参考用例对应的错误类型，进行 PMS 数据修改。由于在爬取的 PMS 数据中存在PMS用例编号 可轻松在 PMS\n上定位问题用例，根据项目情况选择 PMS 批量上传修改或 PMS 接口回填均可。\n\n4.2.4 任务结果收集#\n\n任务完成后设计输出两类结果：\n\n * 提示性汇总结果：通过企业微信机器人实现，同步执行任务相关信息与结果，预期示例如下\n   \n   > 执行日期： 2022.06.13 15:34 执行工程： app 执行对象： music,draw 执行状态： Successful 更新数据： 68\n   > 更新文件： music.csv 保持文件： draw.csv 失败文件： None 异常节点： None\n\n * 本地归档结果：\n   \n   > PMS爬取数据文件\n   > \n   > 自动化工程备份CSV文件\n   > \n   > 数据更新后CSV文件\n   > \n   > 程序运行日志\n\n4.2.5 程序运行入口#\n\n该工具暂命名为 pms_label_manage ，根据程序功能设计运行参数为：\n\n\n\n为了保证易用性，根据使用环境设计了两种启动方式：\n\n * Shell 脚本运行 （无需完成环境部署）- assist_tool.sh，命令行进行：\n * 命令行运行：bash assist_tool.sh run —— 【环境部署 + 以配置文件默认配置运行】。\n   * 交互式运行：bash assist_tool.sh，展示菜单引导用户配置（图5）—— 【以用户选择引导菜单项运行】\n * Python 脚本运行（已完成环境部署）- pms_label_manage.py，命令行进行：\n * 直接运行： python3 pms_label_manage.py —— 【以配置文件默认配置运行】\n   * 参数运行： python3 pms_label_manage.py -p app -o crawler -a music —— 【以参数自定义运行】\n\n\n\n\n5 实验验证#\n\n实验环境\n\n> 【硬件环境】 设备架构：x86_64 设备处理器：处理器 : Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz (八核 /\n> 十六逻辑处理器) 主板 : B460M-HDV(RD) 内存 : 8GB(TMKU8G68AHFHC-26V DDR4 2667MHz (0.4ns))\n> 存储设备 : ESO256GMFCH-E3C-2 (256 GB)/x796w (31.0 GB)/WDC WD10EZEX-08WN4A0 (1.00\n> TB) 网络适配器 : Ethernet Connection (12) I219-V/Ethernet interface/Ethernet\n> interface\n> \n> 【软件环境】 pandas版本：1.3.0 Python版本：3.7\n\n实验流程\n\n\n\n\n5.1 任务启动#\n\n以同步应用 deepin-music 为例，执行环境部署与任务启动命令：\n\n\n\n\n\n\n5.2 任务完成#\n\n等待任务完成，查看任务结果：\n\n\n\n\n5.3 查看用例检测结果#\n\n任务执行结果归档文件中查看 PMS 数据检测结果：\n\n\n\n进一步验证有效性，查看 PMS 项目管理工具 WEB 端数据，抽取用例编号：635533 用例进行验证：\n\n\n\n通过以上在线数据验证可看出，该用例缺少[acp]标签且用例状态非正常，与 CSV 文件中检查异常结果一致。\n\n\n5.4 数据备份与同步#\n\n检查备份文件与同步更新后文件差异性：\n\n\n\n进一步验证有效性，查看 PMS 项目管理工具 WEB 端数据，抽取以上323行 - 325行 数据验证：\n\n\n\n验证结果通过，可看到 PMS 在线数据最新标签确认为 [smoke] ，且本地 CSV 文件中替换[core] 标签正确。\n\n\n5.5 PMS数据批量修改#\n\n本环节存在两种子方案：\n\n * [1] PMS 批量上传修改\n\n * [2] 通过用例编辑接口批量回填修改用例数据\n\n因子方案[1]是手工+ PMS 管理平台本身支持的功能，这里不再做验证。以下主要针对子方案[2]的可行性做验证，以下为利用 PMS 用例编辑接口回填的数据\nDEMO：\n\n\n\n以上 DEMO 主要针对 PMS 用例编号为814409的用例，收集 PMS 该用例历史数据，运行 DEMO ：\n\n\n\n收集 PMS 修改的新用例数据与历史数据做对比：\n\n\n\n通过修改后数据可看出：\n\n * 标题内容修改成功，与运行 DEMO 后打印的修改信息一致\n\n * 用例状态修改成功，从待评审扭转为正常\n\n * 修改历史记录时间验证，与标题时间一致\n\n\n5.6 验证结果#\n\n通过 5.1 - 5.7 小结的验证，可确认该方案可行性通过，同时简单计算效率提升，同样以音乐应用 + PMS 数据同步 CSV 文件场景为例：\n\n5.6.1 历史方案耗时#\n\n通过视频录制的方式采集耗时:\n\n * [1阶段] 获取 PMS 数据，操作+浏览器响应耗时 - 30 秒：\n   \n   * 启动浏览器 - 8秒。\n   * 登录 PMS - 切换项目至应用用例部分 - 15秒\n   * 导出所有用例数据至本地 - 7秒。\n\n * [2阶段] 校验数据差异，并更新 CSV 文件耗时 - 20秒（数据需同步）/18秒（数据无需同步）：\n   \n   * 同时打开 PMS 导出文件与自动化 CSV 文件 - 6秒。\n   \n   * 按照 CSV 文件中用例id的值，在 PMS 导出文件标题列进行查找 - 10秒\n   \n   * 根据查找结果校验 CSV 文件对应用例数值是否一致：\n     \n     * [2-1阶段] 存在差异则进行修改 - 4秒\n     * [2-2阶段] 不存在差异略过 - 2秒\n\n * 耗时计算：\n   \n   > 目前音乐自动化-用例总数量：351 目前音乐自动化-修改用例数量：64 计算公式：[1阶段]耗时 + （用例总数量-修改用例数量）*\n   > [2阶段]数据无需同步耗时 + 修改用例数量* [2阶段]数据需同步耗时\n   \n   计算耗时结果（秒）：30 + 5166 + 1280 = 6476\n\n5.6.2 新方案耗时#\n\n在任务 DEMO 运行代码前后加上时间打印并运行：\n\n\n\n耗时计算公式：end time - start time。\n\n计算耗时结果（秒）：10 - 3 = 7\n\n5.6.3 耗时数据对比#\n\n历史方案耗时（秒）   新方案耗时（秒）   差异值（秒）\n6476        7          6469\n\n根据以上数据可看出，在效率上新方案超出历史方案很多，通过计算现计算具体数值：\n\n * 计算公式：（历史方案耗时-新方案耗时）/新方案耗时。\n\n * 计算结果：（6476-7）/7 = 924.14。\n   \n   通过以上公式得出最终结论，采用新方案比历史方案提升效率 924.14 倍。\n\n\n5.7 稳定性验证#\n\n基于 5.1 - 5.4 章节主流程进行稳定性测试，连续运行30次之后对运行过程与结果进行验证，基于 5.1 - 5.4\n章节描述的验证方法进行结果如下（因之前详细展示过验证方法与流程，此处仅展示结论）：\n\n * 运行过程：未出现报错。\n\n * 运行结果：\n   \n   * 提醒数据：正常。\n   * 归档数据：正常\n   \n   基于验证结果可得出结论，该方案运行较为稳定。\n\n\n6 小结#\n\n根据实验验证章节内容，可得出结论采用方案可行性通过。运行应用除了参数运行外还加入了 Shell\n可视化菜单，可根据提示运行，大大增加了易用性。除此之外在实验验证最后阶段，基于任务 PMS 用例数据同步至自动化工程 CSV\n文件，通过计算得出效率的提示在924倍左右，虽然仅使用音乐进行数据收集，但在其他应用上套用该计算公式同样适用。\n\n结合项目实际情况与问题阶段提出的问题重要程度，目前优先解决 PMS 与 CSV 两端数据不匹配问题，也就是说只实现 PMS 用例数据同步至自动化工程 CSV\n文件部分功能，下一步演进项定为：\n\n 1. 解析 PMS 检测异常用例数据，利用 PMS 用例编辑接口进行内容回填，根据异常类型修改为正确数据。\n\n 2. 因考虑开发周期问题，选用了较为成熟的数据处理库 pandas ，但该库体量较大，后续考虑基于csv 标准库重新实现应用功能，减少依赖。\n\n 3. 后续建立类似定时任务/流水线的运行机制，周期性触发应用，达到持续保证用例数据质量的目的。\n\n\n7 参考资料#\n\nUrllib 标准库使用\n\nPandas 数据分析","routePath":"/技术文档/技术调研/《针对PMS用例数据检查与自动化工程CSV文件数据同步的方法》调研报告","lang":"","toc":[{"text":"1 相关术语","id":"1-相关术语","depth":2,"charIndex":3},{"text":"2 问题","id":"2-问题","depth":2,"charIndex":667},{"text":"2.1 问题背景","id":"21-问题背景","depth":3,"charIndex":675},{"text":"2.2 问题详情","id":"22-问题详情","depth":3,"charIndex":1076},{"text":"3 现状","id":"3-现状","depth":2,"charIndex":1898},{"text":"3.1 方案描述","id":"31-方案描述","depth":3,"charIndex":2086},{"text":"3.2 方案对比","id":"32-方案对比","depth":3,"charIndex":2426},{"text":"3.3 对比结论","id":"33-对比结论","depth":3,"charIndex":2824},{"text":"4 技术方案","id":"4-技术方案","depth":2,"charIndex":2992},{"text":"4.1 整体设计","id":"41-整体设计","depth":3,"charIndex":3002},{"text":"4.2 关键技术","id":"42-关键技术","depth":3,"charIndex":3621},{"text":"4.2.1 数据爬取与检测","id":"421-数据爬取与检测","depth":4,"charIndex":3632},{"text":"4.2.2 数据同步","id":"422-数据同步","depth":4,"charIndex":4571},{"text":"4.2.3 PMS数据修改","id":"423-pms数据修改","depth":4,"charIndex":5416},{"text":"4.2.4 任务结果收集","id":"424-任务结果收集","depth":4,"charIndex":5546},{"text":"4.2.5 程序运行入口","id":"425-程序运行入口","depth":4,"charIndex":5860},{"text":"5 实验验证","id":"5-实验验证","depth":2,"charIndex":6304},{"text":"5.1 任务启动","id":"51-任务启动","depth":3,"charIndex":6693},{"text":"5.2 任务完成","id":"52-任务完成","depth":3,"charIndex":6747},{"text":"5.3 查看用例检测结果","id":"53-查看用例检测结果","depth":3,"charIndex":6777},{"text":"5.4 数据备份与同步","id":"54-数据备份与同步","depth":3,"charIndex":6933},{"text":"5.5 PMS数据批量修改","id":"55-pms数据批量修改","depth":3,"charIndex":7089},{"text":"5.6 验证结果","id":"56-验证结果","depth":3,"charIndex":7432},{"text":"5.6.1 历史方案耗时","id":"561-历史方案耗时","depth":4,"charIndex":7517},{"text":"5.6.2 新方案耗时","id":"562-新方案耗时","depth":4,"charIndex":8078},{"text":"5.6.3  耗时数据对比","id":"563--耗时数据对比","depth":4,"charIndex":-1},{"text":"5.7 稳定性验证","id":"57-稳定性验证","depth":3,"charIndex":8395},{"text":"6 小结","id":"6-小结","depth":2,"charIndex":8599},{"text":"7 参考资料","id":"7-参考资料","depth":2,"charIndex":9051}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":54,"title":"域管自动化测试技术调研","content":"#\n\n\n现状问题#\n\n域管产品主要分为服务端和客户端，服务端为一个后台服务 Web 平台系统，客户端为分布的 UOS 机器。\n\n域管测试用例中，大量的用例会涉及到服务端和客户端协同操作。\n\n\n服务端方面#\n\n现有域管 AT 主要实现为单接口自动化测试，这类自动化测试相对简单，主要校验接口的入参和返回，但较多业务场景是复合接口的，由于没有可用的 API\n接口文档，导致很多场景没办法做接口自动化。\n\n因此经过评估，服务端复合接口场景的测试，将基于 Web UI 自动化实现。\n\n\n客户端方面#\n\n客户端为分布式的安装 UOS 系统的机器，现有的域管 AT 只能通过 SSH 的方式控制客户端做一些简单的命令行操作，比较局限，无法实现控制客户端做一些复杂的\nUI 功能上的操作。\n\n\n要实现的效果#\n\n基于以上现有问题，域管自动化测试我们希望最终实现的效果是：\n\n * 能控制服务端 Web 平台做复杂的 UI 功能操作，最好能直接驱动系统自带的浏览器进行测试；\n * 能远程控制客户端，既能做简单的命令行的操作，也能做复杂的 UI 功能操作。\n\n\n技术方案#\n\n域管用例涉及服务端和客户端穿插操作，底层功能实现大体也会分为两部分：Server（服务端）、Client（客户端）。\n\n\nServer（服务端）#\n\n基于 Web UI 自动化测试，控制浏览器进行用例执行。YouQu 目前还没有接入 Web UI 测试功能，要接入此功能需要先对工具进行选型。\n\n工具调研#\n\n市面上耳熟能详的可用于 Web UI 自动化测试工具：Selenium、Cypress、Puppeteer、Playwright；\n\n咱们先初步排除掉一些明显不用的：\n\n * Cypress，只支持 JavaScript，而我们自动化人员大多使用 Python 对 JavaScript 不熟悉，排除。\n * Puppeteer，只支持谷歌浏览器，格局没打开，官方不支持 Python，排除。\n\n剩下 Selenium、Playwright，我们从一些方面做对比：\n\n对比指标     SELENIUM   PLAYWRIGHT\n环境安装难度   ✗          ✔\n运行速度     ✗          ✔\n元素等待     ✗          ✔\n智能定位     ✗          ✔\n稳定性      ✔          ✔\n文档       ✔          ✗\n接口测试     ✗          ✔\n\n总结：\n\nPlaywright 作为一个比较新的工具，在文档方便确实没有老牌的 Selenium\n完善，特别是一些示例、方法的使用说明，都还不够好，甚至有些就没有说明，但基本的使用该有的都有。\n\n除了文档方面，Playwright 几乎在各方面碾压 Selenium，很明显 Playwright 以绝对优势获胜。\n\n设计思路#\n\n--------------------------------------------------------------------------------\n\n浏览器对象#\n\nYouQu 框架提供灵活可配置的浏览器对象。\n\n * 提供一个全局默认的对象：page，默认使用系统自带的浏览器进行测试，如果需要指定其他第三方的浏览器，提供配置项可以指定浏览器对应的路径。\n\n * 还需要提供一个对象：native_page，它使用 Playwright 最新的 Chromium 浏览器进行测试。\n\n方法层#\n\n方法层按照 PO 设计思想对域管 Web 平台进行封装。\n\n\n\n目录结构：\n\n\n\n * 基类负责处理通用页面行为；\n * 首页、终端、审计等其他页面类，封装各自页面的元素定位和操作方法；\n * 方法唯一出口用于集成所有的页面类，统一出口提供给上层用例调用。\n\n断言方法#\n\nYouQu 框架统一提供断言语句，以保持统一的断言语句风格。\n\n\nClient（客户端）#\n\n客户端要求能远程控制客户端，既能做简单的命令行的操作，也能做复杂的 UI 功能操作。\n\n设计思路#\n\n--------------------------------------------------------------------------------\n\n通讯协议#\n\n域管客户端部署 YouQu 框架环境，并将 YouQu 框架底层能力注册到 RPC 服务，自动化用例执行端作为 RPC 客户端，在自动化用例执行过程中即可通过\nRPC 协议远程调用域管客户端进行操作。\n\n\n\n注意，这里的域管客户端是作为 RPC 的服务端，而域管的服务端是自动化脚本执行端，是作为 RPC 的客户端。\n\n方法层#\n\n域管客户端的操作有特殊性，其在客户端的操作大多是针对有些应用的，比如打开、关闭某个应用，不像应用的操作对象一般就是应用本身。\n\n因此，域管客户端方法层设计和应用的方法层设计也有区别，需要因地制宜。\n\n目录结构：\n\n\n\n * 基类处理一些通用的操作行为；\n * 以应用维度划分方法类，对哪个应用的操作就封装到对应的应用类里面；\n * 方法层统一出口继承所有的应用类操作，统一出口提供给上层用例调用。\n\n客户端信息#\n\n客户端信息支持命令行入参或配置文件传入远程机器的 user、ip、password 信息；\n\n用例中通过框架提供的 fixture 对象：slaves 获取数据，供用例层使用。\n\n\n隐藏的宝石#\n\n（1）RPC 服务注册的问题#\n\n常规的 RPC 服务注册只能按照函数一个个显示的注册，也就是说如果要将 YouQu 所有底层能力全部释放出来，需要将 YouQu\n所有提供的方法单独做封装，然后逐个注册进 RPC 服务。\n\n这也是业内常用的方案，但是，这样功能很不好。\n\n因为 YouQu 底层代码全是面向对象（基于类）的编程，如果全部单独封装成函数，是一个非常巨大的工作量，而且在后续底层新增修改功能后，又要对注册到 RPC\n服务里面的代码进行修改；\n\n所以我们不想要这样的 RPC 服务功能，而是希望利用好 YouQu 优秀的框架设计，能通过将 YouQu 底层统一的功能出口 src.Src 一次性注册到\nRPC 服务里面，这样后续 YouQu 框架在迭代可以随意新增或修改，远程控制 RPC 服务也不用做任何修改。\n\n解决方案#\n\n使用 zerorpc 实现 RPC ，将 YouQu 的 Src 对象注册到 zerorpc 的服务 API zeroservices 里面，提供 RPC\n服务。\n\n从而实现零注册及维护量的 RPC 服务。\n\n（2）代码补全的问题#\n\n域管客户端基于 RPC\n实现的思路存在一个使用体验的问题，就是编写操作方法调用远程函数，在编辑器里面无法做代码补全，也不能追踪代码，使用者必须完整输入要调用的方法名称。\n\n这对于开发者来说就是，也不是不能用，但是差点儿意思。\n\n因此，我们希望远程控制也能实现编辑器代码补全、代码追踪。\n\n解决方案#\n\n 1. 远程对象返回进行类型注解，解决通过远程对象调用远程方法时可以进行代码补全和代码追踪；\n 2. 远程方法类里面将 YouQu 各底层类继承过来，通过属性拦截器进行特殊处理，先将方法从父类中移除，然后将方法调用传递给远程 RPC\n    对象，使得方法层在编写方法时，可以直接调用本地方法，但实际通过属性拦截器转换到远程对象进行调用，从而实现和本地调用相同编程体验，调用逻辑、代码维护也更加\n    优雅简介。\n\n\n总结#\n\n基于以上的实现思路，我们可以实现域管自动化测试的目标。通过使用 Playwright 实现服务端的 Web UI 自动化测试，以及通过 RPC\n服务实现客户端的远程控制，我们能够有效地模拟服务端和客户端之间的交互。\n\n对于服务端，通过 YouQu 框架提供的浏览器对象和方法层设计，我们可以实现对 Web 平台复杂 UI 功能的自动化操作。 虽然 Playwright\n在自动化测试圈内知名度还不高，但我们相信未来它一定能站在领域的山顶，因此我们大胆使用它，押注未来。\n\n对于客户端，通过 RPC 服务的部署和远程控制，我们可以实现对远程 UOS\n机器上应用的自动化操作。通过应用维度的方法层设计，我们可以灵活地处理不同应用的操作，满足复杂 UI\n功能测试的需求。此外，通过命令行或配置文件传入客户端信息，我们可以方便地管理远程机器的测试环境。\n\n虽然目前存在 RPC\n服务注册和代码补全的问题，但这并不影响我们基于现有思路实现域管自动化测试的目标。在后续的迭代中，我们将逐步解决这些问题，进一步提升自动化测试的体验和效果。\n\n总之，通过以上的实现思路，我们可以信心满满地推进域管自动化测试的工作，提高测试效率，降低人力成本，为域管产品的质量和稳定性提供有力保障。","routePath":"/技术文档/技术调研/域管自动化测试技术调研","lang":"","toc":[{"text":"现状问题","id":"现状问题","depth":2,"charIndex":3},{"text":"服务端方面","id":"服务端方面","depth":3,"charIndex":95},{"text":"客户端方面","id":"客户端方面","depth":3,"charIndex":239},{"text":"要实现的效果","id":"要实现的效果","depth":2,"charIndex":340},{"text":"技术方案","id":"技术方案","depth":2,"charIndex":473},{"text":"Server（服务端）","id":"server服务端","depth":3,"charIndex":541},{"text":"工具调研","id":"工具调研","depth":4,"charIndex":628},{"text":"设计思路","id":"设计思路","depth":4,"charIndex":1214},{"text":"Client（客户端）","id":"client客户端","depth":3,"charIndex":1647},{"text":"设计思路","id":"设计思路-1","depth":4,"charIndex":1705},{"text":"隐藏的宝石","id":"隐藏的宝石","depth":3,"charIndex":2266},{"text":"（1）RPC 服务注册的问题","id":"1rpc-服务注册的问题","depth":4,"charIndex":2274},{"text":"（2）代码补全的问题","id":"2代码补全的问题","depth":4,"charIndex":2749},{"text":"总结","id":"总结","depth":2,"charIndex":3123}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":55,"title":"`Python`调用动态库运行时报静态`TLS`块不能分配内存根因分析报告","content":"Python调用动态库运行时报静态TLS块不能分配内存根因分析报告#\n\n\n一、相关术语#\n\n缩写                   全称                     描述\nPython               Python                 一种跨平台的计算机程序设计语言\nC++                  C++                    一种静态数据类型检查的、支持多重编程范式的通用程序设计语言\njemalloc             jemalloc               一种内存分配器\nTLS                  Thread-Local Storage   一种实现线程私有全局变量的机制\nInitial Executable   Initial Executable     一种在程序启动后从加载的共享对象中引用TLS变量的模型\n\n\n二、问题概述#\n\n【背景】\n\n基于Python、C++，通过白盒测试手段完成对某些重要功能在代码层面的测试\n\n【复现步骤】\n\n1.Python通过ctypes第三方库调用C++ 动态库so文件中的函数\n\n\n\n2.运行时报libjemalloc.so.2 cannot allocate memory in static TLS block\n\n【期望】\n\n可正常调用共享库so中的函数并得到正确的结果。\n\n【环境】\n\n硬件环境：X86平台、ARM平台（龙芯平台、申威平台未依赖jemalloc）\n\npython：3.7\n\njemalloc:5.1.0-3\n\n\n三、问题分析#\n\n在X86平台和ARM平台上，Python调用C++动态库so中函数并运行的流程如下图所示，Python程序使用第三方库ctypes加载libTestlib、并通\n过jemalloc进行内存分配。\n\n\n\n。\n\n【分析】\n\n加载动态库jemalloc时报不能在静态TLS块中分配内存，可以猜测导致出现报错的原因有两种：\n\n * 第一：Python使用第三方库ctypes调用C++动态库存在问题。\n * 第二：jemalloc内部在分配内存时有一些特性导致加载C++动态库存在问题。\n\n对第一种情况进行分析\n\n使用ctypes.cdll.LoadLibrary的方式加载依赖jemalloc的动态库与加载不依赖jemalloc的动态库，验证Python是否能正常加载so\n文件：\n\n1.通过ctypes加载不依赖jemalloc的共享库：ldd libfibo.so列出该库依赖的其他共享库\n\n\n\n\n\n2.通过ctypes加载依赖jemalloc的共享库：ldd libfjemalloc.so列出该库依赖的其他共享库\n\n\n\n\n\n根据调用两个共享库的对比结果可知，Python通过ctypes第三方库加载C++共享库的方案是可行的。\n\n对第二种情况进行分析\n\njemalloc是一个能够快速分配/回收内存，减少内存碎片，对多核友好，具有可伸缩性的内存分配器。\n\nTLS线程局部缓存，将数据和执行的特定的线程连续起来，在线程内部，各个函数可以像使用全局变量一样调用它，但它对线程外部的的其他线程是不可见的。\n\nTLS有４种访问模型，每个TLS的引用均遵循其中之一，另外，可以从较一般的访问模型转换为更优化的访问模型。\n\n访问类型                                                         解释\nGeneral Dynamic (GD) - dynamic TLS                           此模型允许从共享对象或动态可执行文件引用所有TLS变量，当TLS块首次从特定线程引用时，该模型还支持延迟分配TLS块\nLocal Dynamic (LD) - dynamic TLS of local symbols            该模型是对GD模型的优化。编译器可以确定变量是在本地绑定的，还是在正在构建的对象中受保护的\nInitial Executable (IE) - static TLS with assigned offsets   这个模型只能引用作为初始静态TLS模板一部分的TLS变量。这个模板由进程启动时可用的所有TLS块以及一个小的备份预留块组\n                                                             成。（通过固定预留块来满足有限数量TLS的访问）\nLocal Executable (LE) - static TLS                           这个模型只能引用作为动态可执行文件的TLS块的一部分的TLS变量\n\n查看jemalloc源码可知，jemalloc默认打开initial-exec模型并定义了JEMALLOC_TLS_MODEL\n\n\n\n通过JEMALLOC_TLS_MODEL，找到了tsd.h，里面的头文件清晰的解释了定义与不定义JEMALLOC_TLS_MODEL的区别,如果默认开启了ini\ntial-exec模型，即定义了JEMALLOC_TLS_MODEL，则使用tsd_tls.h，如果没有，则使用tsd_generic.h\n\n\n\n查阅tsd_tls.h源码：直接将变量赋值给了已经存在的内存地址\n\n\n\n查阅tsd_generic.h：先申请内存空间，再将变量赋值给申请的内存地址\n\n\n\n综上分析，jemalloc默认开启initial-exec模型，直接将静态TLS变量指向已有的内存空间，但Python是使用dlopen的方式加载动态库，即没有\n分配好的内存空间，因此相关报错大概率与jemalloc的initial-exec模型特性有关。\n\n\n四、实验验证#\n\n根据分析结果，相关报错大概率与jemalloc的initial-exec模型特性有关。那么可以通过在编译jemalloc时启用和禁用该功能来判断该分析结论是否正\n确。\n\n\n\n【影响分析】\n\n根据问题分析中的源码分析可知，禁用与不禁用initial-exec的不同在于变量的内存空间分配上，不会对原有代码的功能逻辑产生影响。\n\n【实验环境】\n\n系统：uos 20 1030\n\npython：3.7\n\njemalloc:5.1.0-3\n\n【实验设计】\n\n实验操作：\n\n操作1：编译一个依赖jemalloc的动态库libtest.so。\n\n操作2：对jemalloc进行重新编译禁用initial-exec。\n\n操作3：进行操作2前，使用dlopen加载libtest.so，记录运行结果。\n\n操作4：进行操作2后，使用dlopen加载libtest.so，记录运行结果。\n\n实验步骤：\n\n操作1->操作3->操作2->操作4\n\n实验期望： $$ 对jemalloc重新编译后，可通过dlopen方式正常加载test.so $$\n\n【实验验证】\n\n步骤一：首先完成操作1，编译一个依赖jemalloc的动态库libtest.so。\n\n\n\n使用如下命令进行编译\n\ng++ -fPIC -shared test.cpp -o libtest.so -ljemalloc\n\n步骤二:使用Python直接调用libtest.so，运行结果如下：\n\n\n\n步骤三：重新编译jemalloc，禁用initial-exec\n\n\n\n步骤四：使用Python直接调用libtest.so，运行结果如下：\n\n\n\n步骤五：运行结果对比\n\n根据实验结果，未禁用initial-exec时运行程序会报错、禁用initial-exec后程序可正常运行，即禁用前，需要提前预留内存并将其分配给相应的静态TL\nS使用，禁用后，则不再需要提前分配内存，因此数据符合期望值。\n\n最终得出结论：\n\nPython调用动态库报错的根本原因是:jemalloc默认打开了Initial Executable (IE)\n模型，而Python是通过dlopen的方式加载动态库，导致没有预留的内存可分配给相应的静态TLS使用。\n\n\n五、解决方案#\n\n根据上述实验可知，在程序启动后，加载包含静态TLS的共享对象时，会给这些静态TLS分配内存，由于Python的第三方库ctypes是使用dlopen的方式加载动\n态库（以dlopen的方式加载动态库只能在程序运行时进行内存分配，不能提前分配内存）导致报不能在静态TLS中分配内存的错误。\n\n方案一：更换动态库的依赖对象\n\n既然调用依赖jemalloc的动态库，会报不能在静态TLS中分配内存的错误，那么可以换一种内存分配器来规避该问题，常见的内存分配器有tcmalloc、jemal\nloc、ptmalloc，如果我们的动态库在编译时没有指定jemalloc，则默认链接到ptmalloc，即经过上面的问题分析可知，使用ptmalloc内存分配\n器不会出现相关报错。\n\n方案二：禁用jemalloc的Initial Executable模型特性\n\n使用jemalloc会报相关错误的原因是jemalloc5新增了一个新特性，会在加载包含静态TLS的动态库时给静态TLS分配内存，但由于使用dlopen的方式加\n载动态库，没有静态存储区可用，因此我们可以通过禁用jemalloc的这个特性来解决这个问题，可使用shell脚本来实现该操作的自动化。\n\n\n\n方案比较\n\n从可行性、可操作性、稳定性等方面进行考虑可知，由于我们是通过Python加载动态库的方式对开发的C++源码进行测试，而开发构建出来的动态库在X86平台和ARM平\n台默认依赖jemalloc（龙芯和申威未依赖jemalloc），如果要更换内存分配器，则潜在影响是未知且巨大的，方案一从可操作性、稳定性方面被否决；方案二目前能\n解决该问题，且可操作性很强，影响也较小。\n\n       方案一   方案二\n可行性    可行    可行\n易操作性   较差    较好\n跨平台性   不可行   可行\n稳定性    不稳定   稳定\n\n影响评估:\n\njemalloc默认开启Initial\nExecutable模型特性的优点：在对静态TLS进行内存分配时可直接赋值，不需要每次都重新申请内存空间，可使性能有一定的提升。\n\njemalloc禁用Initial\nExecutable模型特性的影响：首先，在性能方面会有一定的影响，其次，在动态申请内存时会存在一定的风险，例如可能会遇到没有内存可用的极端情况等。本次使用场景\n为基于Python、对Ｃ++动态库的白盒测试，因此在性能及其他方面的影响可忽略。\n\n最终结论：\n\n最终选择方案二来解决该问题，即禁用jemalloc的Initial Executable模型特性。\n\n\n六、小结#\n\n问题描述：Python通过ctypes第三方库调用C++ 动态库so文件中的函数，运行时报libjemalloc.so.2 cannot allocate\nmemory in static TLS block。\n\n根因查找步骤：现象->分析->假设->实验->验证->结论。\n\n根本原因：jemalloc5有一个新特性，在加载共享对象时会给静态TLS分配预留内存。由于Python使用dlopen的方式加载共享对象，不能提前预分配内存导致\n报错。\n\n解决方案：重新编译jemalloc禁用Initial Executable模型特性。\n\n优化/改进：可向在jemalloc源码中自动判定是否需要开启TLS的Initial Executable特性的方向探索\n\n收获与启示：在平时工作过程中，需要多多学习系统底层相关理论知识，在原理上实践。\n\n\n七、参考资料#\n\n * jemalloc源码\n\n * TLS四种模式介绍","routePath":"/技术文档/根因分析/Python调用动态库运行时报静态TLS块不能分配内存根因分析报告","lang":"","toc":[{"text":"一、相关术语","id":"一相关术语","depth":2,"charIndex":36},{"text":"二、问题概述","id":"二问题概述","depth":2,"charIndex":412},{"text":"三、问题分析","id":"三问题分析","depth":2,"charIndex":691},{"text":"四、实验验证","id":"四实验验证","depth":2,"charIndex":2431},{"text":"五、解决方案","id":"五解决方案","depth":2,"charIndex":3378},{"text":"六、小结","id":"六小结","depth":2,"charIndex":4478},{"text":"七、参考资料","id":"七参考资料","depth":2,"charIndex":4857}],"domain":"","frontmatter":{"Author":"张芮"},"version":""},{"id":56,"title":"rootfs进入MATE桌面后打开终端不能执行reboot指令根因分析","content":"#\n\n\n一、相关术语#\n\n全称                缩写       描述\nRoot FileSystem   rootfs   根文件系统，针对特定的操作系统的架构，一种实现的形式;具体表现为，特定的目录（就理解为Windows的文件夹），目录之间\n                           的关系，即组织架构，以及特定的各种文件\nMATE              MATE     MATE 是一个Linux桌面环境，它是基于已经停止维护的GNOME2代码库开发而成。\nX Server          /        X\n                           Server是Linux系统里面图形接口服务器的简称。Windows系统的界面是这个系统不可分割的一部分，各种窗口操作界\n                           面显示都是由系统核心直接管理的，而Linux的图形界面并不是系统的必要组成部分，它可以在无界面的条件下运行。当需要Lin\n                           ux提供界面的时候，系统就会建立一个或者数个X\n                           Server，通过X协议跟窗口管理器交互，由独立于系统的应用程序来产生窗口，状态栏，按钮之类的交互界面。\nX Session         /        X Session是指X Server启动后直到X Server关闭之间的这段时间。这期间一切跟X相关的动作都属于X\n                           Session的内容\n\n\n二、问题概述#\n\n1、问题引入\n\n专用设备系统多个架构中，对arm架构系统开发板构建了一个适用RK3399开发板的rootfs GUI版本系统。在rootfs\nGUI版本系统启动后登录桌面时，普通用户终端中不能执行reboot指令（Bug链接）。\n\n2、硬件环境\n\n * 设备型号：RK3399\n\n * 处理器：Dual-core Cortex-A72 up to 1.8GHz & Quad-core Cortex-A53 up to 1.5GHz\n   六核处理器\n\n * 内存：4GB LPDDR4\n\n * 存储：板载 SPI Flash（16MB ）高速 eMMC 32GB\n\n * 显卡：Mali-T860 MP4 四核 GPU\n\n3、软件环境\n\n * 操作系统：uniontechos-device-20-gui-1000_ARM64-RK3399-20210225-1400.img\n * 桌面版本：1.20.4-2\n * terminal版本：lxterminal（ 0.3.2-1）& mate-terminal （1.20.2-2）\n\n4、复现步骤\n\n（1）使用开发板烧录工具（upgrade_tool），烧录镜像uniontechos-device-20-gui-1000_ARM64-RK3399-20210\n225-1400.img；\n\n（2）烧录完成后，系统上电自动开机；\n\n（3）系统开机后，输入密码登录系统；\n\n（4）终端中执行reboot重启系统。\n\n5、问题现象\n\nrootfs进入MATE桌面后打开终端普通用户终端中不能执行reboot指令。如图1 ：\n\n![](/data/图1 问题现象.png)\n\n6、期望\n\n作为桌面版系统，重启系统是常用且不可缺少的指令命令，当不可使用时，会对普通用户造成极其不好的影响，期望可以正常运行重启命令。并且对比ARM裁剪系统GUI版本，普\n通用户可以执行reboot命令，RK3399 开发版GUI版本需要和ARM裁剪系统GUI版本表现保持一致。\n\n\n三、问题分析#\n\n启动RK3399系统后，从greeter登录“uos”用户，打开终端执行reboot，提示bash: reboot:\n未找到命令。首先猜测是系统缺失reboot程序，但是切换root用户后，重启、关机等命令又可以正常运行。继续尝试shutdown now、ip\naddr等常用命令，依旧提示未找到命令。\n\n当在shell命令行界面执行一个命令时，shell必须搜索系统目录来找到对应的程序。PATH环境变量定义了用于进行命令和程序查找的目录。而reboot等命令位于\n系统/usr/sbin目录下，通过find查找，可以找到reboot文件的存放位置，但是通过which\nreboot进行查找，却返回为空，也就是在当前用户环境变量中并不存在reboot文件的路径。在当前“uos”用户终端中打印系统环境变量PATH，如下：\n\n\n\n确定了当前系统环境变量中缺少/usr/sbin/（超级用户指令都位于/usr/sbin）。\n\n尝试通过tty登录系统，执行reboot，系统正常响应了重启。在tty下查看PATH环境变量，变量中存在超级用户指令所在路径的变量信息/sbin:/usr/sb\nin/，表示仅通过桌面登录的方式会触发此问题现象。并且由于从桌面启用shell终端，切换到root用户可以正常执行reboot等命令，普通用户无法执行，所以猜测\n环境变量加载后，被某种文件加载时进行了重写。\n\n查阅资料，了解到linux系统环境变量区分三类变量配置。见表2：\n\n类型     配置文件           作用域\n局部变量   ~/.bashrc      包含专用于当前bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取\n用户变量   ~/.profile     每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下，他设置一些环境变\n                      量，执行用户的.bashrc文件\n全局变量   /etc/profile   为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行。并从/etc/profile.d目录的配置文件中搜集sh\n                      ell的设置\n\n登录Linux时，首先启动 /etc/profile文件，然后再启动用户家目录下的~/.profile文件和~/.bashrc文件，执行顺序为：\n\n\n\n了解环境变量配置文件加载顺序后，按照加载顺序检查环境变量配置对于PATH的定义是否有缺失，查看/etc/profile对全局环境变量的配置代码如下：\n\n\n\n从对系统全局环境变量的配置查证，不管是普通用户还是root用户，在PATH中都有加入/sbin:/usr/sbin，并将PATH进行了export导出。所以tt\ny下查看环境变量无缺失，reboot指令也可以响应运行。继续查看配置文件~/.profile和~/.bashrc对于PATH变量是否有进行覆盖或者重写：\n\n\n\n查看配置文件脚本后，发现~/.bashrc没有对PATH进行任何操作，~/.profile中虽然有对PATH重新赋值，但是也仅仅在已有$PATH的基础上自增部分\n环境变量（/$HOME/bin目录和$HOME/.local/bin），并没有对全局变量配置文件/etc/profile中定义的PATH变量进行替换、覆盖。便猜\n测是系统在登录桌面环境后，没有执行调用全局变量配置文件/etc/profile导致环境变量异常。\n\n随即在/etc/profile、~/.profile、~/.bashrc加入调试信息进行验证：\n\n\n\n添加调试信息后，重启系统，并从greeter登录“uos”进入系统，登录系统后启动lxterminal和mate-terminal\n终端，终端均没有打印/etc/profile和 用户家目录下的\n.profile中脚本第一行加入的调试信息。只打印了用户家目录下的.bashrc中添加的调试信息。但是通过在终端中登录\n用户的方式，系统会按照配置文件的加载顺序进行加载，按照顺序打印出3行调试信息。如图3：\n\n![](/data/图3 调试详情.png)\n\n阅读bash man手册以及shell相关资料，得知直接启动终端执行命令的方式为非登录式（no-login shell）、交互式（interactive\nshell）行为。如表3 shell启动方式介绍，该行为下不会去运行任何profile和rc文件，只有登录式（login\nshell）会在登录时自动执行/etc/profile和~/.profile文件。从此处分析，无法使用reboot等命令属于正常情况。\n\n启动方式                          说明\n登录式（login shell）              需要用户名、密码登录后才能进入的shell（或者通过\"--login\"选项生成的shell）。它会首先读取和执行/etc\n                              /profile全局配置文件中的命令，然后依次查找~/.bash_profile、~/.bash_login 和\n                              ~/.profile这三个配置文件，读取和执行\n非登录式（non-login shell）         不需要输入用户名和密码即可打开的Shell，例如：直接命令“bash”就是打开一个新的非登录shell，在Gnome或K\n                              DE中打开一个“终端”（terminal）窗口程序也是一个非登录shell。在非登录shell里，只读取\n                              ~/.bashrc （和 /etc/bash.bashrc、/etc/bashrc ）文件\n交互式（interactive shell）        在终端上执行，shell等待用户的输入，并且立即执行用户提交的命令\n非交互式（non-interactive shell）   以shell script方式执行，在这种模式下，shell不与用户进行交互，而是读取存放在文件中的命令，并且执行\n\n\n\n但是对比ARM裁剪系统GUI版本，同样的使用场景，却可以正常使用reboot等命令。按照rootfs添加调试信息的方式，在裁剪系统GUI版本/etc/profi\nle、~/.profile、~/.bashrc加入调试信息进行验证。发现在启动后登陆桌面后，打开终端会打印加载这三个配置文件的调试信息。由于rootfs\nGUI版本采用的MATE桌面，而ARM裁剪系统GUI版本采用的DDE桌面环境，不同的桌面环境在启动时，对于环境变量的加载也可能出现差异。所以判断裁剪系统GUI版\n本对此问题进行了单独的处理。\n\n因此确认 rootfs\nGUI版本桌面终端打开后不能直接使用reboot，根本原因是因为在启动非登录式shell时，系统没有加载/etc/profile配置文件，引起环境变量PATH中\n缺少/sbin:/usr/sbin导致。\n\n\n四、实验验证#\n\n\n4.1 程序设想#\n\n经过以上分析，得出结论：RK3399开发版-GUI\n系统启动从greeter登录后，打开终端无法直接执行重启等操作，是由于系统没有加载/etc/profile全局变量配置文件，导致PATH变量中缺少/sbin:/\nusr/sbin，从而导致reboot不能使用。只要在打开终端时，需要将PATH环境中追加/sbin:/usr/sbin。\n\n\n4.2 实验验证（1）#\n\n由于进入系统桌面后PATH环境变量都缺少/sbin:/usr/sbin才导致不能使用该目录下的应用程序。在每次打开终端窗口时，将环境变量进行补全，理论上可以解决\n问题现象。启动系统进入桌面，打开终端窗口后补全PATH环境变量，如图4：\n\n代码：\n\n\n\n![](/data/图4 手动补全环境变量.png)\n\n追加环境变量后，执行reboot命令，系统响应重启。\n\n\n4.3 实验验证（2）#\n\n虽然不会自动加载全局变量，但是每次打开终端，属于交互式（interactive shell）行为，在该行为模式下，会自动加载 bash\n配置文件，意味着可以在加载 bash 配置文件时或者加载之前， 将$PATH环境中追加/sbin:/usr/sbin便能解决。\n\n/etc/bash.bashrc 配置文件是为每一个运行bash shell的用户执行此文件，里面包括如自动补全等功能配置。当bash\nshell被打开时，该配置文件被调用执行，阅读其代码内容，并无对PATH进行赋值定义，随即在脚本末尾增加以下内容：\n\n\n\n添加保存后，重启系统，登录桌面后打开终端，终端打印PATH变量正常，如图5所示，执行reboot系统正常重启。\n\n![](/data/图5 自动加载环境变量-1.png)\n\n继续边缘验证，该方式虽然可以解决此问题，但是存在不足，当在同一个终端中再次登录一个用户或者以登录方式打开shell，由于系统会自动先加载/etc/profile\n，然后再加载/etc/bash.bashrc ，所以导致变量值重复。如图6：\n\n![](/data/图6 自动加载环境变量-2.png)\n\n\n\n\n五、解决方案#\n\n在上述实验验证和问题分析中已经找到了问题根源，针对问题设计了两个解决方案。\n\n5.1 解决方案一#\n\n5.1.1在bash环境变量中追加PATH并导出#\n\n该方案保证每次启动的bash中都不会缺失/sbin:/usr/sbin，从而解决问题。由于直接在bash全局变量配置文件/etc/bash.bashrc中对$P\nATH进行追加/sbin:/usr/sbin，会导致每次启动一个bash时，变量持续自增，所以对解决代码进行修改，设计如下：\n\n\n\n5.1.2实际验证#\n\n将此解决方案提供至系统开发人员，合入构建镜像中。构建系统完成后，烧录系统至RK3399开发板。重新启动系统。从用户界面登录系统。打开终端窗口，查询PATH环境变\n量，变量内容完整，无缺失，多次在终端中执行bash命令，PATH变量没有持续自增。执行reboot命令，系统成功重启。重新开机后分别在tty、远程ssh连接、终\n端登录root账户，执行reboot、shutdown now，系统均响应正常。\n\n5.2 解决方案二#\n\n5.2.1在启动X Server时自动导入profile#\n\n在裁剪系统GUI版本/etc 目录下寻找调用/etc/profile的配置代码，最终在/etc目录下发现在/etc\n/X11/Xsession.d/目录下存在一个关于profile的可执行脚本\"01deepin-profile\n\"。查阅X11/Xsession.d/相关资料得知，系统启动时会自动启动X Server，X Server启动时，会进入/etc\n/X11/Xsession.d/目录轮询地执行所有脚本。所以，在裁剪系统GUI版本上，当执行了\"01deepin-profile\n\"后，便把/etc/profile下的PATH进行导出。等到用户登录系统后，从桌面启动终端，终端环境会继承X\nServer服务载入的环境变量。这样设计的好处在于，用户启动系统登录后，系统全局环境变量已经准备完毕，用户直接能使用完整的系统环境变量。\n\n而RK3399 rootfs-GUI镜像中不存在此配置文件，启动系统后，X\nServer没有可以载入profile的可执行脚本，导致用户从桌面打开终端后，无法使用reboot命令。所以rootfs增加此可执行脚本，即可解决该问题。\n\n在/etc /X11/Xsession.d/新增可执行脚本“profile”，代码如下：\n\n\n\n5.2.2实际验证#\n\n将此解决方案提供至系统开发人员，合入构建镜像中。构建系统完成后，烧录系统至RK3399开发板。重新启动系统。从用户界面登录系统。打开终端窗口，执行reboot命\n令，系统成功重启。重新开机后分别在tty、远程ssh连接、终端登录root账户，执行reboot、shutdown now，系统均响应正常。\n\n5.3 方案对比#\n\n对比两种解决方案，如表4所示，列出了两种方案的优缺点：\n\n序号   方案                        优点                                                             缺点\n1    在bash环境变量中追加PATH并导出       1、问题处理方法简单2、每次启动终端窗口，均会判断一次环境变量是否齐全，不全时自动补充                    1、处理时调用grep，增加对于增加PATH的代码逻辑2、每次打开终端窗口均会判断一次环境变量，可能增加系统资源负载\n2    在启动X server时自动导入profile   1、问题处理方法简单2、能与裁剪系统GUI版本原生方法保持一致3、只有启动系统登录时会加载一次环境变量，不会造成过多的系   如果/etc/profile文件丢失，则问题会再次出现\n                               统资源负载\n\n两种解决方案都能解决当前问题，但是系统触发加载环境变量流程不同。且GUI版本目前为止没有出现异常情况。所以综合比较，采用方案2，在启动X\nServer时自动导入profile。\n\n得出问题结论以及解决方案后，后续合入代码工作需要由系统开发人员进行代码合入。完成代码合入后，再由测试人员对问题进行回归测试以及边缘测试。\n\n\n六、小结#\n\n6.1问题总结#\n\n在RK3399 开发版\nrootfs系统，登录桌面后启动终端无法使用reboot的问题原因是因为环境变量PATH中缺少/sbin:/usr/sbin。当缺少这部分环境变量时，系统不能进\n入/sbin\n和/usr/sbin中寻找对应的应用程序，而reboot等程序存放路径或者链接指向正好是这两个目录。所以导致reboot执行时，提示不可用。解决此问题的办法即在\n系统启动bash时或者之前将PATH环境变量补充完整，使系统可以正确找到程序的存放位置。\n\n6.2更适合的解决方案#\n\n两种解决方案，处理均不复杂。但是方案1，在系统持续使用的过程中，可能造成系统资源的占用增加。对于实际使用或许会造成微小的影响。方案2\n，只有启动登陆桌面的时候会进行一次环境加载，既能解决问题，不会造成系统负载增加，并且能与目前已经测试稳定的GUI系统保持一致。可以最大程度减小系统不稳定的风险。\n所以最终确定方案2为更适合的解决方式。\n\n6.3进阶方案#\n\n专用设备系统gui版本区分了常规版本和rootfs版本，在功能、需求上几乎是一致的。像是此类缺失某个配置文件一类的问题，可以在系统构建之前对比两个版本 /etc\n目录下的文件是否保持一致。对于差异的配置文件提前分析构建系统后会造成的影响，最大程度避免构建后的两个版本系统存在基础功能的异常差异。\n\n6.4收获#\n\n在分析问题的过程中，除了需要多对系统知识进行了解以外，还需要保持刨根问底的心态，才能从问题发生根本解决问题，而不是仅仅从问题表象解决就放弃根因。此次解决此问题，\n认识了shell的四种状态（登录式、非登录式、交互式、非交互式）。其次，在分析问题时，可以了解一部分系统的运行逻辑，对后期的Linux系统测试工作能提供一些测试\n思路。\n\n在分析问题的过程中，可以快速认识到自身对于系统知识的欠缺部分，需要在后续工作和学习中进行补充。\n\n\n七、参考资料#\n\nLinux的XServer\n\nShell Setup Files","routePath":"/技术文档/根因分析/rootfs进入MATE桌面后打开终端不能执行reboot指令根因分析","lang":"","toc":[{"text":"一、相关术语","id":"一相关术语","depth":2,"charIndex":3},{"text":"二、问题概述","id":"二问题概述","depth":2,"charIndex":710},{"text":"三、问题分析","id":"三问题分析","depth":2,"charIndex":1574},{"text":"四、实验验证","id":"四实验验证","depth":2,"charIndex":4602},{"text":"4.1 程序设想","id":"41-程序设想","depth":3,"charIndex":4612},{"text":"4.2 实验验证（1）","id":"42-实验验证1","depth":3,"charIndex":4794},{"text":"4.3 实验验证（2）","id":"43-实验验证2","depth":3,"charIndex":4991},{"text":"五、解决方案","id":"五解决方案","depth":2,"charIndex":5508},{"text":"5.1 解决方案一","id":"51-解决方案一","depth":4,"charIndex":5556},{"text":"5.2 解决方案二","id":"52-解决方案二","depth":4,"charIndex":5958},{"text":"5.3 方案对比","id":"53-方案对比","depth":4,"charIndex":6700},{"text":"六、小结","id":"六小结","depth":2,"charIndex":7311},{"text":"七、参考资料","id":"七参考资料","depth":2,"charIndex":8122}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":57,"title":"Jenkins环境搭建以及任务创建","content":"#\n\n\n环境搭建#\n\n下面主要讲解一下利用Jenkins容器搭建Jenkins环境\n\n1、下载kenkins容器镜像(建议下载lts稳定版本)\n\n\n\n2、创建docker的文件影射卷\n\n\n\n3、运行容器\n\n\n\n8080端口是Jenkins对外服务开放的端口\n\n50000端口是slave节点与Jenkins的通讯端口\n\n4、查看容器启动日志，查看Jenkins的初始密码\n\n\n\n5、通过web端8080端口，访问Jenkins登录页面，使用初始密码可以成功登录\n\n6、进入插件选择页面，选择自己想要使用的插件\n\n7、创建用户，创建Jenkins URL等基础配置，Jenkins安装完成\n\n\n任务创建#\n\n1、入口\n\n(1) 点击\"新建Item\"按钮，进入任务创建页面\n\n\n\n(2)可以选择创建一个新的任务，输入任务名称，选择任务类型，点击确定即可，也可以选择复制一个现有的任务，输入任务名称，填入想要复制的任务路径，点击确定\n\n2、任务设置\n\n这里以'Freestyle project'类型任务进行举例\n\n(1)通用模块设置\n\n * 填写项目的描述信息\n\n * 设置用户权限\n\n * 项目重构：重新构建这个作业而不需要再次输入参数，也就是说，它会使用上一次构建时使用的参数值直接进行构建\n\n * 任务构建参数选择：\n\n添加一些参数变量信息到你的Jenkins工程当中，根据参数类型，每个参数都有一个Name和某种类型的Value。当构建开始时，这些名称-值对将作为环境变量导出，\n允许构建配置的后续部分(例如构建步骤)访问这些值，例如通过使用${PARAMETER_NAME}语法使用这些变量\n\n * 禁止重构，勾选后，任务将不支持重构功能\n\n * 限制job的最大并发数量\n\n * 允许项目并发执行\n\n * 限制job的运行环境，填写slave节点的标签即可\n\n(2)源码管理模块\n\n * 设置要在任务中要使用的代码仓\n   \n   Repository URL：代码仓库地址\n   \n   Credentials:ssh私钥，用于免密clone仓库\n\n * 仓库分支设置\n   \n   指定分支：clone仓库的哪个分支\n\n * 添加仓库附加行为\n   \n   根据你使用的版本控制系统，选择一个或多个附加行为。以下是一些常见的 Git 附加行为：\n   \n   * Check out to a sub-directory: 将检出代码放到一个子目录中\n   \n   * Clean before checkout: 在每次检出之前清理工作区，确保不会有遗留的文件\n   \n   * Prune stale remote-tracking branches: 清理不再存在的远程分支的跟踪记录\n   \n   * Advanced clone behaviours: 配置高级克隆选项，如 --depth、--single-branch 等\n\n(3)构建触发器模块\n\n * 任务构建设置\n   \n   * 触发远程构建：当想要利用脚本远程触发Jenkins任务的时候，可以选择此选项\n     \n     * 假如此处勾选了此选项，设置一个token值，用于远程控制任务，我们可以通过python的第三方库python-Jenkins进行任务的构建，日志查\n       看等操作，下面是一个简单的demo\n     \n     \n   \n   * Build periodically：定时触发Jenkins任务，如下，每周的星期五中午 12 点执行任务：H 12 * * 5\n   \n   * Poll SCM：用于设置 Jenkins 任务如何定期检查源码管理系统（SCM）以检测代码更改。如果检测到更改，Jenkins\n     将自动触发构建，如设置为H/15 * * * *，则会15分钟检查一次代码变更情况\n   \n   * Build after other projects are built：用于配置当前项目在其他项目完成构建后进行构建\n\n(4)构建模块\n\n * 点击“增加构建步骤”，可以选择构建的方式，最常见的是Excute shell,可以通过shell命令，进行相关build操作\n\n(5)构建后操作模块\n\n * build完成后，进行的一系列操作，比如说，可以将测试结果通过企业微信发送至项目负责人","routePath":"/编程基础/Jenkins/Jenkins环境搭建以及任务创建","lang":"","toc":[{"text":"环境搭建","id":"环境搭建","depth":2,"charIndex":3},{"text":"任务创建","id":"任务创建","depth":2,"charIndex":295}],"domain":"","frontmatter":{"Author":"zhx"},"version":""},{"id":58,"title":"Pipeline语法介绍","content":"#\n\n\n简介#\n\nPipeline 是一种用于定义和自动化软件交付过程的工具，它可以通过代码进行持续集成和持续交付。Pipeline 主要有两种模式：Declarative\nPipeline 和 Scripted Pipeline。Declarative Pipeline\n提供了一种更简单、结构化的方式来定义构建过程，适合大多数用户；而 Scripted Pipeline 则允许更大的灵活性，采用 Groovy\n语言编写，适合需要复杂逻辑的场景\n\n\nDeclarative Pipline#\n\n\ndemo演示#\n\n\n\n上面是一个简单的流水线，其中包含两个测试阶段，在我们实际工作中可以根据不同的使用场景，设计不同的阶段，每个stage代表一个测试阶段，Jenkins会按照从上到\n下的顺序依次执行每个stage，当前两个测试阶段执行完成后，最后执行post内操作，以上示例只是为了让大家先简单感受一下Pipeline的玩法，下面会详细介绍P\nipeline的重点语法\n\n\n语法讲解#\n\n * stages\n\n含义：包括一个或者多个stage的序列，Pipeline的大部分工作在此执行，必须出现的指令，每个Pipeline代码区间中必须只有一个stages\n\n * stage\n\n含义：包含在stages中，Pipeline完成的所有实际工作都需要包含在stage中，必须出现的指令，需要定义stage的名字\n\n * step\n\n含义：具体执行步骤，包含stage代码区间中，必须出现的指令\n\n\n\n * agent\n   \n   含义：定义Pipeline执行节点，是必须出现的指令\n   \n   参数：\n   \n   * any：可以在任意节点上执行Pipeline\n   * none：不配全局agent，每个stage分配自己的agent\n   * label:指定运行节点的label\n   * node：自定义运行节点配置\n     * label：设置运行节点\n     * customWorkspace：指定工作目录\n   * docker：控制目标节点上的docker运行相关内容\n   \n   使用node参数指定执行节点和工作目录：\n   \n   \n   \n   每个阶段使用不同的节点环境：\n   \n   \n\n * environment\n\n含义：定义全局变量，不是必须出现的指令\n\n\n\n * post\n   \n   含义：定义Pipeline或者stage运行结束时的操作\n   \n   参数\n   \n   * always：无论Pipeline运行的完成状态如何都会运行\n   * changed：只有当前Pipeline运行的状态与之前完成的Pipeline的状态不同时，才会运行\n   * failure:仅当当前Pipeline处于失败状态时才会运行\n   * success：仅当当前Pipeline处于成功状态时才会运行\n   * unstable：只有当前Pipeline具有不稳定状态才能运行\n   * aborded：只有当前Pipeline处于中止状态时才能运行\n\n\n\n * options\n   \n   含义：定义一些Pipeline的特殊属性，不是必须出现的指令\n   \n   * buildDiscarder:保留构建的最大个数（页面上可以显示多少次构建）\n   * disableConcurrentBuilds:不允许并行执行Pipeline任务\n   * timeout：Pipeline超时时间\n   * retry:失败后，重试整个Pipeline的次数\n   * timestamps:预定义由Pipeline生成的所有控制台输出时间\n   * skipStagesAfterUnstable:一旦构建状态进入了“Unstable”状态，就跳过后续stage\n\n使用示例：\n\n\n\nskipStagesAfterUnstable使用示例，此情景会跳过Deploy测试阶段：\n\n\n\n * parameters\n   \n   含义：\n   \n   定义Pipeline的触发参数，不是必须出现的指令，支持数据类型：booleanParam(布尔),choice（选择）,credentials（证书）,\n   file（文件），text（文本）,password（密码）,run（运行时参数）,string（字符串）\n\n定义参数PERSON，触发jenkins工程的时候，需要输入参数的值，才能成功触发工程\n\n\n\n * triggers\n   \n   含义：\n   \n   定义了Pipeline自动触发的方式\n   \n   参数：\n   \n   * cron：接受一个cron风格的字符串来定义Pipeline触发的常规间隔\n   * pollSCM：接受一个cron风格的字符串来定义jenkins检查SCM源更改的常规间隔，如果存在新的更改，则Pipeline将被重新触发\n\ncron demo：\n\n\n\n日志显示：\n\n\n\npollSCM demo：\n\n\n\n日志显示：\n\n\n\n * parallel\n   \n   含义：\n   \n   可以让多个stage并行执行\n   \n   demo：\n   \n   \n   \n   运行流程：\n   \n   \n\n\nScripts Pipeline#\n\n\ndemo演示#\n\n\n\nScripts Pipeline相比Declarative Pipline更加灵活，支持条件判断、循环语句等，下面主要讲解一下重点语句用法：\n\n * try catch语句\n   \n   \n   \n   流水线可以通过try语句捕捉异常，防止异常退出的情况发生\n\n * 条件语句\n   \n   demo：\n   \n   \n\n * 循环语句\n   \n   * for循环\n     \n     \n   \n   * while循环\n     \n     \n   \n   * each方法循环列表\n     \n     \n\n * 执行shell\n   \n   * 书写方式：\n     \n     \n     \n     * 参数含义：\n       \n       script：执行的 Shell 命令或脚本\n       \n       returnStdout（可选）：如果设置为 true，命令的标准输出将被捕获并作为字符串返回，而不是直接打印到 Jenkins 日志中\n       \n       label（可选）：为当前的 Shell 执行步骤提供一个描述性标签\n       \n       returnStatus：如果设置为 true，则会返回命令的退出状态码，而不是输出\n       \n       运行日志：\n       \n       \n\n\nDeclarative Pipline和Scripts Pipeline结合使用#\n\n实际工作中，流水线的设计大多会将Declarative和Scripts结合起来使用，这样设计的流水线，在保证结构清晰、简单的情况下，还可以灵活的满足多种场景。结\n合使用的写法也很简单，主体框架采用Declarative的结构书写方式，在需要Scripts语句的时候，只需要把Scripts语句写在script当中即可，下面\n是一个简单的demo：\n\n","routePath":"/编程基础/Jenkins/Pipeline语法介绍","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"Declarative Pipline","id":"declarative-pipline","depth":2,"charIndex":226},{"text":"demo演示","id":"demo演示","depth":3,"charIndex":249},{"text":"语法讲解","id":"语法讲解","depth":3,"charIndex":437},{"text":"Scripts Pipeline","id":"scripts-pipeline","depth":2,"charIndex":2209},{"text":"demo演示","id":"demo演示-1","depth":3,"charIndex":2229},{"text":"Declarative Pipline和Scripts Pipeline结合使用","id":"declarative-pipline和scripts-pipeline结合使用","depth":2,"charIndex":2825}],"domain":"","frontmatter":{"Author":"zhx"},"version":""},{"id":59,"title":"Docker入门","content":"#\n\n\n安装#\n\n\n官方仓库安装#\n\n\n\n\n阿里云镜像安装#\n\n\n\n安装完之后校验：\n\n\n\n看到这样的输出就说明没问题：\n\n\n\n\n基本使用#\n\n\n拉取Python镜像#\n\n\n\n输出：\n\n\n\n\n查看当前所有镜像#\n\n\n\n输出：\n\n\n\n\n创建并进入容器#\n\n\n\n给容器取个名字：--name python311 ，名字可以自定义；\n\n输出：\n\n\n\n查看下容器的系统环境：\n\n\n\n可以看出来，我们从 Docker 官方拉取的Python镜像是基于 Debian 12 构建的，Python 版本为：3.11.4\n\n这里是进入交互模式，使用 exit 退出之后，容器就停了。\n\n\n查看当前所有容器#\n\n\n\n这里主要输出：容器ID、镜像名称、创建时间、状态、容器名称\n\n\n启动容器#\n\n\n\n\n\n表示此容器已经启动了，你可以使用 sudo docker ps -a 查看一下“状态”；\n\n\n进入容器#\n\n启动之后才能进入容器；\n\n1、docker attach\n\n\n\n\n\n使用 exit 退出容器，容器会停止；\n\n2、docker exec\n\n\n\n\n\n注意，使用 exit 退出容器，容器不会停止；\n\n\n删除容器#\n\n\n\n\nPycharm 配置 Docker 容器内 Python 环境#\n\n\n1、ssh 方式指定远程#\n\n这种方式需要在容器里面安装 ssh 服务\n\n\n\n配置文件\n\n\n\n增加以下内容：\n\n\n\n重启SSH\n\n\n\n\n2、TCP 连接#\n\n首先，配置文件：\n\n\n\n写入：\n\n\n\n然后，修改配置文件：\n\n\n\n这到 ExecStart，改成：\n\n\n\n最后重启服务：\n\n\n\n在 Pycharm 添加解释器界面：\n\n\n\n\n\n输入：tcp://0.0.0.0:2375\n\n点【OK】就行了。","routePath":"/编程基础/Linux/Docker入门","lang":"","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":3},{"text":"官方仓库安装","id":"官方仓库安装","depth":3,"charIndex":9},{"text":"阿里云镜像安装","id":"阿里云镜像安装","depth":3,"charIndex":21},{"text":"基本使用","id":"基本使用","depth":2,"charIndex":64},{"text":"拉取Python镜像","id":"拉取python镜像","depth":3,"charIndex":72},{"text":"查看当前所有镜像","id":"查看当前所有镜像","depth":3,"charIndex":95},{"text":"创建并进入容器","id":"创建并进入容器","depth":3,"charIndex":116},{"text":"查看当前所有容器","id":"查看当前所有容器","depth":3,"charIndex":285},{"text":"启动容器","id":"启动容器","depth":3,"charIndex":330},{"text":"进入容器","id":"进入容器","depth":3,"charIndex":388},{"text":"删除容器","id":"删除容器","depth":3,"charIndex":495},{"text":"Pycharm 配置 Docker 容器内 Python 环境","id":"pycharm-配置-docker-容器内-python-环境","depth":2,"charIndex":505},{"text":"1、ssh 方式指定远程","id":"1ssh-方式指定远程","depth":3,"charIndex":540},{"text":"2、TCP 连接","id":"2tcp-连接","depth":3,"charIndex":608}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":60,"title":"FFmpeg常用命令与参数解释","content":"#\n\n\nFFmpeg 概述#\n\nFFmpeg 是一个极为强大且广泛使用的开源计算机程序，专为处理多媒体文件（包括音频、视频）而设计。它是快速前进（FastForward）MPEG\n的缩写，强调了其在多媒体处理方面的高效性。FFmpeg 的核心功能围绕着音视频的记录、转换、解码、编码以及流化，提供了一个全面的解决方案。\n\n官方文档：https://ffmpeg.org/\n\n\nFFmpeg 常用参数释义#\n\n\n\n提示\n\n这只是 FFmpeg 参数中的一小部分，实际应用中可根据需要组合使用这些参数来完成复杂的多媒体处理任务。\n\nffmpeg -h 命令来获取完整的参数列表和最新信息\n\n\nFFmpeg 常用场景#\n\n1、将视频进行重新编码，转换为其他格式\n\n\n\n2、提取视频文件中的音频内容，不进行编码，直接复制出来\n\n\n\n3、视频剪辑，并不进行额外编码\n\n\n\n4、对视频进行分辨率裁切，并以 H.265 编码，进行视频重新编码\n\n\n\n5、对视频进行分帧\n\n\n\n6、对视频进行常见编码的转换\n\n\n\n视频编解码分享（视频）","routePath":"/编程基础/Linux/FFmpeg常用命令与参数解释","lang":"","toc":[{"text":"FFmpeg 概述","id":"ffmpeg-概述","depth":2,"charIndex":3},{"text":"FFmpeg 常用参数释义","id":"ffmpeg-常用参数释义","depth":2,"charIndex":187},{"text":"FFmpeg 常用场景","id":"ffmpeg-常用场景","depth":2,"charIndex":293}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":61,"title":"FTP服务搭建","content":"#\n\n\n安装#\n\n\n\n\n配置用户#\n\n添加用户组\n\n\n\n配置 FTP 访问用户 uos\n\n\n\n配置 FTP 访问密码\n\n\n\n之后输入 2 次密码即可；\n\n\n修改配置项#\n\n\n\n配置以下内容：\n\n\n\n配置用户列表文件：\n\n\n\n写入\n\n> uos\n\n\n创建FTP目录#\n\n\n\n修改目录权限\n\n\n\n\n重启服务#\n\n\n\n\n一键部署脚本#\n\n","routePath":"/编程基础/Linux/FTP服务搭建","lang":"","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":3},{"text":"配置用户","id":"配置用户","depth":2,"charIndex":11},{"text":"修改配置项","id":"修改配置项","depth":2,"charIndex":77},{"text":"创建FTP目录","id":"创建ftp目录","depth":2,"charIndex":123},{"text":"重启服务","id":"重启服务","depth":2,"charIndex":146},{"text":"一键部署脚本","id":"一键部署脚本","depth":2,"charIndex":156}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":62,"title":"KVM安装配置及使用说明","content":"#\n\n\n一、安装 KVM#\n\n\n\n\n二、命令安装镜像#\n\n\n1、创建存储卷#\n\n\n\n\n2、创建虚拟机#\n\n\n\n\n三、配置远程管理#\n\n\n1、增加 libvirtd 用户组#\n\n\n\n\n2、设置用户到组#\n\n\n\n\n3、设置启动libvirtd服务的用户组#\n\n\n\n在尾行写入\n\n\n\n\n4、增加权限启动配置#\n\n\n\n写入\n\n\n\n\n5、重启服务#\n\n\n\n\n四、常见问题#\n\n1、Requested operation is not valid: network 'default' is not active\n\n解决方案：\n\n","routePath":"/编程基础/Linux/KVM安装配置及使用说明","lang":"","toc":[{"text":"一、安装 `KVM`","id":"一安装-kvm","depth":2,"charIndex":-1},{"text":"二、命令安装镜像","id":"二命令安装镜像","depth":2,"charIndex":17},{"text":"1、创建存储卷","id":"1创建存储卷","depth":3,"charIndex":29},{"text":"2、创建虚拟机","id":"2创建虚拟机","depth":3,"charIndex":42},{"text":"三、配置远程管理","id":"三配置远程管理","depth":2,"charIndex":55},{"text":"1、增加 `libvirtd` 用户组","id":"1增加-libvirtd-用户组","depth":3,"charIndex":-1},{"text":"2、设置用户到组","id":"2设置用户到组","depth":3,"charIndex":90},{"text":"3、设置启动libvirtd服务的用户组","id":"3设置启动libvirtd服务的用户组","depth":3,"charIndex":104},{"text":"4、增加权限启动配置","id":"4增加权限启动配置","depth":3,"charIndex":139},{"text":"5、重启服务","id":"5重启服务","depth":3,"charIndex":161},{"text":"四、常见问题","id":"四常见问题","depth":2,"charIndex":173}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":63,"title":"Linux 上 sudo 免密","content":"#\n\n\n\n或者\n\n\n\n找到\n\n\n\n加个 NOPASSWD: 就好了；\n\n","routePath":"/编程基础/Linux/Linux上sudo免密","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":64,"title":"Linux 上远程桌面 VNC 服务配置","content":"#\n\n\n服务端#\n\n一键部署脚本：\n\n\n\n\n客户端#\n\n\n\n客户端打开 tigervnc-viewer，配置要远程连接服务器地址，点击 Connect，输入密码即可。\n\n\nWayland环境远程桌面（服务端）：#\n\n\n\n启动服务服务端密码1：\n\n\n\n客户端连接 Wayland 远程桌面需要降低画质，否则很卡。","routePath":"/编程基础/Linux/Linux上远程桌面VNC配置","lang":"","toc":[{"text":"服务端","id":"服务端","depth":2,"charIndex":3},{"text":"客户端","id":"客户端","depth":2,"charIndex":21},{"text":"Wayland环境远程桌面（服务端）：","id":"wayland环境远程桌面服务端","depth":2,"charIndex":85}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":65,"title":"Linux&Shell基础","content":"#\n\n\nlinux基础命令#\n\n\n用户与身份#\n\n1、用户#\n\n(1) Root 是管理员，光标前为#\n\n(2) 其他名称为普通用户，光标前为 $\n\n2、切换用户#\n\n(1) su - root 表示切换到管理员权限，需要输入密码，也可以直接用su -\n\n(2) u - 其他用户名，表示切换到其他用户\n\n\n目录的基本操作#\n\nls 列出当前目录的内容(list)#\n\n\n\ncd 改变工作目录#\n\n\n\npwd 显示当前共工作目录的绝对路径#\n\nmkdir创建一个空目录#\n\n\n\nrmdir 只能删除空目录#\n\n通配符#\n\n1、* 代表任意一个（1个或多个）\n\n2、？代表1位，且必须为1位\n\n3、[ ]表示括号中的每一个\n\n * ls test[ab] 结果是 testa testb\n * ls test[0-6] 结果是 从最后一位是 0-6 取匹配\n * ls test[a-Z] 结果是 从最后一位是所有字母去匹配\n * [^a-c] 表示取反，即非 a-c 的字符\n\n4、{ } 字符串，字符串之间用,间隔 （{sta,atb,stc}）\n\n\n文件的基本操作#\n\ntouch 新建文本文件#\n\n\n\nrm 删除文件#\n\n\n\ncp 文件复制#\n\n\n\nmv 文件移动#\n\n\n\n查看文件#\n\n\n\nvim 文件编辑#\n\n1、进入编辑模式\n\n * i 表示在光标当前位置编辑。\n\n * a 表示在光标当前位置的下一个字符开始编辑。\n\n * o 表示在光标下一行开始编辑。O 光标上一行开始编辑。\n\n2、命令行模式\n\n * 0（零）跳到行首（不能跳到行首前的空格处）\n\n * ^ 跳到行首（包括空格）\n\n * $ 跳到行尾\n\n * gg 跳到第一行的行首\n\n * GG 跳到最后一行的行首\n\n * yy 复制单行，5yy或y5y复制5行\n\n * p 粘贴，如果复制是1行，则p到下一行，如果复制的是10行，则p粘贴10行\n\n * dd 删除一行，5dd删除5行\n\n * cc 删除一行，并进入删除模式\n\n * x 删除字符\n\n * dw 删除单词\n\n * 查找 /，n 向下翻，N 向上翻\n\n * w 按单词走\n\n * u 撤销\n\n3、底行模式\n\n * :wq 保存并退出\n * :q! 强制退出\n * / 查找\n * set ic 忽略大小写\n * set noic 取消忽略大小写\n * set nu 内容编号\n * set nonu 取消内容编号\n * %s/spool/linux/g 表示将所有的 spool 替换为 linux ，g 是固定用法。\n\n文件压缩和解压缩#\n\n1、gzip\n\n * 压缩单个文件，以 .gz 结尾，压缩后源文件不在了\n   \n   \n\n * 解压\n   \n   \n\n * gunzip 同 gzip -d\n\n2、bzip2\n\n * 压缩单个文件，以.bz2结尾\n   \n   \n\n * 解压\n   \n   \n\n * bunzip2 同 bzip2 -d\n\n3、xz\n\n * 压缩单个文件，以.xz结尾\n   \n   \n\n * 解压\n   \n   \n\n4、zip\n\n * 压缩\n   \n   \n\n * 解压\n   \n   \n\n * 源文件还在\n\n5、tar (打包)\n\n * 压缩\n   \n   \n\n * gz解压\n   \n   \n\n * z 表示 gzip，j 表示 bzip2，J 表示 xz\n\n * bz2 解压\n   \n   \n\n * xz 解压\n   \n   \n\n\n路径#\n\n1、绝对路径：是以/开头，从根目录开始一级一级往下写（/root/tmp/test）\n\n2、相对路径：不以/开头，从当前路劲开始(tmp/test)\n\n\n文件访问权限#\n\n1、权限分4部分：\n\n * 第 1 位是文件类型；\n * 第 2-4 位是 u（user）用户权限；\n * 第 5-7 位是 g（group）组权限；\n * 第 8-10 位是 o（other）其他用户权限；\n * 第 2-10 位为 a（all）；\n\n\n\n2、文件类型：\n\n * - 普通文件；\n * d 目录；\n * l 软链接；\n\n3、u g o 分别有 r w x（读、写、执行）权限。\n\n4、文件增加权限\n\n\n\n5、文件赋权\n\n\n\n6、给目录加权限，要给目录下所有的文件加权限，才有意义\n\n\n\n7、改变拥有者\n\n\n\n8、改变组\n\n\n\n9、改变拥有者和组\n\n\n\n\n用户管理和组管理#\n\n1、新增用户：\n\n\n\n2、删除用户\n\n\n\n3、添加组\n\n\n\n4、查看组\n\n\n\n5、添加组成员：\n\n\n\n6、删除组成员\n\n\n\n\nfind 文件查找#\n\n\n\n\n\n\n帮助命令#\n\n1、man 命令\n\n查外部命令，查内部命令时会把所有的命令列出\n\n2、help 命令\n\n查找内部命令\n\n\n进程管理#\n\n1、ps -ef\n\n进程快照\n\ntop 命令：实时进程\n\nfree 命令：查看系统内存情况\n\n2、grep 按行过滤，语法：grep 选项 参数\n\n\n\n3、剪切\n\n\n\n4、查看端口号\n\n\n\n5、kill 结束进程\n\n（1）kill filename或kill -15 filename 是建议结束进程。\n\n（2）kill -9 filename 表示强制结束进程。\n\n\n磁盘管理#\n\n1、系统服务\n\n① uname -a 查看操作系统名称及环境\n\n② hostname 查看服务器名称\n\n③ cat /etc/redhat-release 查看系统的具体版本\n\n2、系统磁盘\n\n① df -h 查看磁盘分布信息\n\n② du -h 查看文件占用磁盘情况\n\n3、系统启动\n\n① 关机\n\n\n\n② 重启\n\n\n\n\n软件安装#\n\n1、二进制安装\n\n(1) rpm包（redhat package management）\n\n * 安装：rpm -ivh 程序包\n\n * 卸载：rpm -e\n\n * 查看是否安装： rpm -qa\n\n * 统计多少个安装程序：rpm -qa | wc -l\n\n * 查看安装信息： rpm -qi\n\n * 列出安装目录文件：rpm -ql\n\n * 列出配置文件： rpm -qc\n\n * 安装前查看包信息：rpm -qpi\n\n(2) yum\n\n * 安装：yum install -y 安装包\n\n * 卸载：yum remove 或 yum erase\n\n2、源代码安装\n\n(1) 安装步骤\n\n * ① 解压后找到configure\n\n * ② 执行：./configure --prefix=/usr/local/目录名\n\n * ③ make\n\n * ④ make install\n\n(2) 安装后需要指明路径（配置环境变量）\n\n\n\n(3) 卸载：rm -rf\n\n\nshell程序设计#\n\n\n输入输出#\n\n1、管道 |\n\n（1）表示将前面命令的结果，作为后面命令的参数\n\n（2）cat -n test | head -12 | tail -2 表示取第11 和12行\n\n（3）-v 显示控制字符，-n 对输出行进行编号，-b 和 -n 一样，但空白行不编号。\n\n2、echo\n\n（1）echo $PATH | tr “:” “\\n” 表示输出以：分割换行的格式\n\n（2）echo –n “hello world” 不换行\n\n（3）echo “${PATH}abc“ 表示输出变量PATH的值，后面跟abc\n\n（4）echo “now is $(date)” 命令替换\n\n（5）echo ‘now is ${PATH}’ 单引号可以去掉$的功能，直接输出单引号内的字符\n\n（6）echo –e “hello\\nworld” –e 使引号内转义符生效\n\n（7）\\ 转义符，使后面一个字符失效\n\n3、read 定义一个变量\n\n（1）read username age\n\n（2）read –p “please input your name :” name 表示在输入变量时给出相应的提示。\n\n4、tee\n\ntee -a file 表示将文件追加到末尾\n\n\n\n5.重定向\n\n * ls > file 表示重定向到文件中，会覆盖原有内容；\n * ls >>file 表示追加到文件末尾；\n * ls 2>file 表示标准错误重定向到文件中，会覆盖原有内容；\n * ls &>file 表示标准输出和标准错误一起重定向到文件中；\n * ls 1>file1 2>file2 表示标准输出重定向 file1，标准错误输出重定向到 file2；\n\n\nshell后台执行命令#\n\n1、cron 定时任务\n\n管理员在 /etc/crontab 里面可以编辑定时任务\n\n * 第一列表示 min；\n * 第二列表示 hou；\n * 第三列表示 day；\n * 第四列表示 mon；\n * 第五列表示 week；\n * 第六列表示要运行的命令；\n\n比如：5，25 15 * * *，表示每天的15时的5分和25分运行脚本。\n\n普通用户创建为，执行命令 crontab * * * * * 加选项 -e 编辑 ,-l 查看任务；\n\n3、&\n\n（1）将某个运行的命令，放到后台执行。\n\n（2）nohup 命令 & 比如：nohup sleep 500 &\n\n\nshell变量和参数#\n\n1、系统变量\n\n * 系统变量都是大写；\n\n * 设置环境变量：export 将普通变量变成系统变量；\n   \n   \n\n * 变量命令要求：只能以字母、下划线、数字组成，且不能以数字开头；\n\n * env 查看所有的系统环境变量；\n\n * unset var_name 清除系统环境变量；\n\n2、用户变量\n\n * 设置用户变量：\n   \n   \n\n * 清除变量：set var_name\n\n * set 显示用户所有变量\n\n * source /etc/profile 让 profile 生效\n\n * eho ${name:=peter} 表示如果 name 存在就显示 name 的值，如果不存在就显示 peter\n\n3、位置变量\n\n * 向shell脚本传递参数\n   \n   \n\n$0 表示脚本名称本身（包含前面的路径），$1表示第一个参数，以此类推。\n\n\n\n4、特定变量\n\n\n\n返回值为0即成功，返回非0即失败。\n\n\nshell程序设计流程控制#\n\n\ntest测试命令#\n\n1.文件测试\n\n * [ -f file.txt ] 判断file是否为普通文件\n * [ -d file ] 判断file是否为目录\n * [ -s file ] 判断file文件长度大于0\n\n2.逻辑操作符\n\n * -a\n   \n   [ -f file –a –d file1 ] 表示判断两个条件是否同时满足。（与运算）\n\n * -o\n   \n   [ -f file –o –d file1 ] 表示判断两个条件是否有一个满足。（或运算）\n\n * !\n   \n   表示取非，比如 [ ! –f file ]\n\n3.数值测试\n\n * -eq 数值相等 ，比如 [ “$num” –eq “100” ]\n * -ne 数值不等\n * -gt 第一个数大于第二个数\n * -lt 第一个数小于第二个数\n * -le 小于等于\n * -gt 大于等于\n\n\nexpr 简单计算#\n\n * expr 10 + 10 运算符两边要右空格\n   \n   \n\n\nif条件判断#\n\n * 格式：\n   \n   \n\n * if 条件判断有真假，真则写在 then 后面，假则写在 else 后面，其中真假都可以继续嵌套 if 语句。\n\n\n\n\nfor循环#\n\n * 格式\n   \n   \n\n * 举例\n   \n   \n\n\nwhile和until 循环#\n\n * 格式\n   \n   \n\n * while 是判断条件为真时执行命令，until是判断条件为假时执行命令，语法格式都一样。\n\n * 举例\n   \n   \n\n\nbreak 和 continue#\n\n * break 是跳出离它最近的一个循环\n\n * continue 是结束这一次循环，继续下次循环\n\n * 举例\n   \n   \n\n\ncase条件选择#\n\n * 格式\n   \n   ","routePath":"/编程基础/Linux/Linux基础","lang":"","toc":[{"text":"linux基础命令","id":"linux基础命令","depth":2,"charIndex":3},{"text":"用户与身份","id":"用户与身份","depth":3,"charIndex":16},{"text":"1、用户","id":"1用户","depth":4,"charIndex":24},{"text":"2、切换用户","id":"2切换用户","depth":4,"charIndex":74},{"text":"目录的基本操作","id":"目录的基本操作","depth":3,"charIndex":153},{"text":"ls 列出当前目录的内容(list)","id":"ls-列出当前目录的内容list","depth":4,"charIndex":163},{"text":"cd 改变工作目录","id":"cd-改变工作目录","depth":4,"charIndex":186},{"text":"pwd 显示当前共工作目录的绝对路径","id":"pwd-显示当前共工作目录的绝对路径","depth":4,"charIndex":200},{"text":"mkdir创建一个空目录","id":"mkdir创建一个空目录","depth":4,"charIndex":221},{"text":"rmdir 只能删除空目录","id":"rmdir-只能删除空目录","depth":4,"charIndex":238},{"text":"通配符","id":"通配符","depth":4,"charIndex":254},{"text":"文件的基本操作","id":"文件的基本操作","depth":3,"charIndex":476},{"text":"touch 新建文本文件","id":"touch-新建文本文件","depth":4,"charIndex":486},{"text":"rm 删除文件","id":"rm-删除文件","depth":4,"charIndex":503},{"text":"cp 文件复制","id":"cp-文件复制","depth":4,"charIndex":515},{"text":"mv 文件移动","id":"mv-文件移动","depth":4,"charIndex":527},{"text":"查看文件","id":"查看文件","depth":4,"charIndex":539},{"text":"vim 文件编辑","id":"vim-文件编辑","depth":4,"charIndex":548},{"text":"文件压缩和解压缩","id":"文件压缩和解压缩","depth":4,"charIndex":1078},{"text":"路径","id":"路径","depth":3,"charIndex":1454},{"text":"文件访问权限","id":"文件访问权限","depth":3,"charIndex":1536},{"text":"用户管理和组管理","id":"用户管理和组管理","depth":3,"charIndex":1831},{"text":"find 文件查找","id":"find-文件查找","depth":3,"charIndex":1905},{"text":"帮助命令","id":"帮助命令","depth":3,"charIndex":1922},{"text":"进程管理","id":"进程管理","depth":3,"charIndex":1982},{"text":"磁盘管理","id":"磁盘管理","depth":3,"charIndex":2174},{"text":"软件安装","id":"软件安装","depth":3,"charIndex":2341},{"text":"shell程序设计","id":"shell程序设计","depth":2,"charIndex":2782},{"text":"输入输出","id":"输入输出","depth":3,"charIndex":2795},{"text":"shell后台执行命令","id":"shell后台执行命令","depth":3,"charIndex":3517},{"text":"shell变量和参数","id":"shell变量和参数","depth":3,"charIndex":3816},{"text":"shell程序设计流程控制","id":"shell程序设计流程控制","depth":2,"charIndex":4245},{"text":"test测试命令","id":"test测试命令","depth":3,"charIndex":4262},{"text":"`expr` 简单计算","id":"expr-简单计算","depth":3,"charIndex":-1},{"text":"if条件判断","id":"if条件判断","depth":3,"charIndex":4701},{"text":"for循环","id":"for循环","depth":3,"charIndex":4789},{"text":"while和until 循环","id":"while和until-循环","depth":3,"charIndex":4828},{"text":"break 和 continue","id":"break-和-continue","depth":3,"charIndex":4926},{"text":"case条件选择","id":"case条件选择","depth":3,"charIndex":5013}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":66,"title":"NVIDIA驱动&CUDA&cuDNN安装","content":"#\n\n系统环境：Deepin 20.9\n\n\n驱动安装#\n\n以显卡 GTX3060 举例，驱动下载地址：https://www.nvidia.cn/Download/Find.aspx?lang=cn\n\n把驱动下载好。\n\n1、进入 tty：\n\n\n\n2、禁用 nouveau 驱动：\n\n\n\n3、填入：\n\n\n\n4、刷新配置文件\n\n\n\n5、reboot 重启后再进入 tty。\n\n6、关闭图像界面，输入命令关闭图像界面：\n\n\n\n7、安装驱动\n\n\n\n8、reboot 重启，nvidia-smi 查看安装状态。\n\n\n\n注意看下 cuda 版本，后面要用。\n\n\nCUDA安装#\n\nCUDA 是 NVIDIA 的并行计算框架。\n\nCUDA 下载：https://developer.nvidia.com/cuda-toolkit-archive\n\n根据前面查看到 cuda 版本选择对应的包。\n\n\n\n按照网站下面的提示一顿操作就行了。\n\n\n\n输入 nvcc -V 查看，如果正常就说明安装好了：\n\n\n\n安装组件中千万别选 NVIDIA-fs，否则会 fail， 打叉表示选中。\n\n\ncuDNN#\n\ncuDNN 是 NVIDIA 打造的针对深度神经网络的加速库，是一个用于深层神经网络的 GPU 加速库。\n\n下载：https://developer.nvidia.com/rdp/cudnn-archive\n\n需要先注册为开发者。\n\n然后选择对应版本的 cuDNN 版本下载，注意和 CUDA 版本对应。\n\n然后执行安装：\n\n","routePath":"/编程基础/Linux/NVIDIA驱动&CUDA&cuDNN安装","lang":"","toc":[{"text":"驱动安装","id":"驱动安装","depth":2,"charIndex":21},{"text":"CUDA安装","id":"cuda安装","depth":2,"charIndex":274},{"text":"cuDNN","id":"cudnn","depth":2,"charIndex":483}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":67,"title":"Nginx入门使用","content":"#\n\n\n安装#\n\n\n\n安装之后 /var/www/html 就可以作为默认的 http 服务使用了；\n\n\n配置#\n\n配置文件路径：/etc/nginx/nginx.conf\n\n\n\n默认配置如下：\n\n\n\n一共由三部分组成，分别为 全局配置、events 配置和 http 配置；\n\n在 http 中，又包含 http 全局配置、多个 server 配置，每个 server 中，可以包含 server 全局配置和多个 location 配置；\n\n下面展开讲。\n\n\n全局配置#\n\n\n\nuser ：用于指定运行 nginx 服务的用户和用户组；将 user 注释掉或者配置成 nobady 表示所有用户都可以运行；\n\nworker_processes ：指定工作线程数，auto 表示自动模式；\n\npid：指定 pid 文件存放的路径\n\n\nevents#\n\n\n\nworker_connections：设置允许每一个 worker process 同时开启的最大连接数；\n\nmulti_accept: on 表示一个工作进程可以同时接受所有的新连接，off 表示一个工作进程只能同时接受一个新的连接，默认是 off；\n\n\nhttp#\n\n\n\n默认的 80 端口的服务是不用配置的；\n\n访问：IP:80，实际访问的路径为：/var/www/html\n\n访问：IP:8001，实际访问的路径为：/home/mikigo/Desktop/share\n\n\n反向代理#\n\n","routePath":"/编程基础/Linux/Nginx入门使用","lang":"","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":3},{"text":"配置","id":"配置","depth":2,"charIndex":52},{"text":"全局配置","id":"全局配置","depth":2,"charIndex":230},{"text":"events","id":"events","depth":2,"charIndex":366},{"text":"http","id":"http","depth":2,"charIndex":506},{"text":"反向代理","id":"反向代理","depth":2,"charIndex":618}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":68,"title":"U盘新建分区和文件系统","content":"#\n\n\n卸载#\n\n\n\n\n新建分区#\n\n\n\n\n新建文件系统#\n\n","routePath":"/编程基础/Linux/U盘新建分区和文件系统","lang":"","toc":[{"text":"卸载","id":"卸载","depth":2,"charIndex":3},{"text":"新建分区","id":"新建分区","depth":2,"charIndex":11},{"text":"新建文件系统","id":"新建文件系统","depth":2,"charIndex":21}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":69,"title":"dde-config使用","content":"#\n\n\n概述#\n\ndde-dconfig 是用于配置深度/统信系统组件参数的命令行工具，简称为组策略。\n\n在自动化工程中运用较多，可在某些测试场景，使用命令行进行较为便捷的初始化、环境清理。\n\n\n安装#\n\n组策略通过命令行使用较多，但是它任然有图形化配置工具，在调试和查看 key 时较为方便。\n\n需注意的是图形化支持的包未默认安装，所以需要手动安装之后才能正常使用：\n\n\n\n\n\n在页面可以对某些 key 的值进行直接修改和查看，key 一般对应某些功能，想快速定位，请教功能对应研发是不错的方法。\n\n\ndde-dconfig 常用命令#\n\n在自动化中一般是使用命令行进行操作，以下是 dde-dconfig 的一些基本用法示例，标记 [*] 的是最常用的。\n\n\n查看appid#\n\n\n\n这个命令会列出所有可用的 appid。\n\n\n显示指定appid下的resource项#\n\n\n\n使用 -a 参数指定appid。\n\n\n获取指定resource下的keys#\n\n\n\n这里 -a 指定appid名称，-r 指定resource名称。\n\n\n[*]获取指定的keys值#\n\n\n\n-k 用于指定keys名称。\n\n\n[*]修改指定keys的值#\n\n\n\n-v 用于指定新值。\n\n\n监视指定resource下的键值改动#\n\n\n\n这个命令可以用于监视指定resource下的键值改动。","routePath":"/编程基础/Linux/dde-dconfig使用","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"安装","id":"安装","depth":2,"charIndex":97},{"text":"`dde-dconfig` 常用命令","id":"dde-dconfig-常用命令","depth":2,"charIndex":-1},{"text":"查看appid","id":"查看appid","depth":3,"charIndex":331},{"text":"显示指定appid下的resource项","id":"显示指定appid下的resource项","depth":3,"charIndex":365},{"text":"获取指定resource下的keys","id":"获取指定resource下的keys","depth":3,"charIndex":409},{"text":"[*]获取指定的keys值","id":"获取指定的keys值","depth":3,"charIndex":467},{"text":"[*]修改指定keys的值","id":"修改指定keys的值","depth":3,"charIndex":502},{"text":"监视指定resource下的键值改动","id":"监视指定resource下的键值改动","depth":3,"charIndex":533}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"deb安装包制作","content":"#\n\n\n前言#\n\n自己编写的 Python 脚本代码，自己运行还好，让别人用的时候，不方便传输，也不方便运行，制作成 deb\n包后完美解决，网上搜索了很多文章，都没有一次打包成功过，故总结这样一份文档教程。\n\n我当前使用的系统： uos专业版\n\n\n打包需要的库#\n\n\n\n\n制作 debian 配置文件目录#\n\n源码目录下，创建 debian 的配置文件目录。在程序源代码目录下有一个叫做 debian\n的新的子目录。这个目录中存放着许多文件，我们将要修改这些文件来定制软件包行为。其中最重要的文件当属 control, changelog, copyright,\n以及 rules, 所有的软件包都必须有这几个文件。\n\n执行命令快速创建配置文件目录\n\n\n\n\ndeb包目录#\n\n\n\n\n修改 control 文件#\n\n原始文件内容如下，第 1 – 7 行是源代码包的控制信息。第 9 – 13 行是二进制包的控制信息。 按照自己的需求可以修改描述信息、支持架构等等信息\n\n\n\n提示\n\n详细的设置可以查看文末官方文档（4.1，control部分）\n\n\n创建 install 文件#\n\ninstall文件的目的是，安装deb包的时候，能把对应的脚本文件和share文件安装到指定的目录 例如，假设某个二进制文件\nsrc/bar没有被默认安装，则应让 install 呈现成这样：\n\n\n\n\n创建 links 文件#\n\nlinks 文件的目的，对需要直接执行的脚本文件创建链接\n\n\n\n\n进行打包#\n\ndebian 目录下还有很多文件可以按照自己的需求进行定制，不过这里用不上，暂时不做修改示列，比如最重要的 rules 文件，直接决定打包的成功与否\n\n打包可以直接执行以下命令进行打包：\n\n\n\n完成后，会在上级目录生成 mydeb_1.0.0_amd64.deb，自此，打包结束。\n\n\ndebian 目录下文件说明#\n\nchangelog：此文件用于记录软件包的版本和更新历史。每次对软件包进行更改时，都应更新此文件以包含新的版本号、日期、作者和更改描述。\n\ncompat：此文件指定了软件包的兼容性级别。它定义了软件包与 Debian 操作系统版本之间的兼容性要求。该文件中的数字表示 Debian 版本号，例如 9\n表示Debian 9 或更高版本。\n\ncontrol：此文件是软件包的控制文件，包含了软件包的元数据和依赖关系。它定义了软件包的名称、描述、维护者、依赖关系和其他相关信息。\n\ncopyright：此文件包含软件包的版权信息和许可证条款。它指定了软件包的版权所有者、许可证类型和许可证文本。\n\ndocs：此目录用于存放软件包的文档文件。这些文件可以是用户手册、安装指南、示例配置文件等。\n\ninstall：此文件用于指定软件包的安装规则。它告诉 dpkg 工具在安装软件包时应该将哪些文件复制到系统的哪些位置。\n\nrules：此文件包含了构建软件包的规则和指令。它指定了如何编译、打包和安装软件包。\n\nlinks文件用于创建符号链接（symbolic\nlinks）。符号链接是一种特殊类型的文件，它指向另一个文件或目录。通过创建符号链接，可以在文件系统中引用其他位置的文件或目录，而不需要复制或移动它们。\n\nsource：此目录包含软件包的源代码。如果软件包是通过源代码构建的，那么源代码文件应该放在这个目录下。\n\npreinst:（pre-installation script）文件是 Debian 软件包中的一个脚本文件，用于在软件包安装之前执行一些预安装操作。\n\n--------------------------------------------------------------------------------\n\n官方制作deb的方法\n\n--------------------------------------------------------------------------------","routePath":"/编程基础/Linux/deb安装包制作","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":3},{"text":"打包需要的库","id":"打包需要的库","depth":2,"charIndex":123},{"text":"制作 debian 配置文件目录","id":"制作-debian-配置文件目录","depth":2,"charIndex":135},{"text":"deb包目录","id":"deb包目录","depth":2,"charIndex":328},{"text":"修改 control 文件","id":"修改-control-文件","depth":2,"charIndex":340},{"text":"创建 install 文件","id":"创建-install-文件","depth":2,"charIndex":472},{"text":"创建 links 文件","id":"创建-links-文件","depth":2,"charIndex":589},{"text":"进行打包","id":"进行打包","depth":2,"charIndex":636},{"text":"debian 目录下文件说明","id":"debian-目录下文件说明","depth":2,"charIndex":786}],"domain":"","frontmatter":{"Author":"禄烨"},"version":""},{"id":71,"title":"vim配置和插件使用","content":"#\n\n类 Unix 系统中有两大编辑器，Emacs 是神的编辑器，而 Vim 是编辑器之神， 而 Vim 是从 vi\n发展出来的一个文本编辑器。有代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n\nvim键盘图：\n\n\n\nVim 之所以被称为编辑器之神，就是因为系统资源占用小, 打开大文件毫无压力,可配置性强，自定义性高，可根据编码语言和个人喜好进行配置和选择。\n\n\n1. VIM使用#\n\nvim有三种模式，命令模式，可视模式，输入模式\n\n1.1 搜索和替换#\n\n?word：反向搜索，效果上跟/word, 按 N 一样\n\n:n1,n2s/word1/word2/g： n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2\n\n:1,$s/word1/word2/g或者:%s/word1/word2/g：从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2\n\n1.2 删除与复制#\n\nx,X：在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\nnx：n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符\n\ndd： 删除游标所在的那一整行(常用)\n\nndd：n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行\n\nd1G：删除光标所在到第一行的所有数据，相对dG就是删除光标所在行到最后一行的数据。\n\nd$：删除游标所在处，到该行的最后一个字符\n\nd0：是数字0不是o，删除行首到光标处的字符\n\ntips：把d换成y就是复制相关操作。\n\np,P：p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行\n\nJ：合并光标所在行和下一行。\n\n[Ctrl]+r：重做上一个动作\n\n. ：英文中的点号，就是重复上一个动作，比如先执行了dd命令，如果还想删除当前行，就按.就行了。\n\n1.3 编辑模式#\n\nI ：大写的字符I，所在行的第一个非空格符处开始输入\n\na, A：a 为从目前光标所在的下一个字符处开始输入 ，A 为从光标所在行的最后一个字符处开始输入\n\nr, R：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字\n\n1.4 一般模式切换到指令行模式#\n\nZZ：大写的Z，相当于:wq\n\nZQ：不保存强制退出\n\n:w filename：保存到另外一个新文件\n\n:n1,n2 w filename：将 n1 到 n2 的内容储存成 filename 这个档案\n\n1.5 环境变量设置#\n\n:set number：设置显示行号\n\n:set nonumber：设置隐藏行号\n\n:set paste：粘贴模式，从外部复制代码到vim编辑器中，直接粘贴原来的代码格式就不会保留，这么模式下会保留原来的格式\n\n1.6 可视模式#\n\n批量添加注释：ctrl+v进入块选择模式，按下选中要添加注释的行，再按大写的字母I，输入注释，再按两次ESC保存\n\n批量删除注释：ctrl+v进入块选择模式，如果注释为 //,那么就按右键，选中 //，再按下，选择要删除的行，再按小写字符d，再按ESC保存\n\n\n2. 配置说明#\n\nvim 样式配置\n\n\n\n2.1 快捷键设置#\n\nvim设置快捷键共4中方法\n\n * map系列命令\n\nmap {lhs} {rhs}。这个命令就是将{lhs}代表的按键映射成{rhs}所代表的按键。例如map L\n$就是将$键映射成L。此外需要注意的是map命令定义的快捷键是可以嵌套的\n\n * noremap系列命令\n\nno[remap] {lhs} {rhs}，顾名思义，就是不可以重新映射的命令。这个命令和 map 命令类似，不过它所定义的命令不可以被重新映射\n\n * unmap系列命令\n\n就是用来取消所在模式下快捷键的定义\n\n * mapclear系命令\n\n清除所在模式下定义的所有快捷键\n\n2.2 自定义快捷键相关的六种模式#\n\n在Vim中，共有六种模式，不同的定义快捷键的命令生效的模式不同，这六种模式如下：\n\n * N ormal Mode: 即Vim的普通模式，我们打开Vim后进入的第一个模式即此模式。\n * V isual Mode: 即Vim的Visual模式，我们在选中了一定的文本之后(通过v或者V命令)即进入此模式。\n * S elect Mode: 这种模式和Visual模式相似，不过输入的文本都会替换选中的文本。在普通模式下，通过鼠标选中或者使用gH命令都可以进入此模式。\n * O perator-pending Mode: 当我们输入一个操作符后(例如，d，y，c等等)，就会进入此模式。\n * I nsert Mode: 即Vim的插入模式，普通模式下我们输入i(或者s,a等等)就会进入此模式。\n * C ommand-line Mode: 命令行模式，我们在普通模式下输入:或者/等就会进入此模式\n\n\n\n插件寻找位置：https://vimawesome.com/\n\n\n3. vim插件#\n\n插件管理器：顾名思义就是管理插件的工具，在 vim8 之前都是采用三方工具管理插件，vim8有了自己插件管理器package，\n\n常见的第三方vim插件管理有Vundle， vim-plug， dein， pathogen，Volt\n\n本文只介绍Vundle，最早的 vim 插件管理器，最新的 vim-plug 相比 Vundle 多了异步功能\n\n项目地址：https://github.com/VundleVim/Vundle.vim\n\n安装 Vundle ：\n\n\n\n修改 .vimrc 配置文件，在 call vundle#begin() 和 call vundle#end()\n之间添加指定的插件保存并执行PluginInstall命令进行安装\n\n\n\n执行安装命令后的效果，有些插件需要需要梯子才能正常安装\n\nVundle可以进行插件安装卸载，及列出插件列表，对应命令：PluginClean PluginDocs PluginInstall PluginList\nPluginSearch PluginUpdate\n\n\n3.1 插件安装方式#\n\n * 从github上安装：\n\nPlugin 'user/plugin'\n\n * 从特定的网址安装\n\nPlugin 'plugin_name'\n\n * 从一个git库里面安装\n\nPlugin 'git://url.git'\n\n * 本地安装\n\nPlugin 'file:///path'\n\n从github安装，如果没有梯子，可能会安装失败，国内有个代码托管平台码云（gitee）可以直接同步到gitee中，然后再指定选择ssh的地址进行安装，再通过g\nit仓库的方式进行安装。\n\n还可以将插件克隆到 .vim/bundle 下，使用本地安装的方式进行安装\n\n\n3.2 安装ack插件使用#\n\n * 安装ack, sudo apt install ack\n * clone 代码到.vim/bundle,\n * 使用命令: Ack word搜索字符串\n * 设置快捷键nnoremap <F8> :Ack\n\n\n3.3 插件介绍#\n\n3.3.1 NERDTree#\n\n该插件显示一个目录树，可以执行文件的操作命令。在大型项目中，你很难找到你要编辑的那一行的文件确切名称和位置。通过快捷键，一个资源管理器窗口就会以目录树的方式打开\n，你可以轻松找到你想要的文件并打开它，假如你有大量代码或者容易忘记文件名的人，NERDTree 是必须要有的\n\n3.3.2 ack#\n\n当我需要搜索包含某一行或者某个单词的文件时，我就很喜欢 ack 插件，你最好把它和 ag 结合使用，这是一个名为“The Silver\nSearcher”的全局搜索工具。这个组合非常快，涵盖了我可以使用 grep 或 vimgrep 做的绝大多数事情。缺点是你需要安装 ack 或 ag\n才能正常运行，优点是 ag 和 ack 都可以用于 Fedora 和 EPEL7\n\n3.3.3 YouCompleteMe#\n\n自动补全插件,依赖环境变量","routePath":"/编程基础/Linux/vim配置和插件选择","lang":"","toc":[{"text":"1. VIM使用","id":"1-vim使用","depth":2,"charIndex":195},{"text":"1.1 搜索和替换","id":"11-搜索和替换","depth":4,"charIndex":231},{"text":"1.2 删除与复制","id":"12-删除与复制","depth":4,"charIndex":432},{"text":"1.3 编辑模式","id":"13-编辑模式","depth":4,"charIndex":863},{"text":"1.4 一般模式切换到指令行模式","id":"14-一般模式切换到指令行模式","depth":4,"charIndex":992},{"text":"1.5 环境变量设置","id":"15-环境变量设置","depth":4,"charIndex":1113},{"text":"1.6 可视模式","id":"16-可视模式","depth":4,"charIndex":1232},{"text":"2. 配置说明","id":"2-配置说明","depth":2,"charIndex":1374},{"text":"2.1 快捷键设置","id":"21-快捷键设置","depth":4,"charIndex":1396},{"text":"2.2 自定义快捷键相关的六种模式","id":"22-自定义快捷键相关的六种模式","depth":4,"charIndex":1685},{"text":"3. vim插件","id":"3-vim插件","depth":2,"charIndex":2142},{"text":"3.1 插件安装方式","id":"31-插件安装方式","depth":3,"charIndex":2618},{"text":"3.2 安装ack插件使用","id":"32-安装ack插件使用","depth":3,"charIndex":2911},{"text":"3.3 插件介绍","id":"33-插件介绍","depth":3,"charIndex":3035},{"text":"3.3.1 NERDTree","id":"331-nerdtree","depth":4,"charIndex":3046},{"text":"3.3.2 ack","id":"332-ack","depth":4,"charIndex":3200},{"text":"3.3.3 YouCompleteMe","id":"333-youcompleteme","depth":4,"charIndex":3398}],"domain":"","frontmatter":{"Author":"徐小东"},"version":""},{"id":72,"title":"配置开机自启服务","content":"#\n\n写开机自启服务文件：\n\n\n\n写入以下内容：\n\n\n\n注意，在 ExecStart=$do you shell scripts$ 里面配置你的要执行的命令，比如：ExecStart=bash test.sh\n\n修改配置文件的权限：\n\n\n\n自启服务生效：\n\n\n\n查看服务状态：\n\n\n\n--------------------------------------------------------------------------------","routePath":"/编程基础/Linux/配置开机自启服务","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":73,"title":"Linux 上如何选择用 pip3 还是 sudo pip3","content":"#\n\n\n（1）sudo pip3#\n\n如果这个包是带有命令行工具的，推荐使用sudo pip3 install xxx 进行安装;\n\n这样命令行工具才能写入到系统目录下，一般是在 /usr/local/bin/ 下面；\n\n--------------------------------------------------------------------------------\n\n> 如果你没有加 sudo 安装，命令行工具无法写入到系统目录下，而是写入到\n> $HOME/.local/bin，这个路径很明显不是系统的环境变量，因此无法直接使用此命令，要想使用它你有两种方法：\n> \n> 第一种：\n> \n> \n> \n> 第二种：\n> \n> 将 $HOME/.local/bin 添加到 PATH 里面:\n> \n> 临时修改：\n> \n> \n> \n> 用户级别永久修改：\n> \n> \n> \n> 系统级别永久修改：\n\n你看如果带命令行工具的库，安装的时候没有加 sudo 你要多做多少事情；\n\n所以请记住，带有命令行工具的三方库，安装的时候使用 sudo pip3 install。\n\n\n（2）pip3#\n\n如果这个库没有命令行工具，或者说它安装过程中不需要写入系统目录，你使用 pip3 或 sudo pip3 安装都可以；\n\n但是，我个人推荐不要加 sudo；\n\n原因就需要介绍一点点背景知识：\n\n> 在 Linux 上，Python 三方包通常被安装在以下三个路径中：\n> \n>  1. /usr/lib/pythonX.X/site-packages\n> \n> 这个路径中安装的是系统默认的 Python 解释器的三方包，X.X 代表 Python 版本号，如 2.7、3.6;\n> \n>  2. /usr/local/lib/pythonX.X/site-packages\n> \n> 这个路径中安装的是用户自己安装的 Python 解释器的三方包，X.X 代表 Python 版本号，如 2.7、3.6;\n> \n>  3. $HOME/.local/lib/pythonX.X/site-packages\n> \n> 这个路径中安装的是当前用户的 Python 解释器的三方包，X.X代表 Python 版本号，如 2.7、3.6;\n> \n> 在加载Python三方包时，系统会按照以下顺序查找三方包的路径：\n> \n>  1. 先查找当前工作目录是否有需要的包;想\n>  2. 查找 $HOME/.local/lib/pythonX.X/site-packages;\n>  3. 查找 /usr/local/lib/pythonX.X/site-packages\n>  4. 查找 /usr/lib/pythonX.X/site-packages\n> \n> 如果在以上路径中找到了需要的包，就会加载它们；\n> \n> 如果没有找到，则会抛出ImportError异常；\n> \n> 需要注意的是，如果相同的包存在于多个路径中，系统会加载最先找到的那个包，而不是后面找到的那个包；\n> \n> 因此，如果有多个Python解释器或版本，并且使用了不同的路径安装三方包，就需要确认加载的包是否正确。\n\n使用 pip3 安装的时候是安装到 $HOME/.local/lib/pythonX.X/site-packages 路径下；\n\n而使用 sudo pip3 安装的时候是安装到 /usr/local/lib/pythonX.X/site-packages 路径下\n\n基于前面的背景知识，这个路径是排在前面的，是会被优先加载到；\n\n因此，结论：我始终推荐优先考虑使用 pip3 安装（不加sudo ）；\n\n有同学要问了，凭啥优先加载到，我就要用它呢？你的领导做啥都先想到你，你觉得是不是好事，你细品～～\n\n--------------------------------------------------------------------------------","routePath":"/编程基础/Python/Linux上如何选择用pip3还是sudopip3","lang":"","toc":[{"text":"（1）sudo pip3","id":"1sudo-pip3","depth":2,"charIndex":3},{"text":"（2）pip3","id":"2pip3","depth":2,"charIndex":494}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":74,"title":"Linux 上安装 Python 3.9.9","content":"#\n\n在 deepin 上默认是 Python 版本是 3.7.3 ，在做一些 Django 项目的时候需要用到 3.9 版本；\n\n此脚本直接下载并安装 Python 3.9.9，复制以下脚本执行在本地执行即可；\n\n\n\n--------------------------------------------------------------------------------","routePath":"/编程基础/Python/Linux上安装Python3.9.9","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":75,"title":"MMDetection 入门基础","content":"#\n\nMMDetection 是商汤科技开源的一个深度学习框架，国内目标检测领域的翘楚；\n\n相比于 Facebook 开源的 Detectron 框架，作者声称 MMDetection 有三点优势：performance\n稍高、训练速度稍快、所需显存稍小。\n\n低调哈，基操，皆坐，勿6，又被他装到了～\n\nGithub地址：https://github.com/open-mmlab/mmdetection\n\n\n一、虚拟环境安装#\n\n\n\n一路回车\n\n第一次提示输入 yes/no ：输入 yes\n\n继续一路回车\n\n第二次提示：输入 no\n\n\n\n激活conda环境\n\n\n\n添加公司内网源\n\n\n\n如果是外网添加外网源\n\n\n\n如果要删除源\n\n\n\n\n二、安装依赖#\n\n\n1、创建虚拟环境#\n\n\n\n\n\n\n\n\n2、安装 Pytorch#\n\n在mmlab虚拟环境中执行\n\n\n\n\n3、安装 MMCV#\n\n在mmlab虚拟环境中执行\n\n\n\n\n三、数据标注#\n\n标注之前需要先转换图片大小，并且以数字命名，每组命名递增\n\n\n1、转换大小并重命名#\n\nrename_pic.py\n\n\n\n根据终端输出的下一个序号的提示，执行 Python 文件的时候传参。\n\n\n\n\n2、工具标注#\n\n使用工具 labelImg 标注\n\n\n\n终端直接输入 labelImg，回车\n\n标注模式选择：PascalVOC\n\n\n四、拉取 MMDetection 代码#\n\n\n\n\n五、拉取 voc2coco 代码#\n\n\n\n\n六、转换 coco 数据集#\n\n将所有的图片和xml文件放入train2017，从中挑选几组放入val2017（测试集）\n\n\n\n生成json文件\n\n\n七、修改配置#\n\n\n1、读取模型名称#\n\n\n\n\n\n\n2、修改 faster_rcnn_r101_2x_coco.py#\n\nmmdetection/xianjin/faster_rcnn_r101_2x_coco.py\n\n修改46行，num_clasess的指，新增1个，就+1\n\n\n3、修改 coco.py#\n\nmmdetection/mmdet/datasets/coco.py\n\nCLASSES = ()，在里面添加模型名称\n\n\n4、修改 class_names.py#\n\nmmdetection/mmdet/core/evaluation/class_names.py\n\ncoco_classes 里面添加模型名称\n\n\n八、缓存清理#\n\n删除 mmdetection/build 目录\n\n\n\n\n九、训练模型#\n\n\n指定自己配置的训练模型#\n\n\n\n\n查看训练结果的测试集结果#\n\n\n\n\n查看训练结果的准确度#\n\n\n\n\n十、快捷操作#\n\n\n\nrun.py 整合了以上所有的操作。","routePath":"/编程基础/Python/MMDetection入门基础","lang":"","toc":[{"text":"一、虚拟环境安装","id":"一虚拟环境安装","depth":2,"charIndex":204},{"text":"二、安装依赖","id":"二安装依赖","depth":2,"charIndex":319},{"text":"1、创建虚拟环境","id":"1创建虚拟环境","depth":3,"charIndex":329},{"text":"2、安装 Pytorch","id":"2安装-pytorch","depth":3,"charIndex":347},{"text":"3、安装 MMCV","id":"3安装-mmcv","depth":3,"charIndex":380},{"text":"三、数据标注","id":"三数据标注","depth":2,"charIndex":410},{"text":"1、转换大小并重命名","id":"1转换大小并重命名","depth":3,"charIndex":450},{"text":"2、工具标注","id":"2工具标注","depth":3,"charIndex":519},{"text":"四、拉取 MMDetection 代码","id":"四拉取-mmdetection-代码","depth":2,"charIndex":587},{"text":"五、拉取 voc2coco 代码","id":"五拉取-voc2coco-代码","depth":2,"charIndex":612},{"text":"六、转换 coco 数据集","id":"六转换-coco-数据集","depth":2,"charIndex":634},{"text":"七、修改配置","id":"七修改配置","depth":2,"charIndex":709},{"text":"1、读取模型名称","id":"1读取模型名称","depth":3,"charIndex":719},{"text":"2、修改 faster_rcnn_r101_2x_coco.py","id":"2修改-faster_rcnn_r101_2x_cocopy","depth":3,"charIndex":735},{"text":"3、修改 coco.py","id":"3修改-cocopy","depth":3,"charIndex":850},{"text":"4、修改 class_names.py","id":"4修改-class_namespy","depth":3,"charIndex":926},{"text":"八、缓存清理","id":"八缓存清理","depth":2,"charIndex":1022},{"text":"九、训练模型","id":"九训练模型","depth":2,"charIndex":1059},{"text":"指定自己配置的训练模型","id":"指定自己配置的训练模型","depth":3,"charIndex":1069},{"text":"查看训练结果的测试集结果","id":"查看训练结果的测试集结果","depth":3,"charIndex":1086},{"text":"查看训练结果的准确度","id":"查看训练结果的准确度","depth":3,"charIndex":1104},{"text":"十、快捷操作","id":"十快捷操作","depth":2,"charIndex":1120}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":76,"title":"OpenCV(Python)基础—9小时入门版","content":"#\n\n\n一、一句话简介#\n\nOpenCV (Open Source Computer Vision Library) 是用 C++ 语言编写，提供 Python、Java 等语言\nAPI的一个开源计算机视觉库。\n\n\n二、安装#\n\n1、Debian 系使用 apt 安装 OpencCV：\n\n\n\n在 UOS 系统上，也可以使用：\n\n\n\n支持 AMD、ARM、MIPS 架构安装。\n\n2、安装 NumPy：\n\nNumPy 是 Python中的一个运算速度非常快的数学库，数组玩到起飞，如果你玩数据科学、机器学习，这是必学库。所有 OpenCV 数组结构都转换为\nNumPy 数组，要想 OpenCV 学得好，必须熟悉它，学习 OpenCV 基础多少需要了解一点。\n\n\n\n好多同学安装 Python 库都习惯使用 pip 安装，实际上 OpenCV 也可以，但是目前只支持在 AMD，所以考虑到兼容性还是建议使用 apt\n进行安装，并且官方文档也是建议使用 apt 安装。\n\n\n三、入门基础#\n\n所有 OpenCV 类和函数都放在 cv 名称空间中，在 py 文件中导入：\n\n\n\n后续内容默认都使用了导入。\n\n\n1、图像#\n\n1.1、读图像#\n\n\n\n * 参数1：文件路径。(str)\n * 参数2：读取图像的方式。\n   * cv.IMREAD_COLOR 加载一个彩色图像，忽略 alpha 通道。（默认值）\n   * cv.IMREAD_GRAYSCALE 加载图像为灰度模式。\n   * cv.IMREAD_UNCHANGED 加载图像，包括 alpha 通道。\n   * 还可以简单地分别传递整数1、0或 -1。\n\n1.2、显示图像#\n\n\n\n * 参数1：窗口名称。（str）\n * 参数2：图像。（obj）\n\n在窗口中显示图像，窗口自动适合图像大小。\n\n销毁窗口\n\n\n\n1.3、写图像#\n\n\n\n * 参数1：文件名。\n * 参数2：图像。（obj）\n\n\n2、视频#\n\n2.1、从摄像头捕获视频#\n\n\n\n它的参数可以是设备索引或视频文件的名称。设备索引就是指定哪个摄像头的数字。一般我们连接一个摄像头，所以传0(或-1)。当然可以通过传递1来选择第二个相机，以此类\n推。\n\n\n\n一切都看起来很和谐哈。\n\n需要注意其他的两个判断：\n\n * 有时候摄像头可能没有初始化成功，所以用cap.isOpened() 来判断，并退出。\n * 可能没有接收到帧，停止循环。\n\n获取视频的一些属性：\n\n\n\nid\n是一个从0到18的数字，每个数字表示视频的一个属性。每个属性代表什么→（https://docs.opencv.org/4.1.2/d4/d15/group__\nvideoio__flags__base.html#gaeb8dd9c89c10a5c63c139bf7c4f5704d）\n\ncap.set() 属于进阶用法，这里按下不表。\n\n2.2、从文件中播放视频#\n\n原理和从摄像头中捕获是一样的，区别在于：\n\n\n\n参数是文件名称。\n\n2.3、保存视频#\n\n\n\n * 参数1：文件名\n * 参数2：fourcc = cv.VideoWriter_fourcc(*'XVID')\n   * FourCC 是一个4字节的代码，用于指定视频编解码器。\n   * DIVX, XVID, MJPG, X264, WMV1, WMV2\n   * 不同的操作系统有差异 https://www.fourcc.org/codecs.php\n * 参数3：帧率\n * 参数3：分辨率\n\n\n\n结合前面摄像头捕获视频的代码，看起来很简单～\n\n\n3、绘图#\n\n3.1、画线#\n\n\n\n举例：创建一个黑色图像，并从左上角到右下角在上面画一条蓝线\n\n\n\n(255,0,0) 代表蓝色，最后一个参数是线的宽度。\n\n3.2、画圆#\n\n\n\n参数：中心坐标和半径\n\n3.3、画矩形#\n\n\n\n参数：矩形的左上角和右下角\n\n支持其他图形。。。\n\n\n四、核心功能#\n\n\n1、图像的基本操作#\n\n1.1、访问和修改像素值#\n\n\n\n修改\n\n\n\n直接赋值即可修改，但是直接访问非常缓慢，更好的像素访问和编辑方法:\n\n\n\n1.2、访问图像属性#\n\n图像属性包括行数、列数和通道数、图像数据类型、像素数等。\n\n\n\n返回一个行、列和通道数的元组。\n\n\n\n1.3、特定区域#\n\n机器学习中经常需要抠图，比如人脸识别时，一般会先选择人脸区域，搜索其中的眼睛，而不是搜索整个图像，以提供精确度。\n\n\n\n1.4、图像信道的分裂与合并#\n\n\n\n或者\n\n\n\n比如将所有红色像素设置为零\n\n\n\n\n2、图像的算术运算#\n\n2.1、图片添加#\n\n\n\n可以添加两个图像\n\n\n\nOpenCV 的加法和 Numpy 的加法是有区别的。OpenCV 加法是一个饱和操作，而 Numpy 加法是一个除余操作。\n\n\n\n2.2、图像混合#\n\n\n\n也是图像添加，但不同的权重给予图像，使它给人一种混合或透明的感觉。\n\n * 参数1、2：图像1及其权重。\n * 参数3、4：图像2及其权重。\n * 参数5：图像混合的α 值，通过改变 α 从0→1，你可以在一张图片到另一张图片之间进行一个很魔幻的转换。\n\n\n\n2.3、按位操作#\n\n按位 AND、 OR、 NOT 和 XOR 操作。\n\n可以理解为图像的逻辑运算：\n\n\n\n\n五、图像处理#\n\n\n1、改变色彩空间#\n\nOpenCV 目前有150多种颜色空间转换方法。但其中两个最广泛使用的：\n\n1.1、Gray#\n\ncv.COLOR_BGR2GRAY\n\n顾名思义：BGR → Gray\n\n这个图像识别中经常使用，可以提供识别速度和准确度。\n\n1.2、HSV#\n\ncv.COLOR_BGR2HSV\n\n顾名思义：BGR → HSV\n\nHSV 图像可以用它来提取有色物体在 HSV 中，比在 BGR 颜色空间中更容易表示颜色。\n\n\n\n\n2、几何变换#\n\n2.1、缩放#\n\n\n\n参数                解释\nnputArray src     输入图片\nOutputArray dst   输出图片\nSize              输出图片尺寸\nfx, fy            沿x轴，y轴的缩放系数\ninterpolation     插入方式\n\ninterpolation 默认情况下，使用的插值方法是 cv.INTER_LINEAR，用于所有调整大小。\n\n举例：\n\n\n\n2.2、旋转#\n\n\n\n旋转90度：\n\n\n\n\n3、图像阈值化#\n\n3.1、自适应阈值分割#\n\n如果像素值小于阈值，则将其设置为0，否则将其设置为最大值。\n\n\n\n * cv.THRESH_BINARY\n * cv.THRESH_BINARY_INV\n * cv.THRESH_TRUNC\n * cv.THRESH_TOZERO\n * cv.THRESH_TOZERO_INV\n\n如果一个图像在不同的区域有不同的照明条件，全局使用一个阈值一般是不可用的，对同一幅图像的不同区域采用不同的阈值，对不同光照条件下的图像取得了较好的效果。\n\n * cv.ADAPTIVE_THRESH_MEAN_C 阈值是邻近区域的平均值减去常数 c\n * cv.ADAPTIVE_THRESH_GAUSSIAN_C 阈值是邻域值减去常数 c 的高斯加权和\n\n\n\n\n4、模板匹配#\n\n4.1、单目标匹配#\n\n模板匹配是一种在较大图像中搜索和查找模板图像位置的方法。\n\n\n\n * 参数1：大图\n * 参数2：小图\n * 参数3：匹配方法\n   * cv.TM_CCOEFF\n   * cv.TM_CCOEFF_NORMED\n   * cv.TM_CCORR\n   * cv.TM_CCORR_NORMED\n   * cv.TM_SQDIFF\n   * cv.TM_SQDIFF_NORMED\n\n查找最大/最小值\n\n\n\n\n\n4.2、多目标匹配#\n\ncv.minMaxLoc()不会给出所有位置。\n\n通过阈值处理多个模板匹配。\n\n","routePath":"/编程基础/Python/OpenCV(Python)基础—9小时入门版","lang":"","toc":[{"text":"一、一句话简介","id":"一一句话简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":107},{"text":"三、入门基础","id":"三入门基础","depth":2,"charIndex":435},{"text":"1、图像","id":"1图像","depth":3,"charIndex":502},{"text":"1.1、读图像","id":"11读图像","depth":4,"charIndex":509},{"text":"1.2、显示图像","id":"12显示图像","depth":4,"charIndex":709},{"text":"1.3、写图像","id":"13写图像","depth":4,"charIndex":787},{"text":"2、视频","id":"2视频","depth":3,"charIndex":829},{"text":"2.1、从摄像头捕获视频","id":"21从摄像头捕获视频","depth":4,"charIndex":836},{"text":"2.2、从文件中播放视频","id":"22从文件中播放视频","depth":4,"charIndex":1219},{"text":"2.3、保存视频","id":"23保存视频","depth":4,"charIndex":1268},{"text":"3、绘图","id":"3绘图","depth":3,"charIndex":1512},{"text":"3.1、画线","id":"31画线","depth":4,"charIndex":1519},{"text":"3.2、画圆","id":"32画圆","depth":4,"charIndex":1592},{"text":"3.3、画矩形","id":"33画矩形","depth":4,"charIndex":1615},{"text":"四、核心功能","id":"四核心功能","depth":2,"charIndex":1654},{"text":"1、图像的基本操作","id":"1图像的基本操作","depth":3,"charIndex":1664},{"text":"1.1、访问和修改像素值","id":"11访问和修改像素值","depth":4,"charIndex":1676},{"text":"1.2、访问图像属性","id":"12访问图像属性","depth":4,"charIndex":1736},{"text":"1.3、特定区域","id":"13特定区域","depth":4,"charIndex":1800},{"text":"1.4、图像信道的分裂与合并","id":"14图像信道的分裂与合并","depth":4,"charIndex":1871},{"text":"2、图像的算术运算","id":"2图像的算术运算","depth":3,"charIndex":1914},{"text":"2.1、图片添加","id":"21图片添加","depth":4,"charIndex":1926},{"text":"2.2、图像混合","id":"22图像混合","depth":4,"charIndex":2017},{"text":"2.3、按位操作","id":"23按位操作","depth":4,"charIndex":2160},{"text":"五、图像处理","id":"五图像处理","depth":2,"charIndex":2216},{"text":"1、改变色彩空间","id":"1改变色彩空间","depth":3,"charIndex":2226},{"text":"1.1、Gray","id":"11gray","depth":4,"charIndex":2275},{"text":"1.2、HSV","id":"12hsv","depth":4,"charIndex":2349},{"text":"2、几何变换","id":"2几何变换","depth":3,"charIndex":2443},{"text":"2.1、缩放","id":"21缩放","depth":4,"charIndex":2452},{"text":"2.2、旋转","id":"22旋转","depth":4,"charIndex":2672},{"text":"3、图像阈值化","id":"3图像阈值化","depth":3,"charIndex":2694},{"text":"3.1、自适应阈值分割","id":"31自适应阈值分割","depth":4,"charIndex":2704},{"text":"4、模板匹配","id":"4模板匹配","depth":3,"charIndex":3041},{"text":"4.1、单目标匹配","id":"41单目标匹配","depth":4,"charIndex":3050},{"text":"4.2、多目标匹配","id":"42多目标匹配","depth":4,"charIndex":3268}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":77,"title":"Python从进阶到高级—通俗易懂版","content":"#\n\n\n一、简介#\n\nPython\n进阶是我一直很想写的，作为自己学习的记录，过去自己在看一些代码的时候经常会困惑，看不懂，然后自己去查资料、看书籍，慢慢的一个个弄懂，经常沉浸其中。关于\nPython 高级语法的资料、书籍不少，详细是详细，但是总感觉写的太复杂，学习有难度，而且不能使人印象深刻。\n\n“TLDR” 是流行的互联网行话，意思是“太长不读（ to long didn't read\n）”。其实很多内容的核心知识就那么一点，细枝末节的东西蛮多，描述词句也很官方很晦涩，很难读懂，给人感觉就是每个字我都认识，怎么放到一起就不认识了。通俗易懂版就是\n想用一种比较轻松、简单的方式说明其中的重点且常用的内容，在写作的过程中我也时常告诫自己要克制，别整复杂了。\n\nPython 是一门很容易入门的语言，但是要进阶其实需要花费大量的时间和精力，而且还需要不断的练习使用，或许你已经花了两个月时间学习了 Python\n基础并能够写一些小脚本，或许你已经达到一定高度能独立编写大型项目，但是学习永无止境，我们都还有很多需要学习提升的地方。以下内容绝大部分都是我在项目中用过的，很多\n描述是我自己的理解，可能会和官方有一定出入，但是相信大差不差，也欢迎有心人不吝赐教。\n\n内容还会继续增加，包括一些简单好用的标准库、三方库都会持续加进来，希望看到的同学可以多多提意见。\n\n\n二、类和对象#\n\n\n1、鸭子类型#\n\n“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 这是百科上对它的解释。\n\n鸭子类型（duck typing）是动态类型的一种风格，鸭子类型对于 Python\n编码来讲非常重要，理解它能让你真正理解什么是一切皆对象，更有助于我们理解这门语言的设计思想和实现原理，而不是仅仅浮于表面的念经 “一切皆对象”。\n\n鸭子类型始终贯穿于 Python 代码当中，一个对象它是什么类型取决于它实现了什么协议，因此可以说 Python 是一种基于协议的编程语言。\n\n那这些协议是什么，又有哪些协议？这里的协议，更多的时候我们称为魔法函数或魔法方法，因为它具有很多神奇的魔力，坊间因此称之为魔法函数。\n\n在 Python 里面，所有以双下划线开头，且以双下划线结尾的函数都是魔法函数，就像 __init__ 这种，它们是 Python\n语言天然自带的，不是通过某个类去继承而来的，我们也不要随意去自定义一个这样的函数，小心着魔。\n\n魔法函数有很多，但是经常用到的也没多少，常用的一些魔法函数在后面的内容会逐步介绍到。\n\n\n2、类型判断#\n\n在判断数据类型的时候常见的有两种方法：isinstance 和 type\n\n\n\nisinstance 主要用于判断对象的类型。这个好理解，不多讲。\n\ntype 可以查看类型，但它能做的远不止于此，它主要用于动态的创建类。\n\n\n\n\n\n你看，我们定义了一个类并赋值给 t，类名为 Mikigo，t 是类对象的引用，name 是其中的属性，Python\n中一切都是对象，类也是对象，只不过是一种特殊的对象，是 type 的对象。\n\n这个地方有点绕哈，你细品。\n\n我看到网上好多讲 type 函数，准确讲 type 是一个类，只是用法像函数。在源码中：（通过 Pycharm 按住 Ctrl 点击进入）\n\n\n\n有同学要问了，为什么源码里面有 pass，你没看错，源码里面就是写的 pass，这种实际上是由于底层是由 C 语言实现的（本文内容都是基于\nCPython），一般的操作是看不到源码的，之所以能看到是因为 Pycharm\n给我们提供的功能（其他编辑器不知道哈，没咋用过其他的），相当于以代码的形式看文档，所以我们看到的不是真正的源码，但是最接近于源码的源码，姑且称之为源码吧。\n\ntype 的参数说明：\n\n * 当 type() 只有一个参数时，其作用就是返回变量或对象的类型。\n\n * 当 type() 有三个参数时，其作用就是创建类对象：\n   \n   * 参数 1：what 表示类名称，字符串类型；\n   * 参数 2：bases 表示继承对象（父类），元组类型，单元素使用逗号；\n   * 参数 3：dict 表示属性，这里可以填写类属性、类方式、静态方法，采用字典格式，key 为属性名，value 为属性值。\n   \n   \n   \n   \n   \n   这样就添加了一个静态方法，很清楚哈，关于静态方法是什么我们后面会讲到，这里只需要知道 type 创建类的方法就好了。\n\n通过上面 type 的源码可以看到，type 是继承了 object 的，我们知道所有类的顶层类都是继承的 object，那 object\n又是从哪里来的？打印看一下：\n\n\n\n\n\n好家伙，object 也是由 type 创建的，前面说了 type 继承了 object，这俩哥们儿完美闭环了，我直接好家伙，理解起来有点更绕了哈。\n\n你也可以说 type 自己创建了自己，这里要细细的品。实际上如果你了解指针的概念，这里其实也不难理解，不就是自己指向自己嘛，所以说 type\n创建了所有类，因为他连他自己都不放过，还有什么事情做不出来。\n\n\n3、类变量和实例变量#\n\n（1）类变量是在类里面直接定义的变量，它可以被类对象访问和赋值，也可以被实例对象访问和赋值。\n\n\n\n\n\nb 是类变量，都能被访问和赋值，没问题哈。\n\n（2）实例变量是在构造函数里面定义的变量，它可以被实例对象访问和赋值，不能被类对象访问和赋值。\n\n\n\n\n\na 是实例变量，你看实例对象访问和赋值正常的，类对象访问就报错了。\n\n\n4、类方法、静态方法和实例方法#\n\n（1）实例方法又称对象方法，是类中最常见的一种方法。\n\n\n\n实例方法参数必须传入 self ，self 表示实例对象本身，实例方法的调用也必须通过实例对象来调用：\n\n\n\n（2）类方法\n\n\n\n可以通过类对象调用，也可以通过实例对象调用。\n\n\n\n注意两点：\n\n * 方法前面必须加装饰器 classmethod ，装饰器是 Python 中的一种语法糖，后面会讲到，记住这种固定用法，这种写法也是初代装饰器的用法。\n * 参数传入 cls ，cls 表示类对象，但是注意不是必须的写法，写 cls 是一种约定俗成的写法，方便我们理解，也就是说这里你写 self\n   从语法上也是不会有问题的。这就是为什么有时候我们将一个实例方法改成类方法，直接在方法前面添加了装饰器，而没有改 self，仍然能正常执行的原因。\n\n（3）静态方法，实际上就是普通的函数，和这个类没有任何关系，它只是进入类的名称空间。\n\n\n\n不需要传入任何参数。同样，可以通过类对象调用，也可以通过实例对象调用。\n\n\n\n我看到一些社区大佬都表现出对静态方法的嫌弃，他们觉得既然静态方法和类没有关系，何不如在类外面写，直接写在模块里面岂不快哉。咱们不予评价，存在即合理。\n\n\n5、类和实例属性的查找顺序#\n\n这里需要引入一个概念：MRO（Method Resolution Order），直译过来就是“方法查找顺序”。\n\n大家知道类是可以继承的，子类继承了父类，子类就可以调用父类的属性和方法，那么在多继承的情况下，子类在调用父类方法时的逻辑时怎样的呢，如果多个父类中存在相同的方法\n，调用逻辑又是怎样的呢，这就是 MRO。\n\n在 Python2.3 之前的一些查找算法，比如：深度优先（deep first\nsearch）、广度优化等，对于一些菱形继承的问题都不能很好的处理。这部分内容比较多且杂，可以自己查阅资料。\n\n在 Python2.3 之后，方法的查找算法都统一为叫 C3\n的查找算法，升级之后的算法更加复杂，采用的特技版拓扑排序，这里也不细讲，可以自己查阅资料，我们只需要关心现在方法查找顺序是怎样的就行了。\n\n来，这里举例说明：\n\n\n\n__mro__ 可以查看方法的查找顺序。\n\n\n\n可以看到，对于 C 来讲，它里面的方法查找顺序是 C — A — B，没毛病哈，很清楚。\n\n现在升级一下继承关系，试试菱形继承：\n\n\n\n\n\nD 的查找顺序是 D — B — C — A\n\n说明什么问题？我在这噼里啪啦说了这么多，到底想说啥？\n\n想象一下，如果你在 B 和 C 里面都重载了 A 里面的一个方法，此时如果你想调用的是 C 里面的方法，实际上是无法调用的，因为根据方法的查找顺序，会先找到 B\n里面的方法。\n\n因此，重点来了：在 Python 中虽然是支持多继承的，但是在实际项目中不建议使用多继承，因为如果继承关系设计得不好，很容易造成逻辑关系的混乱，原因就是\nMRO。\n\nRuby 之父在《松本行弘的程序世界》书中，讲到三点多继承的问题：\n\n>  * 结构复杂化：如果是单一继承，一个类的父类是什么，父类的父类是什么，都很明确，因为只有单一的继承关系，然而如果是多重继承的话，一个类有多个父类，这些父类\n>    又有自己的父类，那么类之间的关系就很复杂了。\n\n>  * 优先顺序模糊：假如我有A，C类同时继承了基类，B类继承了A类，然后D类又同时继承了B和C类，所以D类继承父类的方法的顺序应该是D、B、A、C还是D、B\n>    、C、A，或者是其他的顺序，很不明确。\n\n>  * 功能冲突：因为多重继承有多个父类，所以当不同的父类中有相同的方法是就会产生冲突。如果B类和C类同时又有相同的方法时，D继承的是哪个方法就不明确了，因为\n>    存在两种可能性。\n\n看看这是大佬说的，不是我说的。\n\n那有同学要问了，我写的功能很复杂啊，必须要继承多个类，怎么办，难受！\n\n实际上有一种比较流行且先进的设计模式：Mixin 混合模式，完美解决这个问题。\n\n举个简单的例子：\n\n\n\n现在动物们没有任何技能，咱们需要给动物们增加一下技能：\n\n\n\n注意 Mixin 的类功能是独立的，命名上也应该使用 MixIn 结尾，这是一种规范。\n\n需要 Run 技能的动物：\n\n\n\n需要 Fly 技能的动物：\n\n\n\n有点感觉了没，Mixin 类的特点：\n\n * 功能独立、单一；\n * 只用于拓展子类的功能，不能影响子类的主要功能，子类也不能依赖 Mixin；\n * 自身不应该进行实例化，仅用于被子类继承。\n\nMixin 设计思想简单讲就是：不与任何类关联，可与任何类组合。\n\n\n6、破解私有属性#\n\n私有属性就是在类的内部能访问，外部不能访问。\n\n在 Python 中没有专门的语句进行私有化，而通过在属性或方法前面加“两个下划线”实现。\n\n举例：\n\n\n\n\n\n\n\n你看，在类的内部访问私有属性是可以正常拿到的，方法也是一样的。\n\n现在我们访问私有属性试试：\n\n\n\n\n\n从外部进行私有属性访问是不行的，人家是私有的。\n\n\n\n\n\n私有方法也无法访问，没问题哈。\n\n有同学要问了，我就是想访问，越是私有的我越想看，怎么才能看到别人的隐私，快说！\n\n泄露天机了哈，这是 Python 一种很奇妙的结构化处理，为什么说是结构化处理，实际上 Python\n拿到双下划线之后，对其进行了变形，在前面加了一个下划线和类名，我们通过这种方式可以访问：\n\n\n\n\n\n你看，这样就可以正常访问了，但是既然作者不希望使用者调用这个方法，我们也尽量不要去强行使用它，强扭的瓜不甜。\n\n所以说，从语言的角度是没有绝对的安全，任何语言都是这样，更多的是一种编程上的约束。\n\n通常在大多数实践中，我们更倾向于使用一个下划线来表示私有属性，这不是真正的私有，而是一种更友好的编程规范，社区称之为\n“受保护的”属性，它向使用着表达了这是一个私有的方法，但是你仍然可以使用它，这就是社区，这就是开源，respect~。\n\n\n7、对象的自省机制#\n\n自省(introspection)，即自我反省，而对象的自省实际上就是查看对象实现了哪些属性或方法。\n\n简单讲就是，告诉别人：我是谁，我能干啥。\n\nPython 的常用的自省函数有四个：dir()、type()、 hasattr()、isinstance()\n\n（1）isinstance() 和 type() 前面也提到过，这里不讲了。\n\n（2）dir() 是最为常用的一个自省函数：\n\n引用前面的 Test 类\n\n\n\n\n\n除了 _Test__ki 和 go 方法以外，其他的方法都是魔法函数，即最开始我们提到的协议，你看随便一个对象就实现了这么多协议，是不是很神奇。\n\n（3）hasattr() 主要用于判断对象中是否包含某个属性，返回布尔值。\n\n\n\n\n\n很简单，不多讲哈。\n\n其他还有一些自省函数可以了解一下，偶尔用到也挺好的：\n\n * __doc__ 获取到文档字符串；\n * __name__ 获取对象的名称；\n * __dict__ 包含了类里可用的属性名-属性的字典；\n * __bases__ 返回父类对象的元组；但不包含继承树更上层的其他类。\n\n\n8、super#\n\nsuper 函数是用于调用父类的一个方法。\n\n\n\n\n\n\n\nsuper 的使用方法是很简单的，但是如果涉及到多继承的情况下，就要小心处理。\n\n准确的讲它不是调用父类的方法，而是调用的 MRO 顺序上的下一个方法。\n\n\n9、上下文管理器#\n\n在讲到上下文管理器的时候，经常有同学一脸懵，然后我说 with 的时候，就会脱口而出 with open 。\n\n没错，with 语句用得最多的也是这个，它是 Python 提供的一种处理资源回收的神奇方法，如果没有 with 我们可能需要多写很多代码。\n\n大家都知道打开一个文件之后是需要关闭的，但是在操作文件的过程中很容易报错，这时候我们需要进行异常处理，要保证无论是否存在异常的情况下，文件都能正常的被关闭，我们\n几乎只能使用try里面的finally来处理：\n\n\n\n如果用 with 语句处理就会很简单：\n\n\n\n对比起来，哪个更好不用多说，自己品。\n\n在《流畅的 Python》这本书里面提到：\n\n> 在任何情况下，包括CPython，最好显式关闭文件；而关闭文件的最可靠方式是使用with语句，它能保证文件一定会被关闭，即使打开文件时抛出了异常也无妨。\n\n那我们如何实现一个上下文管理器呢？\n\n * 基于类实现上下文管理器\n\n要实现上下文管理器，需要实现两个魔法函数：__enter__ 和 __exit__ 。\n\n看名称就知道了，enter 就是进入的时候要做的事情，exit 就是退出的时候要做的事情，很好记有没有。\n\n\n\n然后我们就可以使用 with 语句\n\n\n\n\n\n完美哈，一个上下文管理器的类就轻松搞定。\n\n * 基于 contextlib 实现上下文管理器\n\n还有种通过标准库实现上下文管理器的方法：\n\n\n\n来用 with 玩耍一下\n\n\n\n\n\n利用生成器的原理，yield 之前是进入，yield 之后是退出，同样可以实现一个上下文管理器，稍微理解一下哈。\n\n上下文管理器是 Python\n提供给我们的一个非常方便且有趣的功能，经常被用在打开文件、数据库连接、网络连接、摄像头连接等场景下。如果你经常做一些固定的开始和结尾的动作，可以尝试一下。\n\n\n10、装饰器#\n\n装饰器就是使用 @ 符号，像帽子一样扣在函数的头上，是 Python 中的一种语法糖。\n\n前面讲类方法和静态方法的时候提到过，使用方法非常简单。\n\n原理实际上就是将它所装饰的函数作为参数，最后返回这个函数。\n\n\n\n这样的写法等同于\n\n\n\n对比一下，使用装饰器可读性很高，很优雅是吧，语法糖就是给你点糖吃，让你上瘾。\n\n定义一个装饰器\n\n * 不带参数的装饰器\n\n举个例子：\n\n\n\n这是一个简单的装饰函数，用途就是在函数执行前后分别打印点日志。\n\n有2点需要注意：\n\n（1）装机器是一种高阶函数，在函数内层定义函数，并返回内层函数对象，多层级同理。\n\n（2）最外层函数传入的参数是被装饰函数的函数对象。\n\n\n\n来，试试看\n\n\n\n\n\n * 带参数的装饰器\n\n\n\n你看，都是外层函数返回内层函数对象，参数放在最外层。@wraps 可加可不加，它的用途主要是保留被装饰函数的一些属性值。\n\n\n\n执行试试\n\n\n\n\n\n很奈斯，就这点儿东西。\n\n这是最常见的实现方法，现在咱们搞点不一样的。\n\n基于类实现装饰器\n\n基于类装饰器的实现，必须实现 __call__ 和 __init__ 两个魔法函数。\n\n * 不带参数的类装饰器\n\n\n\n不带参数的类装饰，func 是通过 init 函数里面构造的。\n\n试试看\n\n\n\n\n\n\n\nso easy 哈，鸭子类型，实现了装饰器协议，就是装饰器对象。\n\n * 带参数的类装饰器\n\n\n\n带参数的类装饰器，func 是在 call 函数里面，参数是通过 init函数传入的，这里区别比较大哈。\n\n\n\n\n\n\n\n这类属于装饰器的高阶用法了，在一些优秀的框架源码里面比较常见。\n\n\n三、自定义序列#\n\n\n1、可切片对象#\n\n切片大家都很熟悉，在 Python 基础里面是必学的，对列表使用中括号取值，正切、反切、加步长等都没问题，这里我们主要讲怎么实现一个可切片对象。\n\n隆重请出魔法函数：__getitem__ ，它是我们实现可切片对象的关键。\n\n\n\n咱们对实例对象切片试试\n\n\n\n\n\n简直没难度哈，对象可以切片了。\n\n这里再补充一点没有用的小知识，实现了 __getitem__ 方法实际上也是一个可迭代的对象了，也就是说可以使用 for 循环。\n\n\n\n\n\n这其实是可迭代对象的一种退而求其次的处理，它找不到迭代协议，但是找到了 __getitem__ ，也可以进行迭代，这点相信 99%\n的同学都不知道，没关系哈，关于可迭代对象和迭代器咱们后面会专门讲。\n\n\n2、列表推导式#\n\n列表推导是 Python 提供的一种独有特性，可以用一行代码生成一个列表。\n\n普通操作：\n\n\n\n这样生成一个列表，至少需要3行，来看看列表推导式：\n\n\n\n一行就搞定，多么的简洁优雅，而且可读性和性能都非常高，爱了。\n\n还可以加一些逻辑判断和数据处理，以下是项目实例：\n\n\n\n这里要提醒一下，不要为了推导而推导，如果你的逻辑很复杂，加了多重判断和处理，不建议使用推导式，老老实实分开写，因为这样写出来的表达式会很复杂，就失去了我们编码最\n重要的一点，就是可读性。\n\n\n3、生成器表达式#\n\n前面讲了列表推导式，是用中括号里面写表达式，那把中括号换成小括号是什么呢？好多同学聪明的小脑袋肯定想到了，元组推导式 ... 。\n\n注意元组是不可变序列，没法推导的，小括号的表达式实际上是生成器表达式。\n\n\n\n验证一下：\n\n\n\n\n\n你看，确实是一个生成器吧。生成器细节，咱们也放到后面讲哈。\n\n\n4、字典推导式#\n\n理解了列表推导式，再来看字典推导式就很简单了。\n\n\n\n第一个元素就是字典的 key 和 value，注意字典的key 是唯一的（可哈希），值无所谓。\n\n打印看下\n\n\n\n\n\n就这，简直没难度，还是要注意一点，代码可读性哈，别整复杂了。\n\n\n\n这是自动化测试项目中的一个实例，感受下，如果再复杂点就建议拆开写了。\n\n\n四、对象引用#\n\n\n1、变量到底是什么#\n\n在 Python 中变量到底是什么，有一个比喻我觉得非常好，变量就像便利贴。\n\n为什么这么讲，我们定义一个数据，比如定义一个字符串或者整数，在内存中都会分配一个空间来保存，这个内存空间相当于一个小盒子，我们使用等号将这个数据赋值给一个变量时\n，实际上就像用便利贴贴到这个小盒子上，便利贴上还写了名称，就是变量名。所以说，变量和数据的关系只是一个指向的关系。\n\n一个数据可以赋值给多个变量，相当于这个小盒子上面贴了多个便利贴；一个变量也可以被重新赋值，相当于把这个盒子上的便利贴撕了，贴到另一个盒子上。\n\n变量和数据的关系，就是盒子和便利贴的关系，理解起来很容易。\n\n函数名也是变量，是可以传参的变量，也同样是便利贴。\n\n\n2、== 和 is 是一样的吗#\n\n这两个在编程中经常用到，好多同学经常搞不清楚应该用哪个。\n\n * == 是比较两边的“值”是否相等;\n * is 是判断是否为同一个对象，即 id 是否一样。\n\n\n\n\n\n这里有个很神奇的地方，分别定义了两个变量a, b，他们的值相等，但是这样定义应该是分配了2个内存空间，更有意思的是，如果你通过命令行执行以上代码，结果会不一样：\n\n有这个符号的 >>> 表示是在命令行执行。\n\n\n\n上面是使用 Pycharm 执行的，实际上Python解释器已经对经常使用到的小整数做了特殊处理，解释器会提前将 256\n以内的整数申请内存空间，不会回收，以提升执行效率，所以在这个范围内的整数 id 永远是一样的。\n\n\n\n\n\nPycharm 在解释器的基础之上做了进一步的优化。\n\n\n\n你看，这么大的数字 id 也是相同的，Pycharm 就是这么酷。\n\n\n3、del语句和垃圾回收#\n\n在 Python 中的垃圾回收机制是：引用计数（Reference Counting）。\n\n简单讲就是每个对象内部有一个引用计数器，对象被创建或者被引用就会 +1，对象被销毁或者被赋予新的对象就会 -1\n\ndel 语句是作用在变量上，不是数据对象上。\n\n\n\n打印 b 看下\n\n\n\n\n\n再打印 a 看下\n\n\n\n\n\n很明显，a 被删掉了。\n\n之前看到国外的一个大佬讲 open 的这种写法不用关闭：\n\n\n\n很有意思是吧，这点没有用的小知识，相信你在网上应该查不到。当时觉得不太理解，后面理解垃圾回收之后才明白，使用 open\n打开的文件对象创建之后，没有被其他引用，所以会被内存回收的，因而不用关闭也不影响。\n\n邪门歪道哈，用 open 还是老老实实用 with 吧。\n\n\n五、元类编程#\n\n\n1、动态属性和属性描述符#\n\n有些同学可能知道 @property ，它的主要用于将一个方法变成属性，访问的时候直接通过名称访问，不需要加括号。注意加了 @property\n函数不能有参数，你想嘛，人家调用的时候都不用括号，怎么传参，对吧。\n\n举个小例子：\n\n\n\n\n\n你看，调用 age 方法没加括号吧，那我要修改 age 的值怎么做呢？\n\n\n\n\n\n注意上例中装饰器的写法，setter 是固定写法，setter 前面是你定义的函数名。\n\n没什么问题哈，做了参数的类型检查，整体看起来不算复杂，其实了解到这里已经差不多了。但是，如果我们还有其他属性要处理，就得写好多个这样的，挺费劲不说，关键是不够优\n雅。\n\n这时候就需要请出属性描述符。\n\n这里又要介绍两个魔法函数：__get__， __set__。\n\n举个例子，讲解其用法：\n\n\n\n真正使用的类：\n\n\n\n\n\n在对象访问 age 的时候，首先是进入了 __get__ 方法，因为先打印了 get_instance 和 get_owner，instance 是\nMikigo 实例对象，也就是 mi，owner 是 Mikigo 类对象。\n\n因此，到这里，我们知道了第一个小知识，在访问值的时候，调用的是 __get__ 。\n\n再赋值看看：\n\n\n\n\n\n第二个小知识，赋值是调用的 __set__ 方法，一般为了使属性描述符成为只读的，应该同时定义 __get__() 和 __set__() ，并在\n__set__() 中引发 AttributeError 。\n\n还有一个魔法函数 __delete__ 也是属性描述符，使用 del\n会调用，由于不咋使用，不讲了，还有网上好多区分数据描述符和非数据描述符的，我感觉不用管也没必要，咱们是通俗易懂版，不整那些。\n\n\n2、属性拦截器#\n\n属性拦截器就是在访问对象的属性时要做的一些事情，你想嘛，拦截就是拦路抢劫，拦截下来肯定要搞点事情才放你走。\n\n主要介绍 2 个魔法函数：__getattr__ 和 __getattribute__\n\n这两个函数特别神奇，两个函数功能相反，一个是找到属性要做的事，另一个是没找到属性要做的事。\n\n\n\n定义了一个属性 age ，先来试试访问它\n\n\n\n\n\n找到属性，会先调用 __getattribute__ ，并没有调用 __getattr__。\n\n好，现在访问一个不存在的属性：\n\n\n\n\n\n这里就需要注意了，访问一个不存在的属性，首先还是会进入 __getattribute__ ，说明它是无条件进入的，然后才是调用 __getattr__。\n\n再扩展一个 __setattr__ 用于修改属性值的：\n\n\n\n\n\n你看，age 的值被修改了，但是 __setattr__ 貌似被调用了 2 次，那是因为在类实例化的时候就会进入一次，第一次是将 __init__\n里面的值添加到类实例的 __dict__ 属性中，第二次修改再次进入，将 __dict__ 属性中的值修改掉。\n\n属性拦截一定要谨慎使用，一般情况下不建议使用，因为如果处理不好，会造成类里面属性关系的混乱，抛异常往往不容易定位。\n\n项目实例，config 文件里面用到：\n\n\n\n试着分析下他们的作用吧，逻辑很简单的，你一定能看懂。\n\n\n3、自定义元类#\n\n元类（metaclass）就是生成类的类，先定义metaclass，就可以创建类，最后创建实例。\n\n其实最开始讲 type 的时候已经有所接触了，type 生成了所有类，它就是顶层元类，metaclass 也是要继承\ntype的，排行顶多老二，是不是应该叫“元二类”，或者“元类二”，爱谁谁吧。\n\n来，咱们定义一个元类，用途是添加一个属性 age ：\n\n\n\n这里有 2 个知识点：\n\n * __new__ 也是构造函数，和 __init__ 有区别，__new__ 是用来构造类对象的，你看它的参数是 cls，必须 return 一个对象。\n * name, bases, dct 这三个参数和 type 的三个参数是一个意思，不清楚可以回看前面讲 type 的章节。\n\n元类有了，咱们使用一下，既然元类是用来生成类的类，那咱们就来生成一个类：\n\n\n\n\n\n咱们定义一个类除了省略号没有任何属性，省略号也是一个对象，你也可以用 pass，但是仍然可以访问 age 属性。因为我们是通过元类，向 Mikigo\n这个类添加了一个属性，元类有时称为类工厂。\n\n\n六、迭代器和生成器#\n\n\n1、迭代协议#\n\n迭代就是可以使用循环将数据挨个挨个取出来，这个好理解是吧，比如，咱们常见的对一个列表进行迭代：\n\n\n\n结果不用讲肯定是挨着取出列表里面的数字了。\n\n那列表里面究竟是实现了什么协议，或者说一个对象实现什么魔法函数就可以迭代呢，这就是迭代协议：__iter__\n\n一个类只要实现了魔法函数 __iter__ 就是可迭代的（Iterable），但是它还不是迭代器(Iterator)，品一下区别。\n\n\n\n来验证一下：\n\n\n\n\n\n你看实现了迭代协议，就是可迭代的，想起鸭子类型了吗。\n\n\n2、迭代器和可迭代对象#\n\n我们现在知道一个对象只要实现了 __iter__ 就是一个可迭代的对象，现在咱们来试试对一个可迭代对象使用 for 循环进行迭代，放个简单的列表进去看看：\n\n\n\n在 __iter__ 函数里面返回一个列表，列表是一个可迭代的对象，但不是迭代器。\n\n\n\n运行报错了，说 iter 返回了一个不是迭代器的对象。说明在 __iter__\n里面需要返回一个迭代器，对吧，其他的先不管，咱们放一个迭代器进去，保证程序跑起来不报错。\n\n放一个生成器表达式进去试试：\n\n\n\n\n\n唉，这下对了，没报错，而且也能迭代出来了。\n\n但是，此时仍然还不是一个迭代器，要实现迭代器，还必须要实现另外一个魔法函数：__next__\n\n\n\n验证一下\n\n\n\n\n\n你看，实现 __next__ 之后，就是一个迭代器了。那 __next__ 应该怎么写，前面我们已经看到， __iter__\n里面是不负责逻辑处理的，它只管返回，逻辑处理需要在 __next__ 里面去做。\n\n使用经典的斐波那契数列来举例：\n\n\n\n这里面 n 是用来限制迭代次数的，不然这个循环将一直进行下去，直到宇宙的尽头，抛 StopIteration 异常会被 for 循环自动处理掉。\n\n\n\n\n\n这样我们就实现了一个简单的迭代器。\n\n简单一句话总结一下：迭代器就是使对象可以进行 for 循环，它需要实现 __iter__ 和 __next__ 两个魔法函数。\n\n有同学要说了，就这？不就用 for 循环嘛，搞这么复杂嘎哈，我为什么要用迭代器啊？\n\n为什么要使用迭代器\n\n节省资源消耗，迭代器并不会计算每一项的值，它只在你访问这些项的时候才计算，也就是说它保存的是一种计算方法，而不是计算的结果。能理解吗，相当于迭代器是鱼竿，而不是\n一池子的鱼，需要鱼的时候钓就行了，而不用把所有鱼都搬回家。\n\n平时可能感受不到哈，当你需要计算一个非常大的数据时，你就能感受到了，这就是“惰性求值”的魅力。\n\n你可以试试前面的斐波那契数列的列子，对比一个普通的列表，然后给一个很大的数字，区别就很明显了。\n\n\n3、生成器#\n\n生成器也是一种迭代器，特殊的迭代器，它也可以用 for 循环来取值，但是大部分的情况下是使用 next() 函数进行取值。\n\n前面我们讲生成器表达式已经见识过，这是一种便携的写生成器的方法：\n\n\n\n\n\n一般这么玩的哈。\n\n前面讲的好多对象都是在类里面定义的，而生成器对象就不是在类里面了，而是在函数里面定义，在一个函数里面只要出现了 yield 它就不是普通函数，而是一个生成器。\n\n\n\n\n\nyield 的用途是让函数暂停，并保存对象状态在内存中，下次再使用 next 调用同一个对象时，又开始从之前暂停的位置开始执行，直到运行到下一个 yield\n又暂停，如果后面没有 yield了，则会抛 StopIteration 异常。\n\nyield 和 return 都能返回数据，但是有区别，return 语句之后的代码是不执行的，而 yield 后面还可以执行。\n\n有同学要问了，生成器函数里面能用 return 吗？好问题，不愧是你。\n\n生成器里面是可以用 return 的，但是，return 后面的数据不会被返回。\n\n举例：\n\n\n\n\n\n你看，3 并没有被返回，所以说生成器里面的 return 只是一个结束的标志，它不会把后面的值返回给调用者，这跟函数里面的 return 是不一样的。\n\n\n4、总结#\n\n看完前面迭代器和生成器的内容，可能有些同学有点晕了，没关系，多看几遍，经常看，经常晕。\n\n我们简单总结一下：\n\n * 迭代器需要实现两个魔法函数：__iter__ 和 __next__ ；\n\n * 迭代器允许惰性求值，只有在请求下一个元素时迭代器对象才会去生成它，它保存的是一种生成数据的方法；\n\n * 生成器是迭代器的一种更 Pythonic 的写法，可以在函数里面用 yield 创建一个迭代器；\n\n * 生成器表达式是生成器的一种更加 Pythonic 的写法。\n\n\n七、高阶函数#\n\n高阶函数是通过组合简单函数成一个复杂表达式的函数。你可以理解成，函数套函数。函数式编程是一种编程范式，这部分内容可以体现 Python 在函数式编程上的应用。\n\n\n1、lambda#\n\n匿名函数（lambda），这个函数没有函数名，用于一行创建一个函数，并返回一个函数对象，也是一种语法糖。\n\n定义一个匿名函数，功能就是参数加1：\n\n\n\n普通函数的写法就是：\n\n\n\n你看，确实很简洁哈，my_lb 不是函数名哈，有函数名它就不是匿名函数了，而是函数对象，咱可以调用它。\n\n\n\n我个人觉得，匿名函数很尴尬，基本上都是用在下面几个高阶函数里面的，如果你平时也想用它，大多数情况下是不符合社区规范的。简单的表达式还行，复杂的表达式可读性太差。\n\n传言 Python 之父 Guido 也不推荐使用它，甚至曾想过移除它，后来放弃了，估计是不好搞。就像 GIL\n一样，大家都知道不好，但是这么多年下来太多库都用到了，哪是你想删就能删的，社区不答应，我也不答应。\n\n\n2、map#\n\nmap 函数是给一个序列做映射，然后返回结果序列。\n\n简单通俗讲就是：拿到一个序列，给序列中元素一顿操作之后，返回序列。\n\n\n\n\n\n你看，map 返回的是一个对象，转 list 之后每个元素的加了1。\n\n\n3、reduce#\n\nreduce 函数就是对一个序列做累积，即将序列中前一个元素和后一个元素进行逻辑组合，然后结果再和后面一个元素组合。\n\n简单通俗讲就是：拿到一个或多个序列，给序列中元素一顿操作之后，返回操作结果。\n\n\n\n\n\n你看，把列表中的元素都相加了，注意组合关系不一定是相加，你可以换成相乘试试。\n\n乍一看和上面的 map 是一个意思哈，确实用法一样，区别就是 reduce 函数里面的 lambda 函数有两个参数，而 map\n函数参数理论上可以多个，但是每个参数对应一个序列，也就是说，有多少个参数，就要有多少个序列。\n\n\n4、filter#\n\nfilter 函数用于过滤的，即将序列中的每个元素进行判断，然后返回为 True 的元素。\n\n\n\n\n\n判断序列中哪些数是奇数，filter 返回的是一个对象，转列表之后，可以看到结果。\n\n\n5、sorted#\n\nsorted 函数用于排序，好多同学可能用过它的参数 reverse=False 升序（默认），reverse=True 降序，但是还有个参数 key\n可能没咋用过，这里可以给表达式。\n\n\n\n\n\n数字排序还是挺好用的哈，处理简单的字符串也都可以，但是如果是处理比较复杂字符串排序就有点费劲了，不信试试看：\n\n\n\n我想让这个列表按照结尾的序号排序：\n\n\n\n\n\n排了个寂寞，无论是升序还是降序都是不行的。\n\n所以需要使用参数 key，加表达式：\n\n\n\n\n\n唉，这就对了，我们在表达式里面将结尾的序号取出来，key\n就是关键字，意思就是按照我取出来的关键字排序。这里稍微理解一下哈，里面的表达式比较灵活，你也可以用正则表达式来做：\n\n\n\n也都是可以的哈，没毛病。\n\n它不仅可以对列表排序，只要是可迭代对象都可以，列表对象的内建方法 sort 也可以这样用，但区别是 sort 是对原列表进行排序，不返回新列表。\n\n这里再补充一个小知识，我们经常往一个列表中去添加数据，然后对其进行排序，这样做没啥问题，但是如果数据量大了之后，性能会比较低。\n\n维护一个排序序列，建议使用Python 的标准库 bisect 来做，它是采用二分查找算法，性能较高。\n\n\n6、zip#\n\nzip 就是将多个序列打包成一个个元组，然后返回由这些元组组成的列表。\n\n\n\n\n\nzip 返回的是一个对象，实际上是一个迭代器对象。\n\n转列表之后，可以看到，相当于是把元素纵向分别取出来，放到一个元组里面，然后元组组成一个列表。做数据处理的时候经常用到，了解一下。","routePath":"/编程基础/Python/Python从进阶到高级—通俗易懂版","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、类和对象","id":"二类和对象","depth":2,"charIndex":583},{"text":"1、鸭子类型","id":"1鸭子类型","depth":3,"charIndex":593},{"text":"2、类型判断","id":"2类型判断","depth":3,"charIndex":1076},{"text":"3、类变量和实例变量","id":"3类变量和实例变量","depth":3,"charIndex":2150},{"text":"4、类方法、静态方法和实例方法","id":"4类方法静态方法和实例方法","depth":3,"charIndex":2327},{"text":"5、类和实例属性的查找顺序","id":"5类和实例属性的查找顺序","depth":3,"charIndex":2863},{"text":"6、破解私有属性","id":"6破解私有属性","depth":3,"charIndex":4265},{"text":"7、对象的自省机制","id":"7对象的自省机制","depth":3,"charIndex":4818},{"text":"8、super","id":"8super","depth":3,"charIndex":5313},{"text":"9、上下文管理器","id":"9上下文管理器","depth":3,"charIndex":5431},{"text":"10、装饰器","id":"10装饰器","depth":3,"charIndex":6227},{"text":"三、自定义序列","id":"三自定义序列","depth":2,"charIndex":6933},{"text":"1、可切片对象","id":"1可切片对象","depth":3,"charIndex":6944},{"text":"2、列表推导式","id":"2列表推导式","depth":3,"charIndex":7275},{"text":"3、生成器表达式","id":"3生成器表达式","depth":3,"charIndex":7518},{"text":"4、字典推导式","id":"4字典推导式","depth":3,"charIndex":7677},{"text":"四、对象引用","id":"四对象引用","depth":2,"charIndex":7844},{"text":"1、变量到底是什么","id":"1变量到底是什么","depth":3,"charIndex":7854},{"text":"2、== 和 is 是一样的吗","id":"2-和-is-是一样的吗","depth":3,"charIndex":8177},{"text":"3、del语句和垃圾回收","id":"3del语句和垃圾回收","depth":3,"charIndex":8567},{"text":"五、元类编程","id":"五元类编程","depth":2,"charIndex":8917},{"text":"1、动态属性和属性描述符","id":"1动态属性和属性描述符","depth":3,"charIndex":8927},{"text":"2、属性拦截器","id":"2属性拦截器","depth":3,"charIndex":9684},{"text":"3、自定义元类","id":"3自定义元类","depth":3,"charIndex":10291},{"text":"六、迭代器和生成器","id":"六迭代器和生成器","depth":2,"charIndex":10778},{"text":"1、迭代协议","id":"1迭代协议","depth":3,"charIndex":10791},{"text":"2、迭代器和可迭代对象","id":"2迭代器和可迭代对象","depth":3,"charIndex":11040},{"text":"3、生成器","id":"3生成器","depth":3,"charIndex":11920},{"text":"4、总结","id":"4总结","depth":3,"charIndex":12476},{"text":"七、高阶函数","id":"七高阶函数","depth":2,"charIndex":12720},{"text":"1、lambda","id":"1lambda","depth":3,"charIndex":12811},{"text":"2、map","id":"2map","depth":3,"charIndex":13157},{"text":"3、reduce","id":"3reduce","depth":3,"charIndex":13268},{"text":"4、filter","id":"4filter","depth":3,"charIndex":13537},{"text":"5、sorted","id":"5sorted","depth":3,"charIndex":13643},{"text":"6、zip","id":"6zip","depth":3,"charIndex":14177}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":78,"title":"Python包构建和发布","content":"#\n\n\n1、必要的文件#\n\n除了你的源代码以外，你还需要准备以下文件；\n\n\nLICENSE#\n\n开源协议文件\n\n这里以我的项目用到的开源协议举例：\n\nhttps://github.com/funny-dream/pdocr-rpc/blob/main/LICENSE\n\n\nREADME#\n\n介绍这个包的安装及使用，理论上你可以写任何东西在上面，主要让别人全方位了解这个包的使用；\n\n\npyproject.toml#\n\n网络上大多关于 Python 打包使用的都是 setup.py，最新最流行的是使用 pyproject.toml，pypi 官方也推荐使用它；\n\n相比于setup.py，pyproject.toml 的描述更为精细，但也更为繁琐，如果你是高定玩家，当然首选 pyproject.toml ；\n\n当然，常用的几个东西都差不多，下面就以我的项目举例简单介绍一下：https://github.com/funny-dream/pdocr-rpc/blob/ma\nin/pyproject.toml\n\n里面主要包含这些内容：\n\nbuild-system#\n\n\n\n构建系统\n\nproject#\n\n\n\n这里面就是一些基本信息，你可以按照自己的实际情况修改；\n\n注意：\n\n（1）classifiers 里面 License\n字段要和项目的开源协议一致；在这里列出了所有的开源协议应该怎么写：https://pypi.org/classifiers/\n\n（2）dependencies 是你项目的依赖，别人使用 pip 安装的时候会同时安装上这些依赖；\n\n注意这里如果有一些条件，比如有些包有版本的、操作系统、Python版本的限制，必须要按照规范写：https://peps.python.org/pep-0508\n/\n\n（3）可选依赖\n\n\n\n这些是可选的，安装的时候可以这样进行安装：\n\n\n\n这样就会安装 pytest\n\n（4）urls\n\n\n\n这个在 pypi 的网页端能展示，别人可以通过那里跳转的你的文档或源码页面；\n\n（5）version\n\n\n\n用一个 __version__.py 指定版本是比较优雅的方法；\n\n\n\n关于 project\n下的详细内容及规范，请查看：https://packaging.python.org/en/latest/specifications/declaring-pr\noject-metadata/#declaring-project-metadata\n\n\n2、打包#\n\n安装打包工具：\n\n\n\n打包：\n\n\n\n完成后应生成两个目录中的文件：dist\n\n\n\n\n3、发布#\n\n首先你需要注册一个 pypi 的账号：https://pypi.org/account/register/\n\n安装发布工具：\n\n\n\n发布：\n\n\n\n输入你的账号密码即可发布到 pypi，以后每次发布包记得更新版本；","routePath":"/编程基础/Python/Python包构建和发布","lang":"","toc":[{"text":"1、必要的文件","id":"1必要的文件","depth":2,"charIndex":3},{"text":"LICENSE","id":"license","depth":3,"charIndex":37},{"text":"README","id":"readme","depth":3,"charIndex":135},{"text":"pyproject.toml","id":"pyprojecttoml","depth":3,"charIndex":191},{"text":"build-system","id":"build-system","depth":4,"charIndex":468},{"text":"project","id":"project","depth":4,"charIndex":491},{"text":"2、打包","id":"2打包","depth":2,"charIndex":1051},{"text":"3、发布","id":"3发布","depth":2,"charIndex":1100}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":79,"title":"Python基础语法—8小时入门版","content":"#\n\n\n一、Python基础#\n\n\n（一）输入输出#\n\n1. print\n\n\n\n2. input\n\n\n\n\n（二）数据类型#\n\n\n\n\n（三）变量、表达式#\n\n1. 变量赋值\n\n（1）name=\"mikigo\" 表示将 mikigo 这个字符串赋值给变量 name，注意要加引号，不加引号会被认为是一个变量\n\n（2）a,b,c=7,8,9 多元赋值，表示将值一一对应的复制到等号前面的变量，但位置的个数一定要一致。\n\n（3）数据类型的转换\n\n\n\n2. 表达式\n\n\n\n\n（四）字符串 string#\n\n1.格式化字符串\n\n\n\n2.字符串操作\n\n（1）字符串相加，比如：\"mi\" + \"ki\" > miki；\n\n（2）星号相乘，比如：2 * \"mi\" > mimi；\n\n（3）[ ] 表示通过索引截取字符，第 1 个字符索引是 0 ；\n\n（4）[ : ] 表示截取字符串 比如：[2:4] 表示从索引 2 开始，截取到索引 3（不包含 4 ）；\n\n（5）in 表示 in 后面字符串中是否包含 in 前面的字符，比如：\"i\" in \"miki\" >> True；\n\n（6）not in 用法与 in 类似但是取反；\n\n（7）r/R 表示所有字符都按照字面意思来使用。比如：print(r\"hello\\nmikigo\") 换行字符 \\n 不起作用，直接输入引号内的字符串。\n\n3.字符串的常见函数方法\n\n（1）len(str) 返回字符串的长度；\n\n（2）count 计数；\n\n\n\n（3）startswith 或 endswith 以什么开始或以什么结束；\n\n\n\n（4）find 查找字符或字符串，返回索引位置，如果找不到会返回 -1；\n\n\n\n（5）index 用法同 find，区别在于，找不到时会报错；\n\n（6）strip 删除或截掉；\n\n\n\n（7）replace 替换\n\n\n\n（8）join 加入：\"miki\".join(\"ab\") >> \"amikib\" 每个字符拆开，加入某个字符或字符串。\n\n（9）split 以分隔符截取\n\n\n\n\n（五）列表（list）#\n\n1.list基本操作\n\n\n\n2.切片\n\n\n\n3.list常见的函数和方法\n\n（1）函数\n\n\n\n（2）方法\n\n\n\n\n（六）元组（tuple）#\n\n定义：以小括号括起来的有序列表，但不能修改。\n\n\n\n\n（七）字典（dict）#\n\n1.定义：字典是用大括号括起来，由键值对（key:value）组成的，且是无序的。\n\n2.key 是唯一的，一般赋值为 string，value 可以是任意数据类型\n\n3.常用操作\n\n\n\n4.dict常用方法\n\n\n\n\n二、过程控制#\n\n\n（一）条件语句#\n\n1.句式：\n\n\n\n2.else 可以不要，语法上没有问题\n\n3.运算符\n\n(1) < , <= , > , >= , == , !=\n\n(2）and , or , not , in , not in, is\n\n\n（二）循环语句#\n\n1.while\n\n\n\n\n\n2.for语句（遍历序列的元素）\n\n\n\n * in 后面可以跟元组、列表、字符串，但跟字典时只能取到字典中的键（key）。\n\n * range(函数)\n   \n   * range(3) 表示从索引0，取到索引2（开区间）\n   * range(1,4) 表示从索引1，取到索引3\n   * range(1,10,2) 表示从索引1，取到索引10，步长为2\n\n\n三、函数#\n\n\n（一）定义#\n\n函数是可重复使用的，具有一定功能的代码段。\n\ndef 函数名（参数1，参数2，····）\n\n\n\n\n（二）返回值#\n\n调用函数后，将执行结果返回给调用者。\n\n\n\n>>x=add(1,2) # 返回一个c的值赋给x，如果返回值有多个，而变量只有1个，则会生成一个元组。也可以用多个变量对应多个返回值，即多元赋值。\n\n\n（三）参数#\n\n1、位置参数(形参)#\n\n\n\n位置参数时根据位置顺序传入函数，调用函数时必须与定义时的参数数量一致。\n\n2、默认参数#\n\n * def func(name, age=18): print(\"a未被定义\") # 参数在定义的时候就赋值的\n\n * 默认参数在调用的时候如果不传入，则会使用默认参数，如果给传递了参数，则值会被覆盖。\n\n3、可变参数#\n\n\n\n>>func(1,2,3,···) 传入的参数数量可变，会自动组装称一个元组，如果传入0个参数，结果时返回一个空元组。\n\n * 如果传入的参数是一个元组，调用的时候在函数括号内加*号（参数解构）\n   \n   tp=（1，2，3，4）\n   \n   resule = add(*tp)\n\n4、关键字参数（键和值）#\n\n\n\n>>func(name=\"peter\")\n\n * 如果传入的参数是一个字典，调用的时候在函数括号内加**\n   \n   \n\n5、组合参数#\n\n顺序为位置参数，可变参数，默认参数，关键字参数\n\n\n\n\n四、类（class）#\n\n\n（一）类的实例#\n\n1.类的实例是对象，一个实例包含属性（有什么）和方法（能做什么）。\n\n2.类的声明：class 类名(): 类名单词首字母大写，如果是多个单词，单词与单词之间不空格，直接挨着写，但每个单词首字母需要大写。\n\n3.定义类的属性和方法\n\n\n\n（2）方法调方法或方法调属性等，内部调用都要加self。 ②\n\n（3）调用外部变量时，不加self。\n\n（4）调用\n\n\n\n\n（二）继承#\n\n子类继承父类的属性和方法\n\n\n\n\n\n方法重新定义后，调用的时候，默认先去调用子类的方法，然后再去调用父类的方法。\n\n\n（三）访问限制#\n\n1．访问限制可以使，类内部的属性和方法，不能外部随便访问。用法是在属性或方法前面加双下划线，表示私有属性。\n\n2．访问限制，不能被外部随便访问，但可以被内部调用，私有属性可以用方法调用，私有方法，可以定义其他方法调用。\n\n\n\n\n（四）编码规范#\n\n1．缩进，4个空格的缩进，空格和tab不能混用（tab仅在编辑器中可使用）。\n\n2．类名的单词以大写字母开头。\n\n3．函数和类的属性命名以小写，用下划线连接\n\n4．所有的命名都应采用有意义的英文单词，多单词由下划线连接。\n\n\n五、模块#\n\n\n（一）引入模块#\n\n（1）import 后面直接跟模块名或类或函数。\n\n\n\n（2）from 路径 import 类或函数 #路径最好用绝对路径。\n\n\n\n\n（二）安装三方库#\n\n（1）sudo pip3 install pymysql(三方库名) # 在命令行直接输入即可。\n\n（2）在 pycharm 里面，点击 file，选择 setting，选择 Project，选择 Project Interpreter，在右上角点 +\n号，输入库名即可安装。\n\n（3）如果是需要下载的三方库，下载后查看文件包里面的 readme 文件，根据描述进行安装。\n\n\n六、异常处理#\n\n\n（一）try语句#\n\n（1）try ... except...except 表示当程序运行错误后，被 except 捕捉到，返回一个可定义的信息，且不会影响后续语句的执行。每个\nexcept 后面跟不同的返回信息。\n\n\n\n（2）try ...except...finally 同（1）一样，但 finally 后的语句，无论是否发生异常，都会执行。\n\n（3）try...except...else 同（1）一样，但 **else ** 后的语句，是在没有发生异常的情况才会执行。\n\n\n（二）抛出异常#\n\n① raise NameError(\"这是一个名称错误\")\n\n\n（三）常见的异常#\n\n① AssertionError assert（断言）语句失败。\n\n② AttributeError 试图访问一个对象没有的属性，比如foo.x，但是foo没有x这个属性。\n\n③ IOError 输入/输出异常，基本上是无法打开文件。\n\n④ ImportError 无法引入模块或者包，基本上是路径问题。\n\n⑤ IndentationError 语法错误，代码没有正确对齐。\n\n⑥ IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]。\n\n⑦ KeyError 试图访问字典里不存在的键。\n\n⑧ Kerboardinterrupt Ctrl+C被按下，主要针对无限循环。\n\n⑨ NameError 使用一个还未被赋值予对象的变量。\n\n⑩ SyntaxError 代码非法，代码不能解释。\n\n⑪ TypeError 传入对象类型与要求的不符。\n\n⑫ UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另一个同名的全局变量，导致你以为正在访问它。\n\n⑬ ValueError 传入一个调用者不期望的值，即使值的类型是正确的。\n\n⑭ FileNotFoundError 试图打开一个不存在的文件或目录。\n\n\n七、文件读写#\n\n\n（一）以读的形式打开，并能写（r+）#\n\n 1. \n\n\n\n2.光标会放在文件开头，输入的输入会覆盖开头\n\n\n（二）以写的形式打开，并能读(w+)#\n\n 1. \n\n\n\n2.若文件已存在会将其覆盖，若文件不存在，会新建文件。\n\n\n（三）追加模式（a+）#\n\n 1. \n\n\n\n2.光标在文件的末尾，写入会追加到末尾，若文件不存在，会新建文件。\n\n","routePath":"/编程基础/Python/Python基础语法—8小时入门版","lang":"","toc":[{"text":"一、Python基础","id":"一python基础","depth":2,"charIndex":3},{"text":"**（一）输入输出**","id":"一输入输出","depth":3,"charIndex":-1},{"text":"**（二）数据类型**","id":"二数据类型","depth":3,"charIndex":-1},{"text":"**（三）变量、表达式**","id":"三变量表达式","depth":3,"charIndex":-1},{"text":"**（四）字符串 string**","id":"四字符串-string","depth":3,"charIndex":-1},{"text":"**（五）列表（list）**","id":"五列表list","depth":3,"charIndex":-1},{"text":"**（六）元组（tuple）**","id":"六元组tuple","depth":3,"charIndex":-1},{"text":"**（七）字典（dict）**","id":"七字典dict","depth":3,"charIndex":-1},{"text":"**二、过程控制**","id":"二过程控制","depth":2,"charIndex":-1},{"text":"**（一）条件语句**","id":"一条件语句","depth":3,"charIndex":-1},{"text":"**（二）循环语句**","id":"二循环语句","depth":3,"charIndex":-1},{"text":"三、函数","id":"三函数","depth":2,"charIndex":1432},{"text":"（一）定义","id":"一定义","depth":3,"charIndex":1440},{"text":"（二）返回值","id":"二返回值","depth":3,"charIndex":1497},{"text":"（三）参数","id":"三参数","depth":3,"charIndex":1605},{"text":"1、位置参数(形参)","id":"1位置参数形参","depth":4,"charIndex":1613},{"text":"2、默认参数","id":"2默认参数","depth":4,"charIndex":1665},{"text":"3、可变参数","id":"3可变参数","depth":4,"charIndex":1778},{"text":"4、关键字参数（键和值）","id":"4关键字参数键和值","depth":4,"charIndex":1933},{"text":"5、组合参数","id":"5组合参数","depth":4,"charIndex":2012},{"text":"四、类（class）","id":"四类class","depth":2,"charIndex":2049},{"text":"（一）类的实例","id":"一类的实例","depth":3,"charIndex":2063},{"text":"（二）继承","id":"二继承","depth":3,"charIndex":2254},{"text":"（三）访问限制","id":"三访问限制","depth":3,"charIndex":2321},{"text":"（四）编码规范","id":"四编码规范","depth":3,"charIndex":2445},{"text":"五、模块","id":"五模块","depth":2,"charIndex":2568},{"text":"（一）引入模块","id":"一引入模块","depth":3,"charIndex":2576},{"text":"（二）安装三方库","id":"二安装三方库","depth":3,"charIndex":2653},{"text":"六、异常处理","id":"六异常处理","depth":2,"charIndex":2853},{"text":"（一）try语句","id":"一try语句","depth":3,"charIndex":2863},{"text":"（二）抛出异常","id":"二抛出异常","depth":3,"charIndex":3105},{"text":"（三）常见的异常","id":"三常见的异常","depth":3,"charIndex":3147},{"text":"七、文件读写","id":"七文件读写","depth":2,"charIndex":3691},{"text":"（一）以读的形式打开，并能写（r+）","id":"一以读的形式打开并能写r","depth":3,"charIndex":3701},{"text":"（二）以写的形式打开，并能读(w+)","id":"二以写的形式打开并能读w","depth":3,"charIndex":3755},{"text":"（三）追加模式（a+）","id":"三追加模式a","depth":3,"charIndex":3814}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":80,"title":"Python最强代码检查&格式化工具Ruff","content":"#\n\n\n概述#\n\nRust 正在重构一切，已经杀到 Python 了。\n\nRuff 是基于 Rust 编写的 Python 代码检查&格式化工具，就一个特点，快。\n\n有多快，来看看数据：\n\n\n\n过去 Python 的项目通常使用 Pylint 进行代码检查，然后使用 Black 进行代码格式化。\n\n正所谓人生苦短，现在有了 Ruff 这一个工具就够了。\n\n\n安装#\n\n\n\n\n代码检查#\n\n代码检查是扫描代码中存在的问题。\n\n\n\n表示扫描当前目录下所有的代码，当然你可以指定一个具体的目录或文件。\n\n\n\n在扫描日志最后可以看到一个 fixable，意思是可以通过 --fix 参数直接给你修复掉。\n\n\n\n对比下文件前后：\n\n\n\n你看，直接修复了对吧。\n\n\n代码格式化#\n\n经过前面代码检查并修复之后，说明我们代码中没有“问题”了，接下来就可以进行代码格式化。\n\n\n\n\n\n效果很不错对吧。\n\n格式化这块 Ruff 官方表示是可以直接替代 Black 的。\n\n\n配置#\n\n前面代码检查的时候报了一个问题，是说在 __init__.py 文件里面写了一个导入，但没有被使用。\n\n但是这是我特意这样写的，是一种名称空间的设计，可以在 setting 名称空间下直接导入，不需要 Ruff 处理这个问题，这也不是个问题。\n\n因此，我们需要对 Ruff 进行配置。\n\n在根目录下创建一个 ruff.toml 的文件：\n\n\n\n在上面配置文件中 ignore = [] 写入错误代码：\n\n\n\n再次扫描就不会再报之前的问题。\n\n其他的一些配置也可以根据自己的一些需要进行配置。","routePath":"/编程基础/Python/Python最强静态代码检查&格式化工具Ruff","lang":"","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"安装","id":"安装","depth":2,"charIndex":179},{"text":"代码检查","id":"代码检查","depth":2,"charIndex":187},{"text":"代码格式化","id":"代码格式化","depth":2,"charIndex":327},{"text":"配置","id":"配置","depth":2,"charIndex":428}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":81,"title":"Python环境与依赖管理","content":"#\n\nPython有一大特点，即具有强大的标准库和第三方库。在开发过程中可能会用到第三方库，那么就需要对其进行安装和管理。基于一定的工具链，Python也能写出优雅标\n准的项目代码，将依赖管理玩的明明白白。\n\n\npip#\n\npip 是 Python 标准库的一个包，从 Python3.4 开始 pip 已经内置在 Python 中。Python\n有成千上万的宝藏库，它们被放置在一个统一的仓库 pypi。pip 在这个仓库中充当着管理员的角色，可以将需要的库从 Pypi 取出来，安装并管理这些库。\n\n由于大多数的第三方库都发布在\npypi，所以通过pip就可以安装95%以上的第三方库，体量在包安装这方面是大哥级别。pip还有一大优势就是在安装库的同时会把库所需要的依赖也一并进行安装。综上\n所述，在单一的项目环境中推荐使用它，简单便捷。\n\n如果有两个及以上的项目环境就不建议去使用pip，会出现环境冲突且难以管理。如果一定要使用那么就需要搭配上环境管理工具。\n\n\n安装#\n\n如果 Python 环境没有 pip 工具可以通过以下两种方法进行安装。\n\n\n\n还有种方法：\n\n在 https://pypi.org/project/pip/#files 中下载pip安装文件，然后解压到 python scripts 目录中，执行\npython setup.py install 命令安装即可；\n\n许多人抱怨 pip 命令安装 Python 库很慢或者是安装过程中失败，其实是 pip 源的问题，将其更换为我们国内源即可；\n\n1.临时设定：\n\n\n\n2.设置为默认：\n\n\n\n设为默认后，以后安装库都是从清华源下载，而且无需再加镜像源网址。\n\n\n快速配置环境#\n\n通过 pip list 命令可以预览当前环境下的依赖包：\n\n\n\n通过 pip install package_name 命令安装 Python 包： 以 requests 包举例说明：\n\n\n\n还可以通过pip install requests==<版本号>来指定包的版本号进行安装：\n\n\n\n如果我们想将安装好的这些包及依赖信息全部记录下来，就可以通过pip freeze命令将信息记 在requirements.txt中。\n\n\n\n当我们需要在一个新的python环境中引入当前的依赖时使用以下命令即可。\n\n\n\n还可以通过 pipreqs 进行导包操作：\n\n\n\n如果环境中存在 requirements.txt 文件，需要使用以下命令导出 requirements.txt 文件：\n\n\n\n注意可能在使用时会发现：\n\n\n\n报错了怎么办？\n\n不要慌张，其实这是因为此环境下版本不可用，换个版本就好啦！\n\n\n\n\n明确环境依赖#\n\npip list 和 pip freeze 打印出来的依赖都有一个问题，那就是无法明确依赖关系。\n\n当我们想清理某一个包时，不知道哪个是直接依赖哪个是间接依赖。导致环境清理不干净或者清理了不该清除的依赖。\n\n这时就可以使用 pipdeptree 来管理依赖树：\n\n\n\n这样我们就清楚的知道依赖直接的关系，在依赖清理时就可以避免出现问题。\n\n\n环境依赖治理#\n\n如果说我们想卸载 requests 包，直接使用 pip uninstall requests 命令你会发现怎么卸不干净？\n\n\n\n那么推荐一个工具 pip-autoremove 来做这件事情，下面用这个工具来试试：\n\n\n\n你会发现非常好用哈，它会检索到 requests包 和它的相关依赖，然后全部卸载，可以说是非常干净！\n\n\n常见问题#\n\npip install 与 python install 区别\n\n以 requests 为例：\n\n * 当我们用 pip install requests 安装 requests 模块，则会把 requests\n   依赖的其他库都安装上，不需要在去费力安装依赖的库了。\n\n * 当我们使用 pip setup.py install 安装 requests 模块，需要去手动安装第三方依赖，否则在 import requests\n   时会出现报错。\n\n\nconda#\n\nconda是一个支持多语言的包、依赖和环境管理工具，它不仅能管理包，还可以隔离和管理不同Python版本的环境，类似于管理node.js环境的nvm工具。\n\nconda官方一共有两个发行版anaconda和miniconda，anaconda相比miniconda体积更大，预装了许多科学计算的库，很多东西未必会用的到\n，所以建议使用miniconda。\n\n对于跨语言的或者是本身就整合了各种依赖的环境(比如tenserflow)，再考虑使用conda。\n\n\n安装miniconda#\n\n1.首先下载miniconda的安装脚本\n\n\n\n2.执行安装脚本\n\n3.一直回车等到出现如下提示并输入yes回车\n\n\n\n4.指定安装路径\n\n\n\n5.初始化conda\n\n\n\n通过简单的操作就可以安装成功了，当打开终端提示符前出现(base)说明进入了默认虚拟环境。\n\n\n取消激活base环境#\n\n当miniconda安装完成之后，每次打开终端都会激活其默认的base环境，我们可以通过以下命令禁止激活默认base环境。\n\n\n\n\n安装/卸载Python包#\n\n当我们想在conda中安装包，可以选择用conda install或者pip\ninstall，两者基本相同，但是pip是通过pypi仓库拉取的数据，而conda是通过anaconda.org上拉取的数据。所以说pip的包更全。\n\n以requests为例：\n\n\n\n\n依赖管理#\n\nconda 也有和pip freeze类似的依赖管理方式：\n\n为当前环境创建配置文件：\n\n\n\n根据配置文件复现当前环境：\n\n\n\n\n环境操作#\n\n首先创建一个环境，并激活该环境：\n\n\n\n需要注意的是，创建环境之后，一定要 activate 该环境，否则后续的 install 操作还是在 base 环境。 查看已有环境列表：\n\n\n\n查看当前环境下的依赖：\n\n\n\n退出环境：\n\n\n\n\n切换环境技巧#\n\n当我们切换环境时，会使用conda activate命令，如果我们想只输入uos可不可以激活环境呢？\n\n当然可以，操作如下：\n\n\n\n\n常用命令#\n\n环境相关：\n\n\n\n日常相关：\n\n\n\n\n#\n\n\npdm#\n\npdm是一个新的Python包管理器，于2021年发布1.0版本，目前最新版为2.7。值得一提的是这款工具的开发者是中国人。为什么选择pdm呢？首先它不是传统的\n包管理器(pipenv,poetry)需要基于虚拟环境，pdm得益于2018年的一个PEP提案（PEP582，Python local packages\ndirectory），完全摒弃了虚拟环境。\n\nPDM 包含如下特性：\n\n1.PEP 582 本地项目库目录，支持安装与运行命令，完全不需要虚拟环境。\n\n2.一个简单且相对快速的依赖解析器，特别是对于大的二进制包发布。\n\n3.兼容 PEP 517 的构建后端，用于构建发布包(源码格式与 wheel 格式)\n\n4.拥有灵活且强大的插件系统（有插件系统直接就拉开一个档次）\n\n5.PEP 621 元数据格式\n\n6.像 pnpm 一样的中心化安装缓存，节省磁盘空间\n\n\n安装#\n\npdm的安装方式有很多种，比如pip、pipx、homebrew等。这里推荐一款安装命令行安装工具，pipx 是安装并运行 Python\n终端用户应用（end-user applications）的工具。终端用户应用，其实可以理解为用 Python 编写的命令行工具，可以直接从命令行调用的那种。\n\n\n\npipx 需要 Python 3.6 及以上版本，同时必须已经安装好了 pip。\n\n\n\n如果提示虚拟环境没有被创建需要安装venv，可以通过命令进行安装。\n\n\n\n安装完成之后再通过pipx命令进行安装pdm。\n\n\n\n\n初始化pdm#\n\n执行 pdm init 就会开始初始化，初始化的时候，会让你选择项目的一些信息\n\n\n\n完成之后，PDM 会将你的选择以 toml 格式写入 pyproject.toml 配置文件中。\n\n\n\n\n包操作#\n\n安装包和 Poetry 一样，安装使用的是 add 命令\n\n\n\n查看包\n\n\n\npdm list 还有两个选项： –freeze：以 requirements.txt 的格式列出已安装的包\n\n–json：以 json 的格式列出已安装的包，但必须与 --graph 同时使用\n\n要查看某个包的某体详情，直接用 pdm show some_package即可\n\n\n\n删除包\n\n\n\n更新包\n\n\n\n\n项目配置#\n\n\n\npdm config\n里面有非常多的配置，想要一一搞清楚的可以去官网查阅：https://pdm.fming.dev/latest/reference/configuration/\n\n\n运行命令#\n\n想要在 pdm 的环境中执行命令或者项目，可以使用 run 命令，若是执行项目时，有诸多参数，可以在 pyproject.toml 配置命令别名。\n\n\n\n\n命令别名#\n\n在 pyproject.toml 添加 [tool.pdm.scripts]可以设置快捷命令别名，若项目的执行有非常多的参数，这种设定别名的方法将很有用 。\n\n\n\n[tool.pdm.scripts]有两种形式：\n\n\n\n\n切换 Python 版本#\n\n当你在初始化 pdm 项目时，就已经选定了当前的 Python 版本和可用的 Python 版本范围，后面如果想更改，可以使用 use\n命令，但版本要受之前设定的版本范围约束。假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。\n\n\n\n假设允许范围是 python 3.9+，当前使用的是 python 3.10，可以直接切换过去。\n\n\n兼容环境#\n\npdm 足够好用，也足够开放，如果你当前使用的是其他的包管理器，比如 pipenv ，poetry，或者还在用最原始的 requirements.txt\n，你也可以很方便的迁移到 pdm 中来：\n\n1.使用 pdm import -f {file} 无需初始化，直接转换\n\n2.执行 pdm init 或者 pdm install 的时候，会自动识别你当前的依赖情况并转换\n\n同样的，你也可以当 pdm 管理的项目，导出为其他方案pyproject.toml 和 pdm.lock是 pdm 的两个核心文件。pdm\n做为一个后起之秀，也没有忘本，它支持：\n\n将 pyproject.toml 转成 setup.py\n\n\n\n将 pdm.lock 转成 requirements.txt\n\n\n\n\nvenv#\n\nvenv是Python中自带的一个专门用于管理虚拟环境的模块。\n\n\n创建虚拟环境#\n\n\n\n可以说是非常的快，两三秒就创建成功了！ 创建完成之后在环境目录下，可以看到一个pyvenv.cfg的文件，它记录着虚拟环境的基本信息，包括你使用的 Python\n的家目录，还有当前虚拟环境的 Python 版本，是否开启使用系统的 site-packages\n模块，如果开启了，那么当你就可以直接使用系统中已经装过的第三方模块，但是你在虚拟环境下装的模块就不能被其他地方的程序使用。\n\n\n\n如果你的系统里有多个Python3环境，那么在创建时指明清楚版本号就可以了。\n\n\n\n\n进入虚拟环境#\n\n首先我们进入到创建好的虚拟环境目录，通过source进入虚拟环境：\n\n\n\n\n退出虚拟环境#\n\n\n\n\n总结#\n\nvenv是 Python3 中自带的虚拟环境管理工具，不需要额外安装，功能简单，用法也简单。但是它不能像 poetry 和 pipenv 用于项目的管理，因此\nvenv 建议只做了解，在一些简单的场景中可以使用，如果是复杂的项目中，可以直接上 poetry 和 pipenv。\n\n\nvirtualenv#\n\n...\n\n\nvirtualenvwrapper#\n\n...\n\n\npyenv#\n\n...\n\n\npipenv#\n\n...\n\n\npoetry#","routePath":"/编程基础/Python/Python环境与依赖管理","lang":"","toc":[{"text":"pip","id":"pip","depth":2,"charIndex":105},{"text":"安装","id":"安装","depth":3,"charIndex":434},{"text":"快速配置环境","id":"快速配置环境","depth":3,"charIndex":719},{"text":"明确环境依赖","id":"明确环境依赖","depth":3,"charIndex":1130},{"text":"环境依赖治理","id":"环境依赖治理","depth":3,"charIndex":1310},{"text":"常见问题","id":"常见问题","depth":3,"charIndex":1483},{"text":"conda","id":"conda","depth":2,"charIndex":1718},{"text":"安装miniconda","id":"安装miniconda","depth":3,"charIndex":1956},{"text":"取消激活base环境","id":"取消激活base环境","depth":3,"charIndex":2104},{"text":"安装/卸载Python包","id":"安装卸载python包","depth":3,"charIndex":2183},{"text":"依赖管理","id":"依赖管理","depth":3,"charIndex":2330},{"text":"环境操作","id":"环境操作","depth":3,"charIndex":2402},{"text":"切换环境技巧","id":"切换环境技巧","depth":3,"charIndex":2527},{"text":"常用命令","id":"常用命令","depth":3,"charIndex":2603},{"text":"","id":"","depth":2,"charIndex":2629},{"text":"pdm","id":"pdm","depth":2,"charIndex":2633},{"text":"安装","id":"安装-1","depth":3,"charIndex":3029},{"text":"初始化pdm","id":"初始化pdm","depth":3,"charIndex":3295},{"text":"包操作","id":"包操作","depth":3,"charIndex":3400},{"text":"项目配置","id":"项目配置","depth":3,"charIndex":3602},{"text":"运行命令","id":"运行命令","depth":3,"charIndex":3704},{"text":"命令别名","id":"命令别名","depth":3,"charIndex":3789},{"text":"切换 Python 版本","id":"切换-python-版本","depth":3,"charIndex":3907},{"text":"兼容环境","id":"兼容环境","depth":3,"charIndex":4113},{"text":"venv","id":"venv","depth":2,"charIndex":4466},{"text":"创建虚拟环境","id":"创建虚拟环境","depth":3,"charIndex":4507},{"text":"进入虚拟环境","id":"进入虚拟环境","depth":3,"charIndex":4756},{"text":"退出虚拟环境","id":"退出虚拟环境","depth":3,"charIndex":4803},{"text":"总结","id":"总结","depth":3,"charIndex":4815},{"text":"virtualenv","id":"virtualenv","depth":2,"charIndex":4961},{"text":"virtualenvwrapper","id":"virtualenvwrapper","depth":3,"charIndex":4980},{"text":"pyenv","id":"pyenv","depth":2,"charIndex":5006},{"text":"pipenv","id":"pipenv","depth":2,"charIndex":5020},{"text":"poetry","id":"poetry","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":82,"title":"Python风格指南","content":"#\n\n\n1. 引言#\n\n\n1.1. 目的#\n\n本规范用于指导Python脚本编写人员，统一编码风格，提交代码的易读性和健壮性。\n\n本规范不能替代Pylint/ruff等静态检查工具，请在提升代码前使用Pylint/ruff进行静态检查。\n\n\n1.2. 说明#\n\n本规范中条目分为如下三个级别：\n\n【强制】必须遵守的编码规范，新增代码必须严格按照规范编写，历史代码根据项目实际情况决定是否修改。\n\n【建议】建议遵守的编码规范，根据代码所处上下文决定编码风格，但需要保持在同一项目中统一风格。\n\n【注意】编码过程中的注意事项，通常为容易出现缺陷的代码，应当用合理的编码方式进行替代。\n\n\n2. 环境#\n\n\n2.1. 版本#\n\n【强制】请使用Python 3.7 及以上版本编写代码。\n\n【强制】请使用pylint 2.6 及以上版本进行静态代码检查。\n\n\n2.2. IDE#\n\n【强制】使用PyCharm Community Edition 和 Visual Studio Code\n作为代码编码及调试工具，保持同一项目中团队成员统一IDE。\n\n\n3. Python风格规范#\n\n\n3.1. 符号#\n\n3.1.1. 分号#\n\n【强制】 不要在行尾加分号，也不要用分号将两条命令放在同一行。\n\n3.1.2. 逗号#\n\n【强制】 方法返回值中结束不能加逗号，加逗号后，返回值会自动变成元组，在使用过程中需要格外注意，用逗号的情况只有列表，元组，字典方法参数分割这一种情况。\n\n\n\n\n3.2. 空行，空格，缩进#\n\n3.2.1. 空行#\n\n【强制】\n\n1，导包部分与类，方法之间隔开两个空行。\n\n2，类和类之间隔开两个空行(内部类除外)。\n\n3，类之外的方法隔开两行空行(装饰器中钩子函数除外)。\n\n4，类中的方法和类之间隔开一个空行。\n\n5，文件结尾部分应空一行。\n\n3.2.2. 空格#\n\n1，【强制】 字典中key和冒号之间不能有空格。\n\n2，【强制】 数组，元组，字典逗号之前不能有空格。\n\n3，【强制】 等号，大于，小于符号两边必须有空格。\n\n\n\n上述代码中的空格是不规范的。\n\n3.2.3. 缩进#\n\n【强制】 用4个空格来缩进代码，绝对不要用tab，也不要tab和空格混用(部分IDE设置tab为4个空格例外)。\n\n\n3.3. 注释#\n\n【强制】 注释中尽量使用全英文，以免系统或编码不同导致乱码。\n\n1，文件注释，使用三引号。\n\n\n\n2，【强制】 方法和类描述，方法作用，参数说明，返回值说明使用三引号。\n\n\n\n3，【强制】 行注释，使用# 开头，#后有一个空格，此类注释，注释变量，逻辑描述。\n\n4，【强制】 TODO注释，# TODO开头，暂时使用代码，同时也可以用于未完成步骤描述，部分IDE有查看TODO注释，便于查看未完成部分或临时修改部分。\n\n\n\n\n3.4. 类和方法#\n\n3.4.1. 类#\n\n【强制】 python3中，如果类不继承其他类，类名后不要加括号，如存在括号需要显示的继承object，内部类和嵌套也一样。\n\n【强制】 类名字采用驼峰形式命令，并类名定义能表达该类最基本功能。\n\n\n\n【建议】多继承容易造成逻辑混乱变量类型改变，故应尽量避免多继承。\n\n3.4.2. 方法#\n\n【强制】 类内部的私有方法以_开头，单独定义的私有方法以__开头。\n\n【强制】 使用全小写字母和_隔开，命名定义能体现方法的功能，例：get_conf。\n\n\n3.5. 字符串#\n\n【强制】 在同一个文件中，保持使用字符串引号的一致性，统一使用双引号。\n\n【建议】避免在循环中用+和+=操作符来累加字符串，由于字符串是不可变的，这样做会创建不必要的临时对象，并且导致二次方而不是线性的运行时间。作为替代方案，你可以将\n每个子串加入列表，然后在循环结束后用 .join 连接列表。\n\n\n\n【强制】 Python3.6及其以上的版本尽量使用f-string的方式格式化字符串，不仅简单而且效率相比%和format也是最高的。\n\n【强制】\n多行字符串注释，使用三重双引号”””而非三重单引号’’’，多行字符串不应随着代码其他部分缩进的调整而发生位置移动。如果需要避免在字符串中嵌入额外的空间，可以使用\n串联的单行字符串或者使用 textwrap.dedent() 来删除每行多余的空间。\n\n\n\n\n3.6. 文件和sockets等其他句柄#\n\n【强制】\n使用with打开文件，不能使用with关键字的句柄，可以自定义，实现__enter__和__exit__方法，同时还可以是用contextlib.closing\n\n\n\n\n3.7. 导入#\n\n【强制】 每个 import 语句只导入一个模块，尽量避免一次导入多个模块。\n\n【强制】 导入总应该放在文件顶部，位于模块注释和文档字符串之后，模块全局变量和常量之前。导入应该按照从最通用到最不通用的顺序分组：\n\n 1. __future__导入。\n\n\n\n 2. 标准库导入，例如sys。\n\n 3. 第三方库导入。\n\n 4. 本独代码子包导入。\n\n\n3.8. 命名规范#\n\n【强制】\n\n模块名写法： module_name\n\n包名写法： package_name\n\n类名： ClassName\n\n方法名： method_name\n\n异常名： ExceptionName\n\n函数名： function_name\n\n全局常量名： GLOBAL_CONSTANT_NAME\n\n全局变量名： global_var_name\n\n实例名： instance_var_name\n\n函数参数名： function_parameter_name\n\n局部变量名： local_var_name\n\n函数名，变量名和文件名应该是描述性的，尽量避免缩写，特别要避免使用非项目人员不清楚难以理解的缩写，不要通过删除单词中的字母来进行缩写。始终使用 .py\n作为文件后缀名，不要用破折号。\n\n3.8.1. 应该避免的命名#\n\n【推荐】\n\n1，单字符名称，除了计数器和迭代器，作为 try/except 中异常声明的 e，作为 with 语句中文件句柄的 f。\n\n2，包/模块名中的连字符(-)。\n\n3，双下划线开头并结尾的名称(Python保留，例如__init__)。\n\n3.8.2. 命名的约定#\n\n【强制】用单下划线_开头表示模块变量或函数是protected的(使用from module import *时不会包含)。\n\n【强制】用双下划线(__)开头的实例变量或方法表示类内私有。\n\n3.8.3. 文件名#\n\n【强制】 所有python脚本文件都应该以 .py 为后缀名且不包含 -.若是需要一个无后缀名的可执行文件，可以使用软联接或者包含 exec \"$0.py\"\n\"$@\" 的bash脚本。\n\n\n4. Python语言规范#\n\n\n4.1. 异常#\n\n【强制】永远不要使用 except： 语句来捕获所有异常，也不要捕获 Exception 或者 StandardError\n，除非你打算重新触发该异常，或者你已经在当前线程的最外层(记得还是要打印一条错误消息). 在异常这方面，Python非常宽容， except：\n真的会捕获包括Python语法错误在内的任何错误. 使用 except： 很容易隐藏真正的bug。\n\n【推荐】模块或包应该定义自己的异常基类，这个基类继承Exception，模块的异常基类后缀应该叫做 Error。\n\n【推荐】优先合理的使用内置异常类，比如 ValueError 指示了一个程序错误，不要用 assert，用 raise 语句（手动抛出异常例外）。\n\n【推荐】尽量减少try/except块中的代码量. try块的体积越大，期望之外的异常就越容易被触发. 这种情况下，try/except块将隐藏真正的错误。\n\n【推荐】使用finally子句来执行那些无论try块中有没有异常都应该被执行的代码，这对于清理资源常常很有用，例如关闭文件。\n\n\n4.2. 推导式，生成式及其循环控制#\n\n【强制】循环的时候同时获取当前index使用enumerate。\n\n【推荐】在简单的情况下创建列表使用生成器\n\n【推荐】在字典循环的时候如果只需要value，可用_作为占位符占据key的位置。\n\n\n\n\n4.3. 默认参数值和代码类型注释#\n\n【强制】不要在函数或方法定义中使用可变对象作为默认值。\n\n\n\n\n4.4. True/False的求值#\n\n【强制】永远不要用==将一个布尔量与false相比较. 使用 if not x： 代替，如果你需要区分false和None，你应该用像 if not x and\nx is not None： 这样的语句\n\n【推荐】对于序列(字符串，列表，元组)，要注意空序列是false. 因此 if not seq： 或者 if seq： 比 if len(seq)： 或 if\nnot len(seq)： 要更好\n\n\n4.5. 特性#\n\n【推荐】 访问和设置数据成员时，建议使用特性(properties)来代替它们。\n\n\n\n\n4.6. 倒序#\n\n【推荐】可以使用[：：-1]和reversed方式进行反转。 使用reversed。\n\n\n4.7. 对象类型判断#\n\n【推荐】 可以使用isinstance和type方式，使用isinstance。\n\n\n4.8. 判断空和非空#\n\n在Python中，数字0，空字符串，空列表，空元组，空字典都为False\n\n【推荐】判断非空直接使用if，判断空直接if not\n\n\n4.9. 数据拷贝#\n\n【强制】单纯的数据拷贝，使用深拷贝，避免造成不必要的麻烦。\n\n【注意】判断两个对象是否指向同一地址，通常手段采用id()方法判断，但是在Python中有小数据对象池，Python会将一定规则的字符串和-5到256，True\n和False，None创建一份放在驻留池中，无论程序中变量指向这些值都不会创建对象，而是直接引用。\n\n\n4.10. 模块划分#\n\n【推荐】 Python或其他语言划分包或者代码归类，一般都采用按功能划分，比如：\n\n * 项目中需要很多脚本，那么就需要把这些脚本放在一个scripts的文件夹中\n\n * 公共的方法及其常量文件constant放在utils文件夹中\n\n * 模型类放在models中\n\n * 数据库处理相关放在db中\n\n * ......\n   \n   按功能划分，且文件夹名能体现下面模块的大体功能。\n\n\n4.11. 配置#\n\n【推荐】 可变资源，都应该采用配置的方法进行处理，如数据库用户名，密码，地址等。\n\n\n4.12. 日志#\n\n【推荐】\n日志的目的是便于查看程序运行各类信息，日志等级分四个等级，不同的逻辑配合不同的日志等级记录相关日志，比如接口地方，打印info等级的日志，异常和错误信息打印er\nror日志，且配置日志颜色便于查看，同时必须设置日志存档的时间，不然日志累计导致磁盘空间不够的问题。","routePath":"/编程基础/Python/Python风格指南","lang":"","toc":[{"text":"**1.** **引言**","id":"1-引言","depth":2,"charIndex":-1},{"text":"**1.1.** **目的**","id":"11-目的","depth":3,"charIndex":-1},{"text":"**1.2.** **说明**","id":"12-说明","depth":3,"charIndex":-1},{"text":"2. **环境**","id":"2-环境","depth":2,"charIndex":-1},{"text":"2.1. **版本**","id":"21-版本","depth":3,"charIndex":-1},{"text":"2.2. **IDE**","id":"22-ide","depth":3,"charIndex":-1},{"text":"3. **Python风格规范**","id":"3-python风格规范","depth":2,"charIndex":-1},{"text":"3.1. **符号**","id":"31-符号","depth":3,"charIndex":-1},{"text":"3.1.1. **分号**","id":"311-分号","depth":4,"charIndex":-1},{"text":"3.1.2. **逗号**","id":"312-逗号","depth":4,"charIndex":-1},{"text":"3.2. **空行，空格，缩进**","id":"32-空行空格缩进","depth":3,"charIndex":-1},{"text":"3.2.1. **空行**","id":"321-空行","depth":4,"charIndex":-1},{"text":"3.2.2. **空格**","id":"322-空格","depth":4,"charIndex":-1},{"text":"3.2.3. **缩进**","id":"323-缩进","depth":4,"charIndex":-1},{"text":"3.3. **注释**","id":"33-注释","depth":3,"charIndex":-1},{"text":"3.4. **类和方法**","id":"34-类和方法","depth":3,"charIndex":-1},{"text":"3.4.1. **类**","id":"341-类","depth":4,"charIndex":-1},{"text":"3.4.2. **方法**","id":"342-方法","depth":4,"charIndex":-1},{"text":"3.5. **字符串**","id":"35-字符串","depth":3,"charIndex":-1},{"text":"3.6. **文件和sockets等其他句柄**","id":"36-文件和sockets等其他句柄","depth":3,"charIndex":-1},{"text":"3.7. **导入**","id":"37-导入","depth":3,"charIndex":-1},{"text":"3.8. **命名规范**","id":"38-命名规范","depth":3,"charIndex":-1},{"text":"3.8.1. **应该避免的命名**","id":"381-应该避免的命名","depth":4,"charIndex":-1},{"text":"3.8.2. **命名的约定**","id":"382-命名的约定","depth":4,"charIndex":-1},{"text":"3.8.3. **文件名**","id":"383-文件名","depth":4,"charIndex":-1},{"text":"4. **Python语言规范**","id":"4-python语言规范","depth":2,"charIndex":-1},{"text":"4.1. **异常**","id":"41-异常","depth":3,"charIndex":-1},{"text":"4.2. **推导式，生成式及其循环控制**","id":"42-推导式生成式及其循环控制","depth":3,"charIndex":-1},{"text":"4.3. **默认参数值和代码类型注释**","id":"43-默认参数值和代码类型注释","depth":3,"charIndex":-1},{"text":"4.4. **True/False的求值**","id":"44-truefalse的求值","depth":3,"charIndex":-1},{"text":"4.5. **特性**","id":"45-特性","depth":3,"charIndex":-1},{"text":"4.6. **倒序**","id":"46-倒序","depth":3,"charIndex":-1},{"text":"4.7. **对象类型判断**","id":"47-对象类型判断","depth":3,"charIndex":-1},{"text":"4.8. **判断空和非空**","id":"48-判断空和非空","depth":3,"charIndex":-1},{"text":"4.9. **数据拷贝**","id":"49-数据拷贝","depth":3,"charIndex":-1},{"text":"4.10. **模块划分**","id":"410-模块划分","depth":3,"charIndex":-1},{"text":"4.11. **配置**","id":"411-配置","depth":3,"charIndex":-1},{"text":"4.12. **日志**","id":"412-日志","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"Author":"海针 - 搬运 Google开源项目风格指南之《Python风格指南》"},"version":""},{"id":83,"title":"常用的获取随机字符串的方法","content":"#\n\n\nbase64#\n\nbase64 不是算法而是一种编码方式，是可以被解码的，有时候在代码中我们用它来编码后处理业务效果很好；\n\n\n\n\nhash#\n\nhash 是一种算法，不同的算法复杂度不一样，常用的 MD5算法；\n\n\n\n还可以增加点复杂度，给 md5() 里面传入一个字符串：\n\n\n\n\nsecrets#\n\nsecrets 用于生成高度加密的随机数，在后端处理Token问题时经常使用；\n\n过去咱们习惯使用 random 模块来生成一些随机字符，最新最流行的是用 secrets；\n\n","routePath":"/编程基础/Python/常用的获取随机字符串的方法","lang":"","toc":[{"text":"base64","id":"base64","depth":2,"charIndex":3},{"text":"hash","id":"hash","depth":2,"charIndex":69},{"text":"secrets","id":"secrets","depth":2,"charIndex":146}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":84,"title":"配置 Python 源的几种方法","content":"#\n\n\n（1）临时添加三方源#\n\n\n\n如果不小心添加了多个，就像这样：\n\n\n\n只有最后一个 -i 指定的三方源生效；\n\n\n（2）requirements.txt 临时添加三方源#\n\n\n\n\n（3）命令行永久配置#\n\n * 适用于 pip3 install 的安装方式（普通用户）：\n\n\n\n * 适用于 sudo pip3 install 的安装方式（root用户）：\n\n\n\n可以再次执行再添加一个:\n\n\n\n注意 global.extra-index-url 里面和上面不同；\n\n\n（4）修改配置文件永久配置#\n\n * 适用于 pip3 install 的安装方式（普通用户）：\n\n\n\n配置如下：\n\n\n\n * 适用于 sudo pip3 install 的安装方式（root用户）：\n\n\n\n配置如下：\n\n\n\n * 全局配置\n\n\n\n配置如下：\n\n\n\n\n（5）作用域#\n\n * 临时添加的方式，只在本次操作有效（不区分普通用户、root用户、全局配置）；\n\n * 普通用户的配置方式，只在普通用户权限下生效，就是只有使用 pip3 install 生效；\n\n * root用户的配置方式，只在root用户权限下生效，就是只有使用 sudo pip3 install 生效；\n\n * 全局配置方式，所有情况下均生效；\n\n\n（6）常用的几个三方源#\n\n\n\n--------------------------------------------------------------------------------\n\n补充小知识，pip 下载安装超时设置：\n\n\n\n--------------------------------------------------------------------------------\n\n吐槽一下阿里的镜像，更新相当不及时，我个人不建议使用哈。","routePath":"/编程基础/Python/配置Python源的几种方法","lang":"","toc":[{"text":"（1）临时添加三方源","id":"1临时添加三方源","depth":2,"charIndex":3},{"text":"（2）requirements.txt 临时添加三方源","id":"2requirementstxt-临时添加三方源","depth":2,"charIndex":60},{"text":"（3）命令行永久配置","id":"3命令行永久配置","depth":2,"charIndex":93},{"text":"（4）修改配置文件永久配置","id":"4修改配置文件永久配置","depth":2,"charIndex":238},{"text":"（5）作用域","id":"5作用域","depth":2,"charIndex":372},{"text":"（6）常用的几个三方源","id":"6常用的几个三方源","depth":2,"charIndex":555}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":85,"title":"Shell参数传递","content":"#\n\n\n1. Shell参数#\n\n参数常用在脚本，函数，命令工具调用时传入和传出。\n\n\n1.1 常用位置参数#\n\n函数或者命令接收参数时，按照位置获取参数。\n\n工具/表达式   案例说明\n$0       代表命令或者脚本本身，如常用basename $0 输出脚本名称本身。\n$1~$n    第1个到第n个参数,从第10参数开始，引用时要加{}，如${10}\n$#       传入的参数个数\n$*       传入的全部参数\n$@       传入的全部参数\n\n\n1.2 $@和$*的使用区别#\n\n多个参数传递使用空格分隔，二者在没有使用双引号的情况下传递效果是一致的，所有参数依次解析；\n当带有双引号时，$*中所有的参数连同空格会被当成一个字符串参数传递，而$@仍然会被空格分隔成多个参数（如果某个参数本身带有空格不会分隔成两个参数）。 如下：\n\ntest@test-PC:~/work/study/shell/share$ vi param.sh\n\n\n\n执行结果如下：\n\n\n\n\n1.3 参数的位移#\n\n使用shift改变参数位置，参数从$1开始，shift每提取一个参数，后续的参数列表向左移一个参数位，即原来的$2变成了$1,原来的$1丢弃。\nshfit每次只需要提取$1，以此类推，直到所有参数提取完毕。常用于不关心参数个数，依次处理参数时用shift。\n\ntest@test-PC:~/work/study/shell/share$ shift_test.sh\n\n\n\n执行结果如下：\n\n\n\n\n1.4 参数传入和传出#\n\n1.4.1 自定义函数参数的传入和传出#\n\ntest@test-PC:~/work/study/shell/share$ vi deffunc.sh\n\n\n\n如上：\nin_value为入参数，也是第一个参数。实际上in_value作为变量，在定义变量的位置开始一直到Shell脚本执行结束，变量都是生效的。所以即使不传递，在p\nararm_test也是可以使用的。这不在本节讨论范围，实际也不推荐这样做。这里仍然作为参数传递；\nout_value为出参数，也是第二个参数，从同赋值的位置开始，到Shell脚本结束，变量都是生效的。 执行结果如下：\n\n\n\n有时我们也可以利用函数的返回值当做出参数， 但这是有局限性的，函数的返回值只能为正整型，否则会报错，且数值在0～255区间内，超出范围会反转。\ntest@test-PC:~/work/study/shell/share$ vi retfunc.sh\n\n\n\n执行结果输出\n\n\n\n如上，return的返回值为128，在0~255区间内，现在我们把它改为256。 执行结果输出：\n\n\n\n改成-1，执行结果如下：\n\n\n\n改成A，执行结果如下：\n\n\n\n综上，函数返回值超出0~255会反转，非数字则报错。一般情况下我们是利用函数的返回码来做函数执行状态判断的。我们可以定义0为成功，非0则失败，根据不同的数字值可\n以设定不同的错误状态。\n\n1.4.2 数组做为参数进行传递#\n\n数组也可以作为参数进行传递，这涉及到如何数组的取值， 如下, $WEEK仅取值数组中第一个 元素，\n而${WEEK[@]}或者${WEEK[*]}才是取整个数组的值，所以我们做为参数传递时要传递整个数组。\n\ntest@test-PC:~/work/study/shell/share$ vi arr_param.sh\n\n\n\n注意:${WEEK[@]}和${WEEK[*]}有什么区别呢？参考章节 \"1.2 $@和$*的使用区别\"。\n\n1.4.3 函数名做为参数传递#\n\n函数名也可以做为参数进行传递，使用时用 eval 进行二次解析。 eval 的作用是先将命令中的变量进行一次解析，然后再执行命令。\n\ntest@test-PC:~/work/study/shell/share$ vi func_param.sh\n\n\n\n如上，我们定义了三个函数max,min,abs分别求传入数字最大，最小和绝对值，我们可以将它们的名称作为参数传递给func_param。\n\n\n2. getopts和getopt#\n\n\n2.1 getopts 命令#\n\ngetopts是Bash内置命令，用于格式化参数解析。在开发脚本或者小工具时（需要通过传入参数执行特定功能）时，可以按照给定格式传递与解析参数\n\n命令的关键点，以getopts 'l:t:p:d' 为例说明\n\n * 1. getopts后面的参数约定了getopts所在函数或脚本的接收参数内容及格式， 如支持参数为 -l, -t, 参数只能为单个字符,\n      不支持长参数名，比如--lang.\n * 2. getopts 定义的参数后带:，表示参数为键值参数，需要给参数传入一个值； 如不带:说明是一个开关参数，默认开关是true。\n * 3. 常量OTPARG记录当前参数的值， OPTIND记录下一参数位置。\n * 4. 当出现了不在约定的参数列表中的参数时，进入 ? 分支。\n * 5. 当前getopts后面的参数列表以:开始时， getopts进入安静模式，不打印内置的错误描述。\n\n\n2.2 getopt#\n\ngetopt是一个外部工具，可以通过man getopt查看具体用法。","routePath":"/编程基础/Shell/Shell参数传递","lang":"","toc":[{"text":"1. Shell参数","id":"1-shell参数","depth":2,"charIndex":3},{"text":"1.1 常用位置参数","id":"11-常用位置参数","depth":3,"charIndex":43},{"text":"1.2 `$@`和`$*`的使用区别","id":"12-和的使用区别","depth":3,"charIndex":-1},{"text":"1.3 参数的位移","id":"13-参数的位移","depth":3,"charIndex":443},{"text":"1.4 参数传入和传出","id":"14-参数传入和传出","depth":3,"charIndex":653},{"text":"1.4.1 自定义函数参数的传入和传出","id":"141-自定义函数参数的传入和传出","depth":4,"charIndex":667},{"text":"1.4.2 数组做为参数进行传递","id":"142-数组做为参数进行传递","depth":4,"charIndex":1258},{"text":"1.4.3 函数名做为参数传递","id":"143-函数名做为参数传递","depth":4,"charIndex":1494},{"text":"2. getopts和getopt","id":"2-getopts和getopt","depth":2,"charIndex":1709},{"text":"2.1 getopts 命令","id":"21-getopts-命令","depth":3,"charIndex":1730},{"text":"2.2 getopt","id":"22-getopt","depth":3,"charIndex":2150}],"domain":"","frontmatter":{"Author":"海针 - 搬运"},"version":""},{"id":86,"title":"Shell变量使用","content":"#\n\n\n1. 变量的声明#\n\n在Shell脚本内，变量是可以不先声明而直接使用的。有过传统语言编程经验的小伙伴习惯先声明再使用，这是个好的编程习惯。\n\n\n1.1 常用内置变量#\n\n函数或者命令接收参数时，按照位置获取参数。\n\n工具/表达式          案例说明\n$0              代表命令或者脚本本身，如常用basename $0 输出脚本名称本身。\n$1~$n           第1个到第n个参数,从第10参数开始，引用时要加{}，如${10}\n$#              传入的参数个数\n$*              传入的全部参数\n$@              传入的全部参数\n$$              当前运行的进程ID\n$!              最后一个后台进程的ID\n$?              最后一个执行命令的返回码\n$_              最后执行的命令的最后一个参数的值\n$PPID           shell 的父进程的进程号\n$BASH           扩展为用来启动当前 bash 实例的文件全名\n$BASH_VERSION   一个只读数组变量，成员保存着当前 bash 实例的版本信息。赋予数组元素的值是如下这些：\n                BASH_VERSINFO[0] 主版本号 (release).BASH_VERSINFO[1] 次版本号\n                (version). BASH_VERSINFO[2] 补丁版本BASH_VERSINFO[3]\n                编译信息BASH_VERSINFO[4] 发布时的状态 (例如, beta1).BASH_VERSINFO[5]\n                MACHTYPE 平台类型\n$UID            UID 扩展为当前用户的 ID，在启动时初始化。\n$GROUPS         一个数组变量，包含当前用户所属的组的列表\n$HOME           前用户的个人家目录，内建命令 cd 的默认参数\n$HOSTNAME       自动设置为当前的主机名。\n$IFS            内部字段分隔符 Internal Field Separator 用来在扩展之后进行分词\n$PATH           索命令的路径\n$PWD            由 cd 命令设置的当前工作目录。\n$OLDPWD         上一次命令 cd 设置的工作目录。\n$LINENO         引用这个参数时，shell 将它替换为一个指示在脚本或函数中当前行号的十进制数字(从 1 开始)\n$FUNCNAME       前执行的 shell 函数名。\n$OSTYPE         正在运行 bash 的操作系统类型。\n$MACHTYPE       正在运行 bash 的硬件系统类型\n$RANDOM         引用这个参数时，都会产生一个 0 到 32767 之间的随机整数\n$SECONDS        引用这个参数时，返回 shell 自运行以来的秒数\n$TMOUT          如果设置为大于 0 的值，TMOUT 被当作内建命令 read 的默认超时 等待时间。可以用来设置终端无操作的超时时间\n$HISTSIZE       令历史中保存的历史数量,默认值是 500。\n$PS1            用作主提示符字符串\n$PS2            个参数的值同 PS1 一起被扩展，用作次提示符字符串。\n$PS4            这个参数的值同 PS1 一起被扩展，在执行跟踪中在 bash 显示每个命令之前显示\n\n更多内置变量详情，可查看man bash\n\n\n1.2 变量的声明#\n\n1.2.1 变量的声明与赋值#\n\ntest@test-PC:~/work/study/shell/share/1$ vi var.sh\n\n\n\n脚本执行结果如下：\n\n\n\n注意以下几点：\n\n * 变量名由数字、字母、下划线组成，并且必须以数字，字母开头，不能包含Shell关键字。\n * 变量名称与值之间用=连接，=两点不能有空格。在$((...)),$[...] 表达式内除外。\n * Bash变量可以不用指定类型，默认都是字符串。\n * 变量赋值使用单引确保引号内的字符串不被转义，不被解析，保持原本输出。 而使用双引号，引号内字符串包含变量，命令，转义符将先会被解析后再赋值给变量。\n\n1.2.2 删除变量#\n\n\n\n1.2.3 readonly只读变量#\n\n用readonly声明的变量是只读的，不能修改。\n\n\n\n执行修改：\n\n\n\n注意 readonly和local不能同时使用，如果同时使用，则在最前面的生效，后面的则失效，具体原理尚未深究。\n\n如 readonly loacl var=123 : readonly生效，local失效。\n\n如 local readonly var=123 ：local生效，readonly失效。\n\n1.2.4 declare声明变量#\n\n * declare -i : 声明整型变量\n\n\n\n * declare -r: 声明只读变量\n\n\n\n * declare -a: 声明数组变量\n\n\n\n * declare -f: 声明函数 在函数定义之前可以先声明\n\n\n\n * declare -x: 声明环境变量\n\n声明变量为环境变量，可在当前Shell进程及其子进程中使用。\n\ntest@test-PC:~/share/1$ vi declare.sh\n\n\n\n子进程脚本如下： test@test-PC:~/share/1$ vi declare_test.sh\n\n\n\n调用主脚本，执行结果如下,在子脚本中打印出了环境变量的值。\n\n\n\n如果单独调用子脚本，这个变量是没有赋值的。\n\n\n\n注意： 实际测试，如果declare声明的变量是在函数体内，则变量的作用域也仅是函数体内有效。具体原理尚未深究。\n\n\n2 变量的应用#\n\n\n2.1 变量的作用域#\n\n2.1.1 全局变量#\n\n全局变量的作用域是从变量定义位置开始，到Shell进程结束，全局变量的作用域不包含当前进程的子进程。\n\n全局变量的声明： VariableName=Value 如var=\"abc\"或者global var=\"abc\"，以下示例来演示全局变量的作用域。\n\ntest@test-PC:~/share/1$ vi global.sh\n\n\n\n在以下脚本中调用的两个脚本分别定义如下： test@test-PC:~/share/1$ vi source.sh\n\n\n\ntest@test-PC:~/share/1$ vi extern.sh\n\n\n\n执行主脚本global.sh，结果如下：\n\n\n\n说明：\n\n * 1）<global.sh:func1:4>函数位置，main_var尚未定义，所以值为空。\n\n * 2）<global.sh:func2:9>函数位置，main_var已定义，打印值有效。\n\n * 3）<global.sh:main:15>在main在func2后执行，main_var已定义，值有效。\n\n * 4）<global.sh:main:17>变量source_var在source.sh定义，并且以source的方式导入，还在当前进程中，所以变量sour\n   ce_var有效。 以都是在同一进程内运行，进程ID:28581。\n\n * 5）<extern.sh:print_var:4>，当前是在新进程中运行，进程ID:28286。它打印主进程main_var是无效的，因为已经不在变量的作\n   用域内。\n\n * 6）<global.sh:main:20> 同理，extern_var是在子进程extern.sh中定义，也已经超出了变量的作用域，打印无效。\n\n2.1.2 局部变量#\n\n局部变量的作用域是在函数体内定义的位置开始，到函数执行完毕。\n\n局部变量的定义，使用local来定义局部变量，local只能在函数中使用。\n\nlocal VariableName=Value，如local var=123。如下示例演示局部变量的作用域。\n\ntest@test-PC:~/share/1$ vi local.sh\n\n\n\n调用执行结果如下：\n\n\n\n可以看到，local_var变量只是在函数func 是有效的，函数外打印无效。\n\n2.1.3 环境变量#\n\n环境变量对当前Shell进程及其子进程都是生效的，但不对当前Shell的父进程生效，不同Shell进程也是不生效的。\n\n假如脚本间有如下调用关系：\n\n\n\n在脚本B.sh定义了环境变量，那么变量在B.sh和C.sh是生效的，但是对于调用它的A.sh是不生效的，\n而Z.sh独立进程调用，所以B.sh中定义的环境变量在Z.sh也是无效的。\n\n环境变量的声明： export VARIABLENAME=Value，如local PROJECT_NAME=menu。\n\n也可以\n\ndeclare -x VARIABLENAME=Value,如declare PROJECT_NAME=menu。\n\n一般我们习惯用大写字母表示环境变量，以下示例演示环境变量的作用域:\n\ntest@test-PC:~/share/1$ vi export.sh\n\n\n\ntest@test-PC:~/share/1$ vi extern.sh\n\n\n\ntest@test-PC:~/share/1$ vi subextern.sh\n\n\n\n调用主父进程脚本，执行结果如下：\n\n\n\n分析：\n\n * 1） 输出第一行：子进程extern.sh打印出了父进程中定义的MAIN_ENV值。\n\n * 2） 输出第二行：孙进程subextern.sh打印出了爷爷进程的环境变量MAIN_ENV。\n\n * 3） 输出第三行:孙进程subextern.sh打印出了父进程的环境变量EXTERN_ENV。\n\n * 4）输出第四行：主父进程export.sh尝试打印子进程extern.sh的环境变量EXTERN_ENV不成功，已经超出了环境变量的作用域范围。\n\n然后再编写一个独立调用的脚本，它与前三个脚本是不相关，不过是在同一Shell终端下执行。 test@test-PC:~/share/1$ vi third.sh\n\n\n\n调用执行结果如下：\n\n\n\n因为与前面脚本export.sh与相互独立的，无法共享环境变量。\n\n但是，它们都是在同一Shell终端下运行，也就是它有共同的父进程，所以如果需要共享环境变量，只需要在当前Shell终端下设置一个环境变量就可以了， 如：\n\ntest@test-PC:~/share/1$ export EXPORT_TEST=\"export_test\"\n\n然后在export.sh和third.sh脚本入口添加打印代码：\n\necho EXPORT_TEST=$EXPORT_TEST\n\n执行两个脚本，结果如下：\n\n\n\n可以看到，打印出了共享的环境变量。也可以查看当前Shell终端的环境变量，已经包含了EXPORT_TEST。\n\n\n\n但是，这也仅对当前登录的Shell终端生效，但关掉终端重新打开又是一个新的Shell终端，要想永久生效，可以写入环境变量配置文件，如~/.bashrc或~/.b\nash_profile等 。Shell终端在登录的时候会自动加载共同的环境变量配置文件，保持在整个终端持续期间生效。\n\n\n2.2 变量替换#\n\n表达式            案例说明\n${var:-word}   如果变量var已经设置且非空，结果为var的值，否则结果为word\n${var:=word}   如果变量var已经设置且非空，结果为var的值，否则设置var为word\n${var:+word}   如果变量var已经设置且非空，则设置var的值为word;否则不替换\n${var:?word}   如果变量var已经设置且非空，则替换为word，否则退出shell。\n\n\n2.3 变量嵌套#\n\n变量嵌套一般是变量名中仍然包含变量，需要做二次解析，最终求出变量的结果。\n\n2.3.1 eval#\n\neval命令将会首先扫描命令行进行所有的替换，然后再执行命令。 test@test-PC:~/share/1$ vi eval.sh\n\n\n\n如下，i也循环变量，需要eval将字符串的变量解析，然后echo执行打印。外层变量的$要做转义，否则再未被解析之前会被认为是非法的引用。当然转义也可以用单引号代\n替。\n\n2.3.2 ${!varname*}变量名前缀#\n\n扩展为名称以 prefix 开始的变量名，匹配varname为形状的所有变量名。 先从简单示例开始：\n\n\n\ncolumn先替换为变量 name，然后再取变量值，运行结果为：Tom 然后再实现上一例子： test@test-PC:~/share/1$ vi\neval.sh\n\n\n\n执行结果如下：\n\n\n\n\n3 awk/sed内使用外部变量#\n\n在实际编程中，经常会遇到把shell定义的变量传入给sed和awk使用，这跟我们普通的命令与函数传参略微有所不同。\n\n3.1 sed使用外部变量#\n\n以下三种方法都是可以的\n\n\n\n3.2 awk使用外部变量#\n\n","routePath":"/编程基础/Shell/Shell变量使用","lang":"","toc":[{"text":"1. 变量的声明","id":"1-变量的声明","depth":2,"charIndex":3},{"text":"1.1 常用内置变量","id":"11-常用内置变量","depth":3,"charIndex":76},{"text":"1.2 变量的声明","id":"12-变量的声明","depth":3,"charIndex":1614},{"text":"1.2.1 变量的声明与赋值","id":"121-变量的声明与赋值","depth":4,"charIndex":1626},{"text":"1.2.2 删除变量","id":"122-删除变量","depth":4,"charIndex":1920},{"text":"1.2.3 `readonly`只读变量","id":"123-readonly只读变量","depth":4,"charIndex":-1},{"text":"1.2.4 `declare`声明变量","id":"124-declare声明变量","depth":4,"charIndex":-1},{"text":"2 变量的应用","id":"2-变量的应用","depth":2,"charIndex":2546},{"text":"2.1 变量的作用域","id":"21-变量的作用域","depth":3,"charIndex":2557},{"text":"2.1.1 全局变量","id":"211-全局变量","depth":4,"charIndex":2570},{"text":"2.1.2 局部变量","id":"212-局部变量","depth":4,"charIndex":3321},{"text":"2.1.3 环境变量","id":"213-环境变量","depth":4,"charIndex":3555},{"text":"2.2 变量替换","id":"22-变量替换","depth":3,"charIndex":4821},{"text":"2.3 变量嵌套","id":"23-变量嵌套","depth":3,"charIndex":5055},{"text":"2.3.1 `eval`","id":"231-eval","depth":4,"charIndex":-1},{"text":"2.3.2 `${!varname*}`变量名前缀","id":"232-varname变量名前缀","depth":4,"charIndex":-1},{"text":"3 awk/sed内使用外部变量","id":"3-awksed内使用外部变量","depth":2,"charIndex":5449},{"text":"3.1 sed使用外部变量","id":"31-sed使用外部变量","depth":4,"charIndex":5527},{"text":"3.2 awk使用外部变量","id":"32-awk使用外部变量","depth":4,"charIndex":5558}],"domain":"","frontmatter":{"Author":"海针-搬运"},"version":""},{"id":87,"title":"Shell字符串处理","content":"#\n\n\n1. 字母与ASCII码值的转换#\n\n\n1.1 ASCII#\n\nASCII 是美国对于信息交换的标准代码,使用7位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊控制字符。\n可以使用man ascii查看ASCII值列表，我们通常比较字符的大小，实际上是比对的ASCII码值。 截取如下：\n\nOCT   DEC   HEX   CHAR                OCT   DEC   HEX   CHAR\n000   0     00    NUL '\\0'            100   64    40    @\n001   1     01    SOH （标题开始）          101   65    41    A\n002   2     02    STX （本文开始）          102   66    42    B\n003   3     03    ETX （本文结束）          103   67    43    C\n004   4     04    EOT （传输结束）          104   68    44    D\n005   5     05    ENQ （请求）            105   69    45    E\n006   6     06    ACK （确认回应）          106   70    46    F\n007   7     07    BEL '\\a' （响铃）       107   71    47    G\n010   8     08    BS '\\b' （退格）        110   72    48    H\n011   9     09    HT '\\t' （水平定位符号）    111   73    49    I\n012   10    0A    LF '\\n' （换行键）       112   74    4A    J\n013   11    0B    VT '\\v' （垂直定位符号）    113   75    4B    K\n014   12    0C    FF '\\f' （换页键）       114   76    4C    L\n015   13    0D    CR '\\r' （Enter 键）   115   77    4D    M\n016   14    0E    SO （取消变换）           116   78    4E    N\n017   15    0F    SI （开始变换）           117   79    4F    O\n020   16    10    DLE （跳出数据通讯）        120   80    50    P\n021   17    11    DC1 （设备控制1）         121   81    51    Q\n022   18    12    DC2 （设备控制2）         122   82    52    R\n023   19    13    DC3 （设备控制3）         123   83    53    S\n024   20    14    DC4 （设备控制4）         124   84    54    T\n025   21    15    NAK （确认失败回应）        125   85    55    U\n026   22    16    SYN （同步用暂停）         126   86    56    V\n027   23    17    ETB （区块传输结束）        127   87    57    W\n030   24    18    CAN （取消）            130   88    58    X\n031   25    19    EM （连接介质中断）         131   89    59    Y\n032   26    1A    SUB （替换）            132   90    5A    Z\n033   27    1B    ESC （退出键）           133   91    5B    [\n034   28    1C    FS （文件分区符）          134   92    5C    \\\n035   29    1D    GS （群组分隔符）          135   93    5D    ]\n036   30    1E    RS （记录分隔符）          136   94    5E    ^\n037   31    1F    US （单元分隔符）          137   95    5F    _\n040   32    20    SPACE               140   96    60    `\n041   33    21    !                   141   97    61    a\n042   34    22    \"                   142   98    62    b\n043   35    23    #                   143   99    63    c\n044   36    24    $                   144   100   64    d\n045   37    25    %                   145   101   65    e\n046   38    26    &                   146   102   66    f\n047   39    27    \\´                  147   103   67    g\n050   40    28    (                   150   104   68    h\n051   41    29    )                   151   105   69    i\n052   42    2A    *                   152   106   6A    j\n053   43    2B    +                   153   107   6B    k\n054   44    2C    ,                   154   108   6C    l\n055   45    2D    -                   155   109   6D    m\n056   46    2E    .                   156   110   6E    n\n057   47    2F    /                   157   111   6F    o\n060   48    30    0                   160   112   70    p\n061   49    31    1                   161   113   71    q\n062   50    32    2                   162   114   72    r\n063   51    33    3                   163   115   73    s\n064   52    34    4                   164   116   74    t\n065   53    35    5                   165   117   75    u\n066   54    36    6                   166   118   76    v\n067   55    37    7                   167   119   77    w\n070   56    38    8                   170   120   78    x\n071   57    39    9                   171   121   79    y\n072   58    3A    :                   172   122   7A    z\n073   59    3B    ;                   173   123   7B    {\n074   60    3C    <                   174   124   7C    |\n075   61    3D    =                   175   125   7D    }\n076   62    3E    >                   176   126   7E    ~\n077   63    3F    ?                   177   127   7F    DEL\n\n\n1.1 字母转换为ASCII码值#\n\n * 方法一：printf\n\n\n\n * 方法二：od\n\n\n\n\n1.2 ASCII码值转换为字母#\n\n * 方法一： awk\n\n\n\n * 方法二： printf\n\n\n\n也可以写在一行里：\n\n\n\n\n2. 进制转换#\n\n\n2.1 不同进制的数值赋值给变量#\n\n\n\n当然也可以多此一举，以十进制值同赋值给变量\n\n\n\n\n2.2 不同进制转换为十进制输出#\n\n * 方法一： $(( expressions )) 表达式 表示方法$(( BASE#NUMBER )),\n   BASE代表进制，可为2,8,10,16进制，NUMBER以对应进制的形式显示。\n   \n   注意：这里NUMBER不需要再带进制前缀，因为BASE已经指明了，如0xFF转换为十进制，只需要$((16#FF))而不能使用$((16#0xFF))。\n\n\n\n如果十六进制字符串前缀已经带了0X或者0x，需要先删除这两个字符。\n\n\n\n或者\n\n\n\n * 方法二： bc bc进制转换需要2个内置变量,ibase和obase， ibase为输入进制，obase为输出进制,默认为十进制输出。\n\n\n\n\n2.3 十进制转换为不同进制输出#\n\n * 方法一： printf\n\n\n\nprintf不支持直接输出十进制数据，我们可以通过其它方法实现,比如用bc。\n\n * 方法二： bc\n\n\n\n\n3. 字符串与数组的转换#\n\n\n3.1 数组转换为字符串#\n\n在Bash中，你可以使用\"${array[@]}\"或\"${array[*]}\"来获取数组的所有元素，并使用printf或echo结合字符串连接符\"\"将它们转换为\n单个字符串。\n\n\n\n\n3.2 字符串转换为数组#\n\n要将字符串转换为数组，你可以使用内置的read命令或者直接通过赋值操作。\n\n\n\n在上面的代码中，IFS代表内部字段分隔符（Internal Field\nSeparator），它定义了如何分割字符串。通过设置IFS=','，我们告诉read命令使用逗号作为字段分隔符。在使用完IFS之后，最好将其重置为默认值，以避\n免影响脚本中其他部分的执行。\n\n\n4. Bash字符串处理#\n\n声明一个字符串，并赋初值，本节对字符串的处理都是这个串作为示例。\n\nstring=\"https://zhidao.baidu.com\"\n\n\n4.1 字符串变量处理#\n\n表达式                  说明\n${string}            变量string的值, 与$string相同\n${string-DEFAULT}    如果string没有被声明, 那么就以$DEFAULT作为其值\n${string:-DEFAULT}   如果string没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值，判断var变量是否没有定义\n${string=DEFAULT}    如果string没有被声明, 那么就以$DEFAULT作为其值\n${string:=DEFAULT}   如果string没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值\n                     ，判断var变量是否没有定义，并确保变量始终有值\n${string+OTHER}      如果string声明了, 那么其值就是$OTHER, 否则就为null字符串\n${string:+OTHER}     如果string被设置了, 那么其值就是$OTHER, 否则就为null字符串\n${string?ERR_MSG}    如果string没被声明, 那么就打印$ERR_MSG\n${string:?ERR_MSG}   如果string没被设置, 那么就打印$ERR_MSG\n${!varprefix*}       匹配之前所有以varprefix开头进行声明的变量\n${!varprefix@}       匹配之前所有以varprefix开头进行声明的变量\n\n\n4.2 字符串长度#\n\n表达式          说明\n${#string}   计算字符串string长度。\n\n\n\n\n4.3 字符串截取#\n\n表达式                    说明\n${string#substring}    从变量$string的左侧开始, 删除最短匹配$substring的子串。\n${string##substring}   从变量$string的左侧开始, 删除最长匹配$substring的子串。\n${string%substring}    从变量$string的右侧开始, 删除最短匹配$substring的子串。\n${string%%substring}   从变量$string的右侧开始, 删除最长匹配$substring的子串。\n\n\n\n\n4.4 字符串替换#\n\n表达式                                说明\n${string/substring/replacement}    使用$replacement, 来代替第一个匹配的$substring的子串。\n${string//substring/replacement}   使用$replacement, 代替所有匹配的$substring\n${string/#substring/replacement}   从变量string的右侧开始, 删除最短匹配substring的子串。\n${string/%substring/replacement}   从变量string的右侧开始, 删除最长匹配substring的子串。\n\n\n4.5 字符串连接#\n\n将多个字符串并排放到一起就能实现字符中的连接 。\n\n\n\n\n4.6 字符串切片操作#\n\n通过 ${变量名:起始:长度} 得到子字符串。\n\n表达式                         说明\n${string:offset}            返回字符串变量string中从第offset个字符后面\\（不包括第offset个字符\\）的字符开始，到最后的部分。\n                            注意：offset 的取值在0到 ${#var}-1 之间。\n${string:offset:number}     返回字符串变量string中从第offset个字符后面\\（不包括第offset个字符\\）的字符开始，长度为number的\n                            部分。\n${string: -length}          取字符串的最右侧几个字符。 注意：冒号后必须有一空白字符。\n${string:offset: -length}   从最左侧跳过offset字符，一直向右取到距离最右侧lengh个字符之前的内容。\n${string: -length:offset}   先从最右侧向左取到length个字符开始，再向右取到距离最右侧offset个字符之间的内容。\n                            注意：-length前空格。\n\n\n\n\n4.7 字符串比较大小#\n\n字符串是按照从左向右对字母的ASCII值大小进行比较，不关心字符串的长度，比较过程中左侧同等位置的字母大者字符串为大。\n\n表达式   说明\n=     等于,如:if [ \"$a\" = \"$b\" ]\n==    等于,如:if [ \"$a\" == \"$b\" ], 与=等价注意:==的功能在[[]]和[]中的行为是不同的,如下: 1\n      [[ $a == z* ]] # 如果$a以\"z\"开头(模式匹配)那么将为true 2 [[ $a == \"z*\" ]]\n      # 如果$a等于z*(字符匹配),那么结果为true 3 [ $a == z* ] #\n      如果$a等于z*(字符匹配),那么结果为true 4 [ \"$a\" == \"z*\" ] #\n      如果$a等于z*(字符匹配),那么结果为true\n!=    不等于,如:if [ \"$a\" != \"$b\" ]， 这个操作符将在[[]]结构中使用模式匹配.\n<     小于,在ASCII字母顺序下.如: if [[ \"$a\" < \"$b\" ]] if [ \"$a\" \\< \"$b\" ]\n      在[]结构中\"<\"需要被转义.\n>     大于,在ASCII字母顺序下.如: if [[ \"$a\" > \"$b\" ]] if [ \"$a\" \\> \"$b\" ]\n      在[]结构中\">\"需要被转义.\n-z    字符串为空.就是长度为0.\n-n    字符串不为空","routePath":"/编程基础/Shell/Shell字符串处理","lang":"","toc":[{"text":"1. 字母与ASCII码值的转换","id":"1-字母与ascii码值的转换","depth":2,"charIndex":3},{"text":"1.1 ASCII","id":"11-ascii","depth":3,"charIndex":23},{"text":"1.1 字母转换为ASCII码值","id":"11-字母转换为ascii码值","depth":3,"charIndex":3945},{"text":"1.2 ASCII码值转换为字母","id":"12-ascii码值转换为字母","depth":3,"charIndex":3995},{"text":"2. 进制转换","id":"2-进制转换","depth":2,"charIndex":4061},{"text":"2.1 不同进制的数值赋值给变量","id":"21-不同进制的数值赋值给变量","depth":3,"charIndex":4072},{"text":"2.2 不同进制转换为十进制输出","id":"22-不同进制转换为十进制输出","depth":3,"charIndex":4119},{"text":"2.3 十进制转换为不同进制输出","id":"23-十进制转换为不同进制输出","depth":3,"charIndex":4442},{"text":"3. 字符串与数组的转换","id":"3-字符串与数组的转换","depth":2,"charIndex":4534},{"text":"3.1 数组转换为字符串","id":"31-数组转换为字符串","depth":3,"charIndex":4550},{"text":"3.2 字符串转换为数组","id":"32-字符串转换为数组","depth":3,"charIndex":4657},{"text":"4. Bash字符串处理","id":"4-bash字符串处理","depth":2,"charIndex":4846},{"text":"4.1 字符串变量处理","id":"41-字符串变量处理","depth":3,"charIndex":4931},{"text":"4.2 字符串长度","id":"42-字符串长度","depth":3,"charIndex":5616},{"text":"4.3 字符串截取","id":"43-字符串截取","depth":3,"charIndex":5676},{"text":"4.4 字符串替换","id":"44-字符串替换","depth":3,"charIndex":5962},{"text":"4.5 字符串连接","id":"45-字符串连接","depth":3,"charIndex":6300},{"text":"4.6 字符串切片操作","id":"46-字符串切片操作","depth":3,"charIndex":6341},{"text":"4.7 字符串比较大小","id":"47-字符串比较大小","depth":3,"charIndex":6926}],"domain":"","frontmatter":{"Author":"海针 - 搬运"},"version":""},{"id":88,"title":"","content":"Shell数学运算#\n\n\n1. 常用的数学运算工具及表达式#\n\n工具/表达式               案例说明\n$[ expressions ]     支持整数运算， 如 var = $[ 3 + 2 ], var = $[ var * 10 ]。\n$(( expressions ))   支持整数运算，功能更为强大灵活，类C语言表达式风格，支持三元运算，支持自增自减，如$((1+2+3))，\n                     $(($i++))\nexpr                 支持整数运算，如 expr $i + 2, 注意表达式中每个参数之间要有空格，并且有类似*这样的通配符还要转义。\n                     如expr 2 + 3 , expr 5 \\* 6\nlet                  用于整数计算，支持自增自减运算， 注意表达式中每个参数之间不能有空格， 如let i++;let i++1;\nbc                   计算器，支持浮点运算, 如 echo “2+3” | bc , echo “scale=2;5/2” | bc\nawk/gawk             强大的文本和字符串处理工具，类C语言表达式风格，如 echo | awk '{ printf(\"%d\\n\",2+3)\n                     }'\n\n\n1.1 $[ expression ]表达式#\n\n * 1. $[...]表达式中变量符号$可有可无，表达式各参数之间空格可有可无。支持+,-,*,/,%, ++,--,>,<,==,**,&&,||等运算符。\n      \n      如a=8; echo $[$a+8]等同于echo $[ a + 8 ], $和空格可有可无。\n      \n      更多示例如下：\n   \n   \n\n * 2. 注意和[ expressions\n      ]表达式做区分,[]是test的用法变体，在[]表达式中变量必须带$，各参数之间必须有空格，数值比较必须用lt,le,gt,ge,eq,ne参数，如\n      用<>=符号，则视为字符串比较。\n   \n   \n\n\n1.2 $(( expressions )) 表达式#\n\n$(( expressions ))除了具备 $[ expression ]的运算符支持的能力外，还支持多个表达式运算，进制转换。\n\n * 支持多个表达式运算， 表达式之间用“,”分隔。\n\n\n\n * 转换成10进制输出\n\n\n\n * 类C语言风格的for循环\n\n\n\n\n1.3 expr#\n\nexpr工具可以用来进行整数数值运算和数值比较，需注意以下几点：\n\n * 只能对整数参数进行运算和比较\n\n * 参数之间必须有空格\n\n * 对于通配符如*，必须要转义\n\n * 变量必须使用$来引用\n\n用法如下：\n\n * 整数数学运算和逻辑判断\n\n\n\n * 判断变量是否为整数\n   \n   由于expr只能对整数进行数学运算，所以可以通过expr命令的退出码来判断是变量是否为整数\n\n\n\n\n1.4 let#\n\nlet是shell内置命令，常用于整数的整值运算，使用时需要注意\n\n * let 只接受整数数值运算，传入变量为字符串会默认变量值为0. （实际测试还会出现未知的异常错误）\n\n * let 运算=号左右两边不能有空格， 除非let 的表达式用双引号引起来（建议）\n\n * let 等式中的变量可以不用带$， 对于*,()符号可以不用转义。\n\n用法：\n\n\n\n在循环中使用let计数:\n\n\n\n\n1.5 bc#\n\nbc计算器，不仅可以进行整数计算，还支持对浮点数的运算，进制转换，幂运算。\n\n * 整数计算，逻辑判断\n\n\n\n * 浮点数计算\n\n\n\n注意：bc变量scale设置的小数位只对除法有效，加减乘法还是输出最高精度，想要保留具体小数点位数建议还是使用printf格式化打印\n\n * 进制转换\n\n\n\n * 科学计算，利用bc -l 使用数学库来实现求幂运算，正弦，余弦，正切等\n\n\n\n * 批量运算\n\n\n\n\n1.6 awk/gawk#\n\nawk是一款非常强大的文本处理工作，涉及大量的文本处理工作时选择awk无疑是高效的，awk使用方法网上有大量的介绍。本章节重点使用awk来进行数学运算。\n\nawk/gawk已经可以作为一门编程语言，在数学运算上参照C语言编程规范， 支持\n\n * 算术运算: +,-,*,/,%,++,--\n * 关系运算: > ,<,==,<=,>=,!=\n * 逻辑运算： &&,||,!\n * 赋值运算: =,+=,-=,*=,/=,%=, &=,^=,|=\n * 三元运算: ?:\n * 位运算函数：lshift(var,count)，rshift(var,count), or(var1,var2), xor(var1,var2),\n   and(var1,var2),compl(var)\n * 内置数学函数：sin(var),cos(var),exp(var),sqrt(var),log(var) ,等等\n   更为关键的是，awk/awk还可以自定义算法函数， 可以处理更为复杂的逻辑运算。\n\n用法\n\n\n\n\n2. Shell数学运算实践#\n\n本节参考一段C语言代码，获取字符串的hash值，把C语言代码转换成Bash语言和awk，来练习之前章节所学习的一些技能。\n\n\n2.1 C语言Hash算法#\n\n以下C语言代码中ELFHash函数来源于http://www.partow.net/programming/hashfunctions\n\ntest@test-PC:~/work/study/cplus$ vi hash.c\n\n\n\n编译执行，结果如下：\n\n\n\n\n2.2 Bash语言Hash算法#\n\ntest@test-PC:~/work/study/cplus$ vi hash.sh\n\n\n\n执行结果如下：\n\n\n\n\n2.3 awk语言Hash算法#\n\ntest@test-PC:~/work/study/cplus$ vi hash.awk\n\n\n\n执行结果如下：\n\n","routePath":"/编程基础/Shell/Shell数学运算","lang":"","toc":[{"text":"Shell数学运算","id":"shell数学运算","depth":2,"charIndex":-1},{"text":"1. 常用的数学运算工具及表达式","id":"1-常用的数学运算工具及表达式","depth":2,"charIndex":12},{"text":"1.1 `$[ expression ]`表达式","id":"11--expression-表达式","depth":3,"charIndex":-1},{"text":"1.2 `$(( expressions )) `表达式","id":"12--expressions--表达式","depth":3,"charIndex":-1},{"text":"1.3 `expr`","id":"13-expr","depth":3,"charIndex":-1},{"text":"1.4 `let`","id":"14-let","depth":3,"charIndex":-1},{"text":"1.5 `bc`","id":"15-bc","depth":3,"charIndex":-1},{"text":"1.6 `awk/gawk`","id":"16-awkgawk","depth":3,"charIndex":-1},{"text":"2. Shell数学运算实践","id":"2-shell数学运算实践","depth":2,"charIndex":2201},{"text":"2.1 C语言Hash算法","id":"21-c语言hash算法","depth":3,"charIndex":2281},{"text":"2.2 Bash语言Hash算法","id":"22-bash语言hash算法","depth":3,"charIndex":2427},{"text":"2.3 awk语言Hash算法","id":"23-awk语言hash算法","depth":3,"charIndex":2505}],"domain":"","frontmatter":{"Author":"海针 - 搬运"},"version":""},{"id":89,"title":"Shell编码规范错误参考手册","content":"#\n\n\n背景#\n\nShell 脚本提交以前必须用静态代码扫描工具 shellcheck 扫描，根据提示修改代码，需达到扫描后无报错即可通过。\n\n修改过程中整理了一些常见错误与解决办法以供参考。\n\n\n工具使用#\n\n安装 shellcheck 并使用命令进行扫描，具体步骤如下：\n\n\n\n\n错误编号#\n\n--------------------------------------------------------------------------------\n\nshellcheck 扫描出的每一个错误，均有其编号，以 SC+4位数字 组成，google 可搜索到详细建议，以下为整理出的部分编号，分为两部分：\n\n * 可选修改编号：部分场景下为正常现象，该错误无需修改，在文件头配置跳过该检测项与说明即可，配置命令 # shellcheck disbale=编号\n\n * 必须修改编号：必须修改的错误\n\n\n可选修改编号：#\n\n--------------------------------------------------------------------------------\n\nSC2154#\n\n * 报错：SC2154: quiet_type is referenced but not assigned.\n * 原因：代码中使用的变量quiet_type被引用，但并未被赋值\n * 解决：在引用变量前对齐赋值\n * 特殊情况：应该测试框架加载了多个文件，文件中存在关联关系，当前文件未被赋值的变量是在其他文件中处理的，顾此时可以特殊处理，跳过该项检查，文件头注释：#\n   shellcheck disable=SC2154\n\nSC2034#\n\n\n\n * 报错：SC2034: r appears unused. Verify use (or export if used externally).\n\n * 原因：变量ｒ赋值后未被使用，因该文件是存放公共方法，顾变量ｒ在脚本中不会被使用\n\n * 解决：在此文件跳过该项检查，文件头增加注释：# shellcheck disbale=SC2034\n\n\n必须修改编号：#\n\n--------------------------------------------------------------------------------\n\nSC2162#\n\n\n\n * 报错：SC2162:read without -r will mangle backslashes.\n * 原因：默认情况下，Read将解释空格和换行符之前的反斜杠，通常您只想读取数据，这就是read\n   -r所做的。除非有充分的理由不使用-r，否则应该始终使用-r（请注意，read-r仍然会去掉前导空格和尾随空格。IFS=“”read-r可防止这种情况。）\n * 修改：\n\n\n\n * 例子：\n\n\n\nSC2181#\n\n\n\n * 报错：SC2181:Check exit code directly with e.g. 'if mycmd;', not indirectly with\n   $?.\n * 原因：检查退出代码直接使用 if mycmd; ，而不是使用$?\n * 修改：\n\n\n\nSC1090#\n\n\n\n * 报错：SC1090: Can't follow non-constant source. Use a directive to specify\n   location.\n * 原因：source后不要跟变量\n * 修改：\n\n\n\nSC1091#\n\n\n\n * 报错：SC1091: Not following: method/config was not specified as input (see\n   shellcheck -x).\n\n * 原因：file not found, no permissions, not included on the command line, not\n   allowing shellcheck to follow files with -x\n\n * 解决：\n   \n   * 命令行输出检查命令时加上参数-x，允许 shellcheck 跟踪文件：shellcheck -x -s bash test.sh\n     \n     * 注意：当涉及文件无权限时，使用之后方法\n   \n   * 文件中错误命令上增加注释# shellcheck disable=SC1091，跳过该错误项检查：\n     \n     \n\nSC2219#\n\n * 报错：SC2219: Instead of 'let expr', prefer (( expr )) .\n\n * 原因：使用(( )) 代替 let\n\n * 解决：\n   \n   \n\nSC2076#\n\n * 报错：SC2076: Don't quote rhs of =~, it'll match literally rather than as a\n   regex.\n\n * 原因：使用=~ 但右侧的值存在\" \"，那将按照字面量匹配，而非正则表达式\n\n * 解决：\n   \n   \n\nSC2010#\n\n * 报错：SC2010: Don't use ls | grep. Use a glob or a for loop with a condition to\n   allow non-alphanumeric filenames.\n\n * 原因：不要使用 ls|grep，可使用 glob 通配符\n\n * 解决：\n   \n   \n\nSC2046#\n\n * 报错：Double quote to prevent globbing and word splitting.\n\n * 原因：当命令扩展未加引号时，将发生单词拆分和全局合并。当文件名包含空格时，这通常表现为中断。\n\n * 解决：\n\n\n\nSC2086#\n\n * 报错：Double quote to prevent globbing and word splitting.\n\n * 原因：引用变量可防止单词拆分和全局扩展，并在输入包含空格、换行符、全局字符等时防止脚本中断。\n\n * 解决：\n   \n   \n\nSC2188#\n\n * 报错：SC2188: This redirection doesn't have a command. Move to its command (or\n   use 'true' as no-op).\n\n * 原因：重定向无命令\n\n * 解决：\n   \n   \n\nSC2013#\n\n * 报错：SC2013: To read lines rather than words, pipe/redirect to a 'while read'\n   loop.\n\n * 原因：要读取行，而不是词时，使用管道/重定向到while read循环\n\n * 解决：\n   \n   \n\nSC2129#\n\n * 报错：SC2129:Consider using { cmd1; cmd2; } >> file instead of individual\n   redirects.\n\n * 原因：多个重定向时，建议使用{ cmd1; cmd2; } >> file，更为简洁\n\n * 解决：\n   \n   \n\nSC2126\n\n * 报错：SC2126:Consider using grep -c instead of grep | wc\n\n * 原因：grep+wc时，可使用grep -c代替\n\n * 解决：\n   \n   \n\nSC2230#\n\n * 报错：SC2230:which is non-standard. Use builtin 'command -v' instead.\n\n * 原因：which是在PATH中定位可执行文件的非标准外部工具。command\n   -v是一个POSIX标准内置命令，它使用与shell本身相同的查找机制，使用command -v代替which\n\n * 解决：\n   \n   \n\nSC2002#\n\n * 报错：SC2002:Useless cat. Consider 'cmd < file | ..' or 'cmd file | ..' instead.\n\n * 原因：CAT是启用文件的工具。将单个文件作为程序的输入读取被认为是对Cat(UUOC)的无用使用。简单地使用重定向更高效、更少迂回。对于可以从可查找的输入\n   中获益的程序(如Tail或tar)，情况尤其如此。\n\n * 解决：\n   \n   \n\nSC2164#\n\n * 报错：SC2164:Use cd ... || exit in case cd fails.\n\n * 原因：CAT是启用文件的工具。将单个文件作为程序的输入读取被认为是对Cat(UUOC)的无用使用。简单地使用重定向更高效、更少迂回。对于可以从可查找的输入\n   中获益的程序(如Tail或tar)，情况尤其如此。\n\n * 解决：\n   \n   \n\nSC2145#\n\n * 报错：SC2145:Argument mixes string and array. Use * or separate argument.\n\n * 原因：参数混合了字符串和数组。使用*或单独的参数。\n\n * 解决：\n   \n   \n\nSC2185#\n\n * 报错：SC2185:Some finds don't have a default path. Specify '.' explicitly.\n\n * 原因：如果没有提供搜索路径，GNU和Busybox\n   find将使用当前目录的默认路径。在POSIX、MacOS/OSX、FreeBSD、OpenBSD和NetBSD上，它反而会导致错误。\n\n * 解决：\n   \n   \n\nSC2012#\n\n * 报错：SC2012:Use find instead of ls to better handle non-alphanumeric filenames.\n\n * 原因：如果您想要的仅仅是文件名或它们的数量，那么ls通常可以替换为find。\n\n * 解决：\n   \n   \n\nSC2143#\n\n * 报错：SC2143:Use grep -q instead of comparing output with [ -n .. ].\n\n * 原因：grep判断结果时，使用grep -q，而不是将结果输出，正确的代码更干净，并在第一个匹配行停止，避免了迭代目录的其余部分和将数据读入内存。\n\n * 解决：\n   \n   \n\nSC2001#\n\n * 报错：SC2001: See if you can use ${variable//search/replace} instead.\n\n * 原因：echo 变量+sed处理输出时，壳尝试使用${variable//search/replace}\n\n * 解决：\n   \n   \n\nSC2116#\n\n * 报错：SC2116: Useless echo? Instead of 'cmd $(echo foo)', just use 'cmd foo'.\n\n * 原因：无用的echo\n\n * 解决：\n   \n   \n\nSC2059#\n\n * 报错：Don't use variables in the printf format string. Use printf \"..%s..\"\n   \"$foo\".\n\n * 原因：printf未使用%s\n\n * 解决：\n   \n   \n\nSC2066#\n\n * 报错：SC2066: Since you double quoted this, it will not word split, and the loop\n   will only run once.\n\n * 原因：for循环使用了数组：\"array[*]\"，由于使用了双引号，因此不会拆分单词，循环只会运行一次。\n\n * 解决：\n   \n   \n\nSC2103#\n\n * 报错：SC2103: Use a ( subshell ) to avoid having to cd back..\n\n * 原因：使用子shell执行命令，避免回放cd。\n\n * 解决：\n   \n   \n\nSC2035#\n\n * 报错：SC2103: Use ./glob or -- glob so names with dashes won't become options.\n\n * 原因：因为文件和参数是以相同方式传递的字符串，所以程序不能正确地识别，使用./、--可避免这个问题。\n\n * 解决：\n   \n   \n\nSC2124#\n\n * 报错：SC2124: Assigning an array to a string! Assign as array, or use * instead\n   of @ to concatenate.\n\n * 原因：将数组赋给字符串！赋值为数组，或使用*而不是@进行连接。\n\n * 解决：\n   \n   \n\nSC1012#\n\n * 报错：SC1012: \\t is just literal t here. For tab, use \"$(printf '\\t')\" instead.\n\n * 原因：ShellCheck 发现了一个\\t,\\n或者\\r在一个上下文中，它们只是变成了普通的字母t，n或者r。很可能，它被用作制表符、换行符或回车符。\n\n * 解决：\n   \n   \n\nSC2048#\n\n * 报错：SC2048: Use \"$@\" (with quotes) to prevent whitespace problems.\n\n * 原因：当一个数组使用 for 循环遍历时，相对于 $* ， \"$@\" 要更为安全，避免空格可引起的其他问题。\n\n * 解决：\n   \n   \n\nSC2268#\n\n * 报错：SC2268 (style): Avoid x-prefix in comparisons as it no longer serves a\n   purpose.\n\n * 原因：避免在比较中使用x-prefix，因为它不再起作用。\n\n * 解决：\n   \n   ","routePath":"/编程基础/Shell/Shell编码规范错误参考手册","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":3},{"text":"工具使用","id":"工具使用","depth":2,"charIndex":98},{"text":"错误编号","id":"错误编号","depth":2,"charIndex":141},{"text":"可选修改编号：","id":"可选修改编号","depth":3,"charIndex":403},{"text":"SC2154","id":"sc2154","depth":4,"charIndex":495},{"text":"SC2034","id":"sc2034","depth":4,"charIndex":722},{"text":"必须修改编号：","id":"必须修改编号","depth":3,"charIndex":908},{"text":"SC2162","id":"sc2162","depth":4,"charIndex":1000},{"text":"SC2181","id":"sc2181","depth":4,"charIndex":1216},{"text":"SC1090","id":"sc1090","depth":4,"charIndex":1361},{"text":"SC1091","id":"sc1091","depth":4,"charIndex":1489},{"text":"SC2219","id":"sc2219","depth":4,"charIndex":1906},{"text":"SC2076","id":"sc2076","depth":4,"charIndex":2011},{"text":"SC2010","id":"sc2010","depth":4,"charIndex":2164},{"text":"SC2046","id":"sc2046","depth":4,"charIndex":2340},{"text":"SC2086","id":"sc2086","depth":4,"charIndex":2470},{"text":"SC2188","id":"sc2188","depth":4,"charIndex":2606},{"text":"SC2013","id":"sc2013","depth":4,"charIndex":2750},{"text":"SC2129","id":"sc2129","depth":4,"charIndex":2904},{"text":"SC2230","id":"sc2230","depth":4,"charIndex":3176},{"text":"SC2002","id":"sc2002","depth":4,"charIndex":3374},{"text":"SC2164","id":"sc2164","depth":4,"charIndex":3592},{"text":"SC2145","id":"sc2145","depth":4,"charIndex":3779},{"text":"SC2185","id":"sc2185","depth":4,"charIndex":3909},{"text":"SC2012","id":"sc2012","depth":4,"charIndex":4111},{"text":"SC2143","id":"sc2143","depth":4,"charIndex":4261},{"text":"SC2001","id":"sc2001","depth":4,"charIndex":4434},{"text":"SC2116","id":"sc2116","depth":4,"charIndex":4587},{"text":"SC2059","id":"sc2059","depth":4,"charIndex":4706},{"text":"SC2066","id":"sc2066","depth":4,"charIndex":4837},{"text":"SC2103","id":"sc2103","depth":4,"charIndex":5024},{"text":"SC2035","id":"sc2035","depth":4,"charIndex":5140},{"text":"SC2124","id":"sc2124","depth":4,"charIndex":5300},{"text":"SC1012","id":"sc1012","depth":4,"charIndex":5466},{"text":"SC2048","id":"sc2048","depth":4,"charIndex":5652},{"text":"SC2268","id":"sc2268","depth":4,"charIndex":5806}],"domain":"","frontmatter":{"Author":"海针"},"version":""},{"id":90,"title":"Shell进程调用","content":"#\n\n\n1. 进程调用无处不在#\n\n实际上，Shell脚本的进程调用无处不在，除了shell自身的内建命令，Shell调用工具命令都会开辟一个子进程去执行，比如在shell脚本中使用sed，gre\np，sleep等命令。\n\ntest@test-PC:~$ vim proc.sh\n\n\n\n如上例，在Bash脚本中执行一个sleep， 执行脚本，新开终端查询进程。查询结果分析可以看到，sleep\n20做为一个子进程在运行，进程ID为14586,而他的父进程正是proc.sh脚本进程，ID为14586。\n\ntest@test-PC:~$ bash proc.sh\n\ntest@test-PC:~$ ps -ef | grep -E 'sleep|proc.sh'\n\n\n\n\n2. 脚本的调用#\n\n * 调用方法1： bash script.sh\n   \n   在当前Shell中开辟一个子进程shell运行script.sh脚本，\n   与父进程共享环境变量；script.sh文件可不必有可执行权限，已经显示的给出调用script.sh的解析器为Bash。\n\n * 调用方法2：./script.sh\n   \n   在当前Shell中开辟一个子进程shell运行script.sh脚本，\n   与父进程共享环境变量；script.sh文件必须有可执行权限，否则权限错误，使用哪种shell解释执行，取决于脚本开头的声明，如#!/bin/bash，如\n   未进行声明，默认使用当前终端所用Shell。\n\n * 调用方法3： . script.sh\n   \n   在当前Shell进程中执行script.sh，与当前shell同一进程，共享全局变量和环境变量。script.sh如有exit，则退出当前shell。\n\n * 调用方法4： source script.sh\n   \n   同调用方法3\n   \n   补充说明\n   \n   >  1. 调用方法1,2 都是新开shell进程执行， 调用方法3,4都是当前进程中执行；\n   >  2. 调用方法3,4的常用场景在需要导入环境变量，全局变量，或者导入公共函数处理脚本时使用，使用.和使用source效果是一样的，但source是B\n   >     ash的内建命令，并非所有Shell解析器都能支持，所以从脚本的健壮性和通用性角度讲，推荐使用.。\n\n\n3. 进程的后台处理#\n\n\n3.1 进程后台运行#\n\n * &： 使用&符号，在调用进程或者函数后加 &，即将进程放到后台去执行。如下，sleep进程被放入后台，进程ID为13358。\n   \n   \n\n * Ctrl+z：\n   如果是在终端中调用的命令或脚本，可以通过键入Ctrl+z，将命令或脚本放入后并挂起进程，注意：进程在后台不再运行，是停止状态，等待唤醒指令后才能继续运行。\n   \n   \n\n\n3.2 查询后台进程#\n\njobs:使用jobs命令后台运行中的进程。[1]\n中括号里的数字表示进程的作业号，唤醒和恢复时可以指定进程。+代表当前进程，-代表当前进程的上一进程，使用fg恢复时如不指定作业号，默认恢复当前进程。\n\n\n\njobs支持参数选项来对后台进程进行筛选。\n\n\n\n\n3.3 恢复后台进程#\n\n * fg:将后台进程恢复到前台运行, 通过fg number指定进程作业号来恢复指定进程。\n   \n   \n\n * bg:将后台进程唤醒，继续在后台执行,即将挂起的任务进程的状态由 stopped 改为 running。\n   \n   \n\n\n4. 守护进程#\n\n通常我们运行脚本或者命令是在一个用户终端下，不论脚本是在前后还是后台运行，当我们关闭终端，脚本和命令进程也会随之消亡。这是因为终端退出时会对终端下的子shell\n进程发送SIGHUP信号，子进程shell进程收到信号默认终止进程运行。\n\n有时这并不是我们想要的，比如写一个长时间运行的批处理脚本，如产品安装，升级，构建，脚本执行时长可能以小时来计算，在这期间如果终端异常中断，脚本也会中断，任务就会\n执行失败。\n\n这里我们引入守护进程，借鉴了传统编程语言守护进程的概念（如C++/Java），Shell的守护进程可以狭义的理解为脱离了用户终端而在后台运行的进程。\n实现方法如下：\n\n * nohup script.sh & ：\n   nohup通知脚本script.sh忽略掉终端断连信号SIGHUP，即终端断开时进程不会退出。如下，sleep进程放入后台，ID为27310。\n   \n   \n   \n   终端退出，再次登录查看sleep进程,进程ID27310仍然在运行，它已被 init进程(ID为1)接收。\n   \n   \n\n * 在脚本中忽略终端退出信号 改变进程接收SIGHUP信号后的默认处理方式，即主动捕捉信号并自定义处理方式。\n   在脚本中，需要开始忽略SIGHUP的核心代码运行之前，加入trap \"\" HUP，\n   \"\"中可以自定义一个函数名，在接收到SIGHUP信号后执行该函数，也可以为空，不做任务处理，即忽略掉SIGHUP信号，程序照常运行。\n   test@test-PC:~/work/study/shell/share$ vi sighup.sh\n   \n   \n   \n   \n   \n   重启终端，查看进程并未退出。\n   \n   \n\n\n5. 进程的并发控制#\n\n\n5.1 一个简单的并发例子#\n\nshell也可以通过进程并发的方式提高运行效果，以下是最简单的shell进程并发例子。\n\n\n\n以上是两个进程，主进程和子进程同时运行，各自打印自己的信息。\nchild_process子进程被放到了后台运行，主进程并没有等子进程运行完成就退出了。子进程在后台继续运行，直到退出。\n\n\n\n\n5.2 Shell进程的同步机制#\n\n优化一下上述脚本，引入进程同步机制，主进程等待子进程执行完毕后再退出。这里引入wait命令。\n\n\n\n$$:当前shell的进程ID $!：最后一个运行在后台的进程ID\n在父进程里使用wait以阻塞的方式等待子进程执行完毕，父进程（主进程）得以继续执行。这里值得注意的是不管父进程，还是子进程，打印PID都是1161，即当前she\nll进程的PID,这是bash的自身机制。\n\n\n\n\n5.3 多进程并发#\n\n并发的目的是为了提高运行效率，以另外一种机制来实现多进程并发与同步。\n\n\n\n * 1）上面是用数组的方式采集进程ID，实现了5个子进程并发处理，子进程命令为sleep，这里根据业务需要可以替换成自定义的批处理进程，脚本，函数等；\n\n * 2）这里进程间的同步是通过kill -0查询进程是否存在，查询的时长取决于执行时间最长的子进程。通过并发后脚本执行时长为5秒，如果串行则时长为15秒。\n\n\n6. 进程间通信#\n\n进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。\n\n编程语言常用的IPC的方式有管道（包括匿名管道和命名管道）、消息队列、信号量、共享内存等，如果涉及跨主机通信，可以使用Socket等。\n\n当然Shell做为解释性语言无法直接实现上面的底层开发，这也不是我们使用Shell的初衷，但是我们仍然可以借助工具，借鉴思路实现简单的进程通信，以满足业务需要。\n\n\n6.1 匿名管道#\n\n匿名管道使用符号 | 表示,这是我们最常用的进程间通信方式了，管道左侧接收进程的标准输出，右侧是进程的标准输入。\n\n\n\n如上例，一行代码我们使用了两个|，为了方便叙述我们称为管道1和管道2。\n管道1左侧echo进程输出信息，原本是要送到标准输出（STDOUT）的,这里被管道1接收；\n管道1右侧cut进程从管道1中读入信息，做出处理，然后输出到管道2；而sed进程又从从管道2中读入信息，做处理，将结果输出到标准输出。\n\n注意：\n\n * |两侧是标准输出和标准输入，所以如果左侧是标准错误，是不会被送入管道，右侧也就无法接收处理。如下,ls的执行结果还是被送到了标准错误，在屏幕中显示，并没有\n   进入管道。\n   \n   \n\n\n6.2 命名管道#\n\nmkfifo:用来创建命名管道，命名管道是一种特殊的文件，同一操作系统内的进程都可以向命名管道内写入消息，同理，也可以读取消息，消息写入和读取是双向的，跟普通文\n件一样，读写前提是进程要有权限。\n如下是创建一个命名管道，权限标志位置第一个字母是p，代表这是管道文件（-：普通文件，d:目录文件，l:链接文件，b:设备文件，c:字符设备文件，p:管道文件），\n其它权限标志跟普通文件是一致的。\n\n\n\n向管道写入信息,写入后会阻塞等待进程读取。\n\n\n\n向管道读取信息，我们用cat命令，跟读取文件一样，如果管道内无消息，则阻塞等待消息进入管道。\n\n\n\n读取信息完毕之后，cat进程退出，当然你也可以做后续的处理； 而写入进程echo在管道内信息被取走之后，进程也随之退出。\n\n可以看到，命名管道是通过阻塞的方式进行进程同步的，可以多个进程写入消息，读取进程按照 先进先出\n的顺序取走消息。可不可以多个进程读呢，当然也是可以的，但是消息被取走之后管道就空了（除非有新消息写入），多个进程来读，总是最先读取的进程拿到消息，后来读取的因为\n管道空了，只有阻塞等待，直到有新消息写入。\n\n我们可以借助传统编程语言的思路做一个服务端和客户端程序：\n\n * server端：\n\n\n\n启动服务端：\n\n\n\n * 客户端\n\n\n\n执行客户端发送消息： bash client.sh \"Name:Jack,Age:22,Gender:Man,Desc:null\" bash client.sh\n\"Name:Jack,Age:22,Gender:Man,Desc:null\" bash client.sh\n\"Name:Lily,Age:21,Gender:Woman,Desc:null\"\n\n查看服务端接收消息：\n\n\n\n\n6.3 普通文件传递消息#\n\n命名管道采用阻塞的方式实现进程间同步通信，有时，我们也需要进程间异步通信，即两个进程间不需要阻塞的方式等待消息， 它们之间仅仅是传递一个状态或者是标志。\n实现异步用一个简单的普通文件就可以了。 比如， A进程需要实现系统IP的配置，B进程需要实现系统IP的修改，但前提是要求系统IP已经配置好，否则就执行失败；\n\n那么A进程在执行配置IP成功后，可以将状态写入一个约定的配置文件（可以为空文件，仅做标志位，也可以写入状态内容），写完后A进程就不管了；\nB进程在执行修改工作时，首先读取配置文件，确认IP配置状态已经成功，然后执行修改过程； 否则可以提示IP尚未配置；\n\n\n7. 进程的远程调用#\n\n实际工作中，经常会遇到远程调用主机上的命令或脚本， 或者将本地脚本同步到远程主机上进行调用。 这里用到ssh(Secure\nShell),前提是双方主机建立了通信连接机制，或者密钥的方式或者输入密码方式进行登录执行；\n\n> ssh -nq user@xxx.xxx.xx.xx \"commoand line\" -n 把 stdin 重定向到 /dev/null (实际上防止从\n> stdin 读取数据).\n> \n> -q 安静模式. 消除所有的警告和诊断信息. -t 强制分配伪终端. ssh的详细使用说明可以自行man page\n\n\n7.1 进程执行简单命令#\n\n\n\n * ssh连接到远程主机，会进入用户家目录，加载环境变量，所以这里运行的系统命令不需要加绝对路径。\n * 但如果是自己定义的脚本，并且不在家目录下，则需要带上脚本的绝对路径，否则远程shell找不到脚本。\n\nBash登录模式分为登录和非登录，交互和非交互，不同的模式下对环境变量（如/etc/profile,~/.profile,\n~/.bashrc,...)加载是不一样的，详细可见man page，这里不做阐述。\n\n\n7.2 进程执行多条命令组合#\n\n如果执行多条命令或者更为复杂的逻辑处理，可以使用Shell Here Document（嵌入文档）的方式。\n\n应当注意：\n\n * 1） 命令从 EOF开始，到遇到下一个EOF结束，注意第二个EOF一定要顶行（行开头，不要留空格或其它字符）书写。\n * 2） 命令中如果包含变量是在远程主机上进行解析，那么本地命令中要加转义’\\’，否则会被认为是本地变量，解析后再发送给远程主机。\n   如下例，两个EOF之间的命令，对于本地主机就是多行字符串，发送到远程主机才会执行，在发送之前，会对${ARCH}变量进行解析，由于ARCH未定义和赋值，这\n   里会被解析成空串发送给远程主机，导致后面命令执行出错。 如果加转义\\${ARCH}后本地不再解析，发送到远程主机后命令执行过程中解析。\n\n\n\n输出\n\n\n\n\n7.3 本地脚本远程执行#\n\n把上例的命令写入脚本中，这里把变量$符号之前的转义符给去掉，因它不是在作为字符串传递给远程主机了。 vim remote_shell.sh\n\n\n\n * 把本地脚本拷贝到远程目录下，再通过ssh远程执行。\n\n\n\n输出：\n\n\n\n * 通过标准输入重定向的方式将命令传递到远程执行\n\n\n\n输出与上例是一致的，用此方法可以省去将脚本拷贝到远程主机这一步骤。\n\n\n8. 信号处理#\n\n\n8.1 Linux信号#\n\n使用kill -l可以查看当前系统支持的信号列表。\n\n\n\n其中最常用的是\n\n\n\n进程可以通过三种方式来响应一个信号：\n\n * 1）缺省操作，Linux对每种信号都规定了默认行为，一般是中断进程。\n * 2）捕捉信号，自定义函数进行处理。\n * 3）忽略信号，即对信号不做任何处理，其中有两个信号不能忽略：SIGKILL及SIGSTOP。\n\n\n8.2 信号的发送和接收#\n\n信号的来源是多样化的，通过kill\n-l查看信号名称大概可以看到有来源于键盘，有来源于电源，有来源于时钟等等，信号的接收是默认状态的，对于信号的处理linux也规定了默认动作。\n在程序本身中，我们也可以自定义发送和捕捉信号，自定义处理捕捉后的行为。\n\n8.2.1 trap 捕捉信号。#\n\ntrap用于捕捉信号\n\n用法： trap [-lp] [[arg] sigspec ...]\n\n * trap \"commands\" signals\n   捕捉到signals，执行commands，signals是信号列表，多个信号用空格分开。commands可以是一条Linux指定，也可以是自定义的函数。\n   如下示例，trap捕捉INT,HUP,QUIT三个信号，捕捉到后打印Catch Ctrl+C,QUIT!，然后执行exit退出进程。\n   \n   test@test-PC:~/work/study/shell/share$ vi trap1.sh\n   \n   \n   \n   trap捕捉后的处理是采用了echo和exit两个指令组合，也可以改为在自定义函数中处理。如下,定义catch_singal来替换commands指定，在\n   函数中可以做更复杂的处理过程。\n   \n   \n   \n   在上述脚本执行过程中，按下键盘Ctrl+Z，或者执行kill -1 <PID>或者kill -3 <PID>发送信号， 脚本捕捉到信号后做出处理。\n   \n   \n\n * trap \"\" signals:\n   忽略信号signals，即捕捉到信号，不做处理，屏蔽掉缺省的行为。注意：SIGKILL,SIGSTOP不能被忽略，缺省的操作必定执行。 仍然用上例，\n   \n   \n   \n   任凭如何按Ctrl+C，进程都要执行完毕才退出。\n   \n   \n   \n   当然，你也可以在trap \"\"的打印一段信息，表示已接收到信号，如trap \"echo 'Catch Ctrl+C,but ignore it.'\"\n   INT HUP QUIT，然后再次执行，进程接收到了键盘中断信号，但是不鸟它，就是这么豪横。\n   \n   \n\n * trap signals: 恢复信号的默认行为。\n   信号可以在进程的开头部分进行忽略，保证进程的关键操作能够不受影响得以完成，也可以中间部分恢复信号的默认行为，保证进程能够正常接收处理信号 。\n   test@test-PC:~/work/study/shell/share$ vi trap3.sh\n   \n   \n   \n   执行前三次打印，发送中断信号无效，第四打印，中断信号成功。\n   \n   \n\n * trap -p signal: 把当前的trap设置打印出来。\n\n * trap -l:打印系统支持的信号列表。同kill -l。\n\n * trap \"commands\" EXIT:脚本退出时执行commands指定的命令。\n\n * trap \"commands\" RETURN:当从shell函数返回、或者使用source命令执行另一个脚本文件时，执行commands指定的命令。\n\n8.2.2 kill 发送信号。#\n\nkill:发送信号 用法 ：kill[-ssignal|-p][-a]pid...\n\n> -s 指定发送的信号. 信号可以以信号名或数字的方式给定。 -p 指定 kill 只打印命名进程的进程标识 (pid) , 而不应发送给它信号。 -l\n> 打印信号名的列表.这可以在 /usr/include/linux/signal.h 中找到。 pid ... 给 kill 指定一个该发信号的进程列表。\n\n * kill <signal> <pids>: 发送kill和接收trap信号时，signal可以使用信号名或数字，\n   信号名可以带前缀SIG,如SIGHUP，也可以不带，如HUP。pids进程ID可为多个，用空格分隔。\n   最常用的发送SIGKILL信号来杀死进程,通过命令的返回码$?判断是否执行成功，成功则为0，否则失败。\n   \n   \n\n * kill pid： kill不带信号名或数字，则发送(15)SIGTERM信号，默认中断进程。\n\n * kill -0 pid: 或kill -EXIT\n   pid，常用于查询进程在后台是否还在运行，通过命令的返回码$?来判断，如果$?为0说明进程还在，否则，进程已经退出。\n   \n   \n\n\n8.3 进程通过信号通信#\n\n练习信号通信，使用一个自定义信号SIGUSR1来给守护进程增加一个退出机制。通过自定义函数，保证程序做完清理，然后安全的退出。\ntest@test-PC:~/work/study/shell/share$ vi server.sh\n\n\n\n写一个客户端进程，专门用来安全停止server.sh服务进程。\n\n\n\nstopserver.sh执行结果：\n\n\n\nserver.sh执行结果：\n\n","routePath":"/编程基础/Shell/Shell进程控制","lang":"","toc":[{"text":"1. 进程调用无处不在","id":"1-进程调用无处不在","depth":2,"charIndex":3},{"text":"2. 脚本的调用","id":"2-脚本的调用","depth":2,"charIndex":334},{"text":"3. 进程的后台处理","id":"3-进程的后台处理","depth":2,"charIndex":1005},{"text":"3.1 进程后台运行","id":"31-进程后台运行","depth":3,"charIndex":1019},{"text":"3.2 查询后台进程","id":"32-查询后台进程","depth":3,"charIndex":1209},{"text":"3.3 恢复后台进程","id":"33-恢复后台进程","depth":3,"charIndex":1352},{"text":"4. 守护进程","id":"4-守护进程","depth":2,"charIndex":1487},{"text":"5. 进程的并发控制","id":"5-进程的并发控制","depth":2,"charIndex":2238},{"text":"5.1 一个简单的并发例子","id":"51-一个简单的并发例子","depth":3,"charIndex":2252},{"text":"5.2 Shell进程的同步机制","id":"52-shell进程的同步机制","depth":3,"charIndex":2411},{"text":"5.3 多进程并发","id":"53-多进程并发","depth":3,"charIndex":2621},{"text":"6. 进程间通信","id":"6-进程间通信","depth":2,"charIndex":2830},{"text":"6.1 匿名管道","id":"61-匿名管道","depth":3,"charIndex":3049},{"text":"6.2 命名管道","id":"62-命名管道","depth":3,"charIndex":3376},{"text":"6.3 普通文件传递消息","id":"63-普通文件传递消息","depth":3,"charIndex":4134},{"text":"7. 进程的远程调用","id":"7-进程的远程调用","depth":2,"charIndex":4435},{"text":"7.1 进程执行简单命令","id":"71-进程执行简单命令","depth":3,"charIndex":4717},{"text":"7.2 进程执行多条命令组合","id":"72-进程执行多条命令组合","depth":3,"charIndex":4946},{"text":"7.3 本地脚本远程执行","id":"73-本地脚本远程执行","depth":3,"charIndex":5315},{"text":"8. 信号处理","id":"8-信号处理","depth":2,"charIndex":5507},{"text":"8.1 Linux信号","id":"81-linux信号","depth":3,"charIndex":5518},{"text":"8.2 信号的发送和接收","id":"82-信号的发送和接收","depth":3,"charIndex":5703},{"text":"8.2.1 `trap` 捕捉信号。","id":"821-trap-捕捉信号","depth":4,"charIndex":-1},{"text":"8.2.2 `kill` 发送信号。","id":"822-kill-发送信号","depth":4,"charIndex":-1},{"text":"8.3 进程通过信号通信","id":"83-进程通过信号通信","depth":3,"charIndex":7600}],"domain":"","frontmatter":{"Author":"海针 - 搬运"},"version":""},{"id":91,"title":"Shell风格指南","content":"#\n\n\n1. 引言#\n\n\n1.1. 目的#\n\n本规范用于指导Shell脚本编写人员，统一编码风格，提升代码的易读性和健壮性。\n\n本规范不能替代ShellCheck等静态检查工具，请在提升代码前使用ShellCheck进行静态检查。\n\n\n1.2. 说明#\n\n本规范中条目分为如下三个级别：\n\n【强制】必须遵守的编码规范，新增代码必须严格按照规范编写，历史代码根据项目实际情况决定是否修改。\n\n【建议】建议遵守的编码规范，根据代码所处上下文决定编码风格，但需要保持在同一项目中统一风格。\n\n【注意】编码过程中的注意事项，通常为容易出现缺陷的代码，应当用合理的编码方式进行替代。\n\n\n2. 环境#\n\n\n2.1. STDOUT vs STDERR#\n\n【建议】所有的错误信息都应该被导向STDERR。\n\n推荐使用类似如下函数，将错误信息和其他状态信息一起打印出来。\n\n\n\n\n3. 注释#\n\n\n3.1. 文件头注释#\n\n【强制】可执行文件首行必须指定脚本解释器，通常以 #!/bin/bash 开始。\n\n【强制】每个文件必须包含一个顶层注释，对其内容进行简要概述。\n\n【建议】脚本中尽量使用英文注释，防止切换系统环境后出现中文乱码问题。\n\n如果脚本仅限于公司内部使用，那么版权声明和作者信息是可选的。如果用于版本发布，那么至少要在头文件中携带版权声明。\n\n示例：不带版权声明\n\n\n\n示例：带版权声明\n\n\n\n\n3.2. 函数定义注释#\n\n【强制】任何不是既明显又短的函数都必须被注释。\n\n其他人通过阅读注释（和帮助信息，如果有的话）就能够学会如何使用你的程序或库函数，而不需要阅读代码。所有的函数注释应该包含：\n\n * 函数的描述\n\n * 全局变量的使用和修改\n\n * 使用的参数说明\n\n * 返回值，而不是上一条命令运行后默认的退出状态\n\n例如：\n\n\n\n\n3.3. 代码体注释#\n\n【强制】注释代码中含有技巧、不明显、有趣的或者重要的部分。\n\n如果有一个复杂的算法或者你正在做一些与众不同的，放一个简单的注释。并非注释所有代码。\n\n\n3.4. TODO注释#\n\n【强制】使用TODO注释临时的、短期解决方案的、或者足够好但不够完美的代码。\n\nTODO应当为全部大写字符串，接着是括号中你的名字。冒号是可选的。最好在TODO条目之后加上 bug或者ticket 的序号。\n\n例如：\n\n\n\n\n4. 格式#\n\n\n4.1. 缩进#\n\n【强制】缩进为4个空格，禁止使用TAB制表符来代替空格。 \n\n【建议】对于已有文件，或者从第三方开源获取的文件，保持已有的缩进格式。\n\n【建议】在代码块之间请使用空行以提升可读性。 \n\n\n4.2. 行的长度#\n\n【强制】行的最大长度为120个字符。\n\n如果你必须写长度超过120个字符的字符串，如果可能的话，尽量使用here\ndocument或者嵌入的换行符。长度超过120个字符的文字串且不能被合理地分割，这是正常的。但强烈建议找到一个方法使其变短。\n\n\n\n\n4.3. 管道#\n\n【建议】如果一行容不下整个管道操作，那么请将整个管道操作分割成每行一个管段。如果一行容得下整个管道操作，那么请将整个管道操作写在同一行。\n\n否则，应该将整个管道操作分割成每行一个管段，管道操作的下一部分应该将管道符放在新行并且缩进4个空格。这适用于使用管道符’|’的合并命令链以及使用’||’和’&&\n’的逻辑运算链。\n\n\n\n\n4.4. 循环#\n\n【强制】将 ; do , ; then 和 while , for , if 放在同一行。\n\nshell中的循环略有不同，但是我们遵循跟声明函数时的大括号相同的原则。也就是说， ; do , ; then 应该和 if/for/while 放在同一行。\nelse 应该单独一行，结束语句应该单独一行并且跟开始语句垂直对齐。\n\n例如：\n\n\n\n\n4.5. case语句#\n\n【强制】可选项与case关键字首字母对齐。\n\n【强制】操作命令表达式和 ;; 符号缩进4个空格， ;; 与操作命令表达式左对齐。\n\n【强制】可选项与右圆括号之间不能有空格。\n\n【建议】通常情况下，可选项，操作命令表达式和 ;; 符号在不同的行。如果整个表达式可读，简单的命令可以跟可选项和 ;; 写在同一行，但可选项右圆括号之后和结束符\n;; 之前各需要一个空格。\n\n示例：\n\n\n\n只要整个表达式可读，简单的命令可以跟可选项和 ;; 写在同一行。这通常适用于单字母选项的处理。也可以将选项与命令放一行，而 ;;\n单独放一行。无论哪种写法，必须保证在同一case语句中的语法风格一致，同时选项，括号与 ;; 使用一个空格分隔。\n\n示例：选项、命令和 ;; 写在同一行。\n\n\n\n示例：选项和命令写在一行， ;; 单独一行。\n\n\n\n\n4.6. 变量扩展#\n\n【强制】如果变量值是系统路径，那么${var} 必须用双引号引起来。\n\n【建议】引用变量，推荐用 ${var} 而不是 $var 。\n\n【建议】除非绝对必要或者为了避免困惑，否则不要用大括号将单个字符的shell特殊变量或定位变量括起来。推荐将其他所有变量用大括号括起来。\n\n示例：当位置参数超过10个时，对于第10个及以上参数变量的引用必须大括号括起来\n\n\n\n示例：单字符的特殊变量或小于10的位置变量，不建议用大括号括起来\n\n\n\n示例：为避免困惑用大括号括起来\n\n\n\n示例：包含路径的变量用引号引起来\n\n\n\n\n5. 命名约定#\n\n\n5.1. 文件名#\n\n【强制】文件名使用小写字母，单词之间用下划线分隔。\n\n【建议】作为可执行程序入口脚本，脚本名称不带.sh后缀，对于库函数文件名，脚本名称需带.sh后缀。\n\n\n5.2. 变量名#\n\n5.2.1. 常量和环境变量#\n\n【强制】常量和环境变量全部大写，单词用下划线分隔，声明在文件顶部，文件头注释之下。\n\n\n\n5.2.2. 只读变量#\n\n【建议】使用 readonly 或者 declare -r 来确保变量只读。\n\n因为全局变量在shell中广泛使用，所以在使用它们的过程中捕获错误是很重要的。当你声明了一个变量，希望其只读，那么请明确指出。\n\n\n\n5.2.3. 本地变量#\n\n【强制】使用 local 来声明局部变量以确保其只在函数内部和子函数中可见。这避免了污染全局命名空间和不经意间设置可能具有函数之外重要性的变量。\n\n【强制】当赋值的值由命令替换提供时，声明和赋值必须分开。因为内建的 local 不会从命令替换中传递退出码，会导致set -e设置不生效。\n\n\n\n\n5.3. 函数名#\n\n【强制】函数名全部使用小写字母，单词之间用下划线分隔。\n\n【强制】函数名之后必须有小括号。\n\n【建议】定义函数的关键function是可选的，但必须在一个项目中保持一致。\n\n【建议】定义函数体的左大括号可以和函数名在同一行，也可以另起一行，但必须在一个项目中保持一致。\n\n【建议】函数名的定义尽量可以反映出函数的功能，即通过函数名可知道函数的作用，因此函数名中的单词不建议使用缩写。\n\n\n5.4. 函数使用#\n\n【强制】将文件中所有的函数一起放在常量下面。不要在函数之间隐藏可执行代码。\n\n只有source， set 声明和常量设置可能在函数声明之前完成。不要在函数之间隐藏可执行代码。\n\n【强制】对于独立完成一个功能的脚本，入口主程序放入一个称为main的函数，作为脚本最下面的函数，文件中最后的非注释行应该是对 main 函数的调用。\n\n\n\n【建议】每个函数尽可能只处理一个小功能，代码量在100行以内，超出行数建议分拆。\n\n【建议】多次反复调用的代码建议独立成函数，简化程序，使条理更清晰。\n\n\n6. 命令调用#\n\n\n6.1. 内建命令和外部命令#\n\n【强制】对于shell内建命令和外部程序之间选择，优先选择内建命令。\n\n例如：\n\n\n\n\n6.2. 检查返回值#\n\n【强制】命令及表达式的使用，总是检查返回值，并根据返回值做出响应。\n\n对于非管道命令，使用 $? 或直接通过一个 if 语句来检查以保持其简洁。如果判断逻辑简单并且处理代码简短也可以使用[[...]]结合&&和||在一行中处理。\n\n例如：\n\n\n\nBash 也有 PIPESTATUS 变量，允许检查从管道所有部分返回的代码。如果仅仅需要检查整个管道是成功还是失败，以下的方法是可以接受的：\n\n\n\n但是在运行任何其他命令时， PIPESTATUS 将会被覆盖。如果你需要基于管道中发生的错误执行不同的操作，那么你需要在运行命令后立即将 PIPESTATUS\n赋值给另一个变量。\n\n\n\n\n7. 语句#\n\n\n7.1. 命令替换#\n\n【强制】运行命令使用$(command)而不是反引号。\n\n嵌套的反引号要求用反斜杠转义内部的反引号。而 $(command) 形式嵌套时不需要改变，而且更易于阅读。\n\n例如：\n\n\n\n\n7.2. 文件名的通配符扩展#\n\n【强制】当进行文件名的通配符扩展时，请使用明确的路径。\n\n因为文件名可能以 - 开头，所以使用扩展通配符 ./* 比 * 来得安全得多。\n\n\n\n\n7.3. test,[和[[#\n\n【建议】推荐使用 [[ ... ]] ，而不是 [ , test , 和 /usr/bin/[ 。\n\n因为在 [[ 和 ]] 之间不会有路径名称扩展或单词分割发生，所以使用 [[ ... ]] 能够减少错误。而且 [[ ... ]] 允许正则表达式匹配，而 [\n... ] 不允许。\n\n\n\n\n7.4. 测试字符串#\n\n【建议】Bash足以在测试中处理空字符串，请使用-z或者-n字符串测试，而不是填充字符，使得代码更易于阅读。\n\n\n\n\n7.5. 管道导向while循环#\n\n【注意】命令输出通过管道导向给while循环，在while循环中被修改的变量是不能传递给父shell的，因为循环命令是在一个子shell中运行的。\n\n管道导向while循环中的隐式子shell使得追踪bug变得很困难。\n\n\n\n如果你确定输入中不包含空格或者特殊符号（通常意味着不是用户输入的），那么可以使用一个for循环。\n\n\n\n使用过程替换允许重定向输出，但是请将命令放入一个显式的子shell中，而不是bash为while循环创建的隐式子shell。\n\n\n\n\n7.6. $@与$的使用#\n\n【建议】请使用 $@ 除非你有特殊原因需要使用 $* 。\n\n当变量引用加上双引号时，使用 \"$*\" ， 会将所有参数组合一个字符串参数， 而 \"$@\"\n保留参数状态，如果某个参数中包含空格，该空格是以字符的形态作为参数的一部分。\n\n","routePath":"/编程基础/Shell/Shell风格指南","lang":"","toc":[{"text":"**1.** *引言*","id":"1-引言","depth":2,"charIndex":-1},{"text":"**1.1.** **目的**","id":"11-目的","depth":3,"charIndex":-1},{"text":"**1.2.** **说明**","id":"12-说明","depth":3,"charIndex":-1},{"text":"2. **环境**","id":"2-环境","depth":2,"charIndex":-1},{"text":"2.1. **STDOUT** **vs STDERR**","id":"21-stdout-vs-stderr","depth":3,"charIndex":-1},{"text":"3. **注释**","id":"3-注释","depth":2,"charIndex":-1},{"text":"3.1. **文件头注释**","id":"31-文件头注释","depth":3,"charIndex":-1},{"text":"3.2. **函数定义注释**","id":"32-函数定义注释","depth":3,"charIndex":-1},{"text":"3.3. **代码体注释**","id":"33-代码体注释","depth":3,"charIndex":-1},{"text":"3.4. **TODO注释**","id":"34-todo注释","depth":3,"charIndex":-1},{"text":"4. **格式**","id":"4-格式","depth":2,"charIndex":-1},{"text":"4.1. **缩进**","id":"41-缩进","depth":3,"charIndex":-1},{"text":"4.2. **行的长度**","id":"42-行的长度","depth":3,"charIndex":-1},{"text":"4.3. **管道**","id":"43-管道","depth":3,"charIndex":-1},{"text":"4.4. **循环**","id":"44-循环","depth":3,"charIndex":-1},{"text":"4.5. **case语句**","id":"45-case语句","depth":3,"charIndex":-1},{"text":"4.6. **变量扩展**","id":"46-变量扩展","depth":3,"charIndex":-1},{"text":"5. **命名约定**","id":"5-命名约定","depth":2,"charIndex":-1},{"text":"5.1. **文件名**","id":"51-文件名","depth":3,"charIndex":-1},{"text":"5.2. **变量名**","id":"52-变量名","depth":3,"charIndex":-1},{"text":"5.2.1. **常量和环境变量**","id":"521-常量和环境变量","depth":4,"charIndex":-1},{"text":"5.2.2. **只读变量**","id":"522-只读变量","depth":4,"charIndex":-1},{"text":"5.2.3. **本地变量**","id":"523-本地变量","depth":4,"charIndex":-1},{"text":"5.3. **函数名**","id":"53-函数名","depth":3,"charIndex":-1},{"text":"5.4. **函数使用**","id":"54-函数使用","depth":3,"charIndex":-1},{"text":"6. **命令调用**","id":"6-命令调用","depth":2,"charIndex":-1},{"text":"6.1. **内建命令和外部命令**","id":"61-内建命令和外部命令","depth":3,"charIndex":-1},{"text":"6.2. **检查返回值**","id":"62-检查返回值","depth":3,"charIndex":-1},{"text":"7. **语句**","id":"7-语句","depth":2,"charIndex":-1},{"text":"7.1. **命令替换**","id":"71-命令替换","depth":3,"charIndex":-1},{"text":"7.2. **文件名的通配符扩展**","id":"72-文件名的通配符扩展","depth":3,"charIndex":-1},{"text":"7.3. **test,[和[[**","id":"73-test和","depth":3,"charIndex":-1},{"text":"7.4. **测试字符串**","id":"74-测试字符串","depth":3,"charIndex":-1},{"text":"7.5. **管道导向while循环**","id":"75-管道导向while循环","depth":3,"charIndex":-1},{"text":"7.6. **$@与$的使用**","id":"76-与的使用","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"Author":"海针 - 搬运 Google开源项目风格指南之《Shell风格指南》"},"version":""},{"id":92,"title":"编程基础-章节预览","content":"","routePath":"/编程基础/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"编程基础-章节预览"},"version":""},{"id":93,"title":"CSS 基础","content":"#\n\n\nCSS 简介#\n\nCSS（层叠样式表，Cascading Style Sheets）是一种用于描述 HTML 或 XML（包括如 SVG、MathML 等各种 XML\n方言）文档样式的样式表语言。CSS 描述了如何将结构化文档（例如 HTML 文档或 XML 应用）呈现在屏幕、纸质、语音或其他媒体上。简单地说，CSS\n用于控制网页元素的布局和外观。\n\nCSS 在网页设计和开发中扮演着至关重要的角色：\n\n * 美化网页： CSS 能够使网页更加美观，通过样式定义，可以创建具有吸引力的布局和设计，提升用户体验。\n * 布局控制： CSS 提供了一系列的布局技术，如 Flexbox 和\n   Grid，允许开发者创建复杂的页面布局，这些布局在不同的设备和屏幕尺寸上都能保持一致性和响应性。\n * 提高网站的可维护性： 通过将样式与内容分离，CSS 使得网站的维护变得更加简单。更新网站风格时，只需修改样式表，而不必触及 HTML 代码。\n\n\nCSS 语法#\n\nCSS 语法由一个由花括号包围的声明块组成，该声明块前面是一个选择器。选择器指向你想要样式化的 HTML 元素，而声明块包含一个或多个由分号分隔的 CSS\n声明。\n\nCSS 规则的结构，一个 CSS 规则通常由以下两部分组成：\n\n 1. 选择器（Selector）： 指定要应用样式的 HTML 元素。\n    1. 用于定位到 HTML 文档中的元素。选择器可以是元素名称、类（.前缀）、ID（#前缀）或更复杂的组合，比如属性选择器、伪类等。\n 2. 声明块（Declaration Block）： 包含一个或多个声明，每个声明是一个属性 - 值对。\n    1. 属性: 要改变 HTML 元素的样式，你需要指定 CSS 属性，比如color、font-size、margin等\n    2. 值: 为属性分配的值，比如red、12px、1em等。值决定了属性如何影响所选元素。\n\nCSS 属性定义了如何渲染 HTML 元素。以下是一些常用的 CSS 属性：\n\n * color: 设置文本颜色。\n * font-size: 设置字体大小。\n * background-color: 设置背景颜色。\n * margin: 设置元素的外边距。\n * padding: 设置元素的内边距。\n * border: 设置元素的边框。\n * width, height: 设置元素的宽度和高度。\n * display: 设置元素的显示类型（如block, inline, none等）。\n * float: 设置元素的浮动布局。\n * position: 设置元素的定位方式（如static, relative, absolute, fixed）。\n\nCSS 值定义了属性的具体设置。以下是不同类型的 CSS 值：\n\n * 颜色值：如red, #ff0000, rgb(255,0,0)。\n * 长度值：如10px, 2em, 50%。\n * 字符串值：如\"Open Sans\", \"Arial\"（用于font-family）。\n * 数值值：如100, 2.5（用于line-height, z-index等）。\n * 函数值：如url('path/to/image.jpg')（用于background-image）\n\n一个简单的例子\n\n\n\n\n选择器#\n\n\n基础选择器#\n\nCSS 选择器用于定位 HTML 文档中的元素，以便应用样式。\n\n元素选择器#\n\n选择所有相同类型的元素。\n\n基本写法\n\n\n\n应用例子\n\n * 所有的<p>标签都应用了样式\n\n\n\n\n\n类选择器#\n\n选择所有具有相同类名的元素。类名前有一个点（.）。\n\n写法\n\n\n\n应用例子\n\n\n\n\n\nID选择器#\n\n选择具有特定 ID 的单一元素。ID 名前有一个井号（#）\n\n写法\n\n\n\n应用例子\n\n\n\n\n\n\n复合选择器#\n\n后代选择器#\n\n选择一个元素内部的所有匹配的后代元素。\n\n\n\n给div标签下所有的p标签应用样式，多级的p标签也会应用样式。\n\n\n\n\n\n子选择器#\n\n选择一个元素直接子代的匹配元素。\n\n\n\n给div下所有p标签应用样式\n\n相邻兄弟选择器#\n\n选择紧跟在指定元素后面的匹配元素。\n\n\n\n\n\n\n\n一般兄弟选择器#\n\n选择在指定元素后面的所有匹配的兄弟元素。\n\n\n\n\n\n\n\n属性选择器#\n\n选择具有特定属性或属性值的元素。\n\n[attribute]选择所有具有指定属性的元素，不论该属性的值是什么。\n\n\n\n这将选择所有具有type属性的input元素，并应用蓝色文本。\n\n[attribute=value]选择所有具有指定属性且属性值恰好等于给定值的元素。\n\n\n\n这将选择所有type属性值为text的input元素，并为其添加黑色边框。\n\n[attribute~=value]选择所有具有指定属性且属性值为以空格分隔的一系列值中包含给定值的元素。\n\n\n\n这将选择所有class属性值中包含单词example的div元素，并设置其背景颜色为黄色。\n\n[attribute|=value]选择所有具有指定属性且属性值是以给定值开头的元素，或者属性值是给定值，后面紧跟着一个连字符-。\n\n\n\n这将选择所有lang属性值为en或以en-开头的p元素，并将其字体设置为斜体。\n\n[attribute^=value]选择所有具有指定属性且属性值以给定值开头的元素。\n\n\n\n这将选择所有href属性值以https开头的a元素，并在其背景上显示一个锁形图标。\n\n[attribute$=value]选择所有具有指定属性且属性值以给定值结尾的元素。\n\n\n\n这将选择所有src属性值以.png结尾的img元素，并为其添加圆角边框。\n\n[attribute*=value]选择所有具有指定属性且属性值中包含给定值的元素。\n\n\n\n这将选择所有title属性值中包含单词chapter的li元素，并将其文本设置为粗体。\n\n[attribute operator value i]这是一个带有i修饰符的属性选择器，它用于表示选择时不区分大小写。\n\n\n\n这将选择所有href属性值为example.com的a元素，不论其大小写如何，并将其文本颜色设置为绿色。\n\n\n组合选择器#\n\n上面选择器可以自由组合，从而创建更复杂的选择器来精确匹配特点的元素\n\n\n\n这将选择所有type属性为submit且具有button类的input元素，并设置其填充为 10 像素。\n\n\n应用选择器的例子#\n\n\n\n\n\n\nCSS常用属性#\n\n\n常用字体属性#\n\n * font-family 字体类型 宋体、⿊体、⾪书、楷体\n\n * font-size 22px\n\n * font-style 字体的⻛格 normal | intalic | oblique | inherit 默认值、斜体、倾斜、继承\n\n * font-weight 粗细程度 100-900 | bold | bolder | lighter | normal 数值、粗体、更粗、更细、默认\n\n\n常用文本属性#\n\n\n\n\n常用颜色属性#\n\n * color 设置颜⾊\n * background-color 背景颜⾊\n * background-image 背景图⽚\n * background-repeat no-repeat | repeat-x|repeat-y 不重复 横向重复 纵向重复 横向重复\n\n\nHTML中引入CSS的方式#\n\n\n内联方式#\n\n直接在标签中的 style 属性中添加 css\n\n\n\n\n嵌入方式#\n\n在HTML的<head>标签中的<style>标签中写下CSS代码，根据CSS中的选择器来使用到样式\n\n\n\n\n连接引入方式#\n\n在HTML的<head>标签中直接引入外部的css文件\n\n * 本地的css文件\n * 网上的css文件\n\n","routePath":"/编程基础/前后端/CSS基础","lang":"","toc":[{"text":"CSS 简介","id":"css-简介","depth":2,"charIndex":3},{"text":"CSS 语法","id":"css-语法","depth":2,"charIndex":425},{"text":"选择器","id":"选择器","depth":2,"charIndex":1405},{"text":"基础选择器","id":"基础选择器","depth":3,"charIndex":1412},{"text":"元素选择器","id":"元素选择器","depth":4,"charIndex":1453},{"text":"类选择器","id":"类选择器","depth":4,"charIndex":1512},{"text":"ID选择器","id":"id选择器","depth":4,"charIndex":1562},{"text":"复合选择器","id":"复合选择器","depth":3,"charIndex":1618},{"text":"后代选择器","id":"后代选择器","depth":4,"charIndex":1626},{"text":"子选择器","id":"子选择器","depth":4,"charIndex":1694},{"text":"相邻兄弟选择器","id":"相邻兄弟选择器","depth":4,"charIndex":1737},{"text":"一般兄弟选择器","id":"一般兄弟选择器","depth":4,"charIndex":1772},{"text":"属性选择器","id":"属性选择器","depth":4,"charIndex":1810},{"text":"组合选择器","id":"组合选择器","depth":3,"charIndex":2591},{"text":"应用选择器的例子","id":"应用选择器的例子","depth":3,"charIndex":2691},{"text":"CSS常用属性","id":"css常用属性","depth":2,"charIndex":2707},{"text":"常用字体属性","id":"常用字体属性","depth":3,"charIndex":2718},{"text":"常用文本属性","id":"常用文本属性","depth":3,"charIndex":2930},{"text":"常用颜色属性","id":"常用颜色属性","depth":3,"charIndex":2942},{"text":"HTML中引入CSS的方式","id":"html中引入css的方式","depth":2,"charIndex":3087},{"text":"内联方式","id":"内联方式","depth":3,"charIndex":3104},{"text":"嵌入方式","id":"嵌入方式","depth":3,"charIndex":3139},{"text":"连接引入方式","id":"连接引入方式","depth":3,"charIndex":3201}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"Django基础知识","content":"#\n\n\n1. Python web框架要点#\n\n\n1.1 web应用程序流程#\n\n\n\n\n1.1 web程序框架的意义#\n\n 1. 搭建web应用程序\n 2. 免去不同web应用相同代码部分的重复编写，只需关心web应用核心的业务逻辑实现\n\n\n1.2 web应用程序本质#\n\n1.3.1接收并解析HTTP请求，获取具体的请求信息#\n\n服务器端接收到客户端（通常是浏览器）通过网络发送的HTTP请求，这个请求中包含了请求方法（GET、POST等）、请求头（携带了客户端信息、接受的数据类型等）、请\n求参数（URL中的查询字符串或POST请求的数据体）等信息。\n\n1.3.2处理本次HTTP请求，即完成本次请求的业务逻辑处理#\n\n根据请求的具体内容，Web应用执行相应的业务逻辑处理。这可能涉及到数据库操作、计算、调用外部API、验证用户身份等多种操作。\n\n1.3.3构造并返回处理结果--HTTP响应#\n\n处理完业务逻辑后，服务器需要构造一个HTTP响应，该响应包括状态码（如200表示成功，404表示未找到等）、响应头（指示内容类型、编码方式等）以及响应体（通常是\nHTML页面、JSON数据或其他格式的内容）。这个响应会被发送回客户端，展示或进一步处理。\n\n\n1.3 web框架学习要点#\n\n1.4.1如何搭建工程#\n\n * 工程组建\n\n * 工程配置\n\n * 路由定义\n\n * 试图函数定义\n\n1.4.2如何获取请求数据#\n\n获取请求数据是处理HTTP请求的关键部分，不同的请求类型（GET、POST等）和数据传输方式（查询字符串、表单数据、JSON数据等）有不同的获取方法。以下是几种\n常见情况下的数据获取方式：\n\n对于GET请求：\n\n * 查询字符串参数：不论是Flask还是Django，你可以通过框架提供的请求对象轻松访问。在Flask中使用request.args.get('parame\n   ter_name')，在Django中使用request.GET.get('parameter_name')来获取特定的查询参数值。如果参数不存在，.ge\n   t()方法会返回None或你指定的默认值。\n\n对于POST请求：\n\n * 表单数据：当表单通过application/x-www-form-urlencoded或multipart/form-data编码发送时，可以使用类似的方\n   式获取数据。在Flask中，利用request.form['parameter_name']；Django中则是request.POST['paramet\n   er_name']。注意，尝试访问不存在的键会抛出异常，因此推荐使用.get()方法来避免错误。\n\n * JSON数据：现代Web应用中，客户端经常发送JSON格式的数据，尤其是在API接口中。在Flask中，可以直接使用request.get_json()来\n   获取整个JSON数据，或者request.json['key']访问具体键值；Django中则需要先将请求体解析为JSON，如import json;\n   data = json.loads(request.body)['key']。\n\n1.4.3如何构造响应数据#\n\n构造响应数据是Web应用程序开发中的另一个重要环节，它涉及到如何将服务器处理的结果组织成符合HTTP规范的格式并发送回客户端。\n\n无论使用哪种Web框架，构造响应数据的核心思路都是类似的：\n\n * 确定响应状态码：如200表示成功，404表示未找到等。\n\n * 设置响应头：如Content-Type来指明响应内容的类型。\n\n * 构建响应体：根据应用场景，可以是HTML、JSON、XML等格式的数据。\n\n * 发送响应：将上述信息组合并通过框架提供的方法发送给客户端。\n\neg:\n\nDjango（Python Web框架）\n\n在Django中，可以通过视图函数直接返回HttpResponse对象，或者使用JsonResponse来构造JSON响应：\n\n\n\nFlask（Python Web框架）\n\nFlask提供了简洁的API来构造响应：\n\n\n\n\n2. Django框架以及工作流程简单梳理#\n\n\n2.1 django介绍MVC和MVT#\n\n2.1.1 MVC模式#\n\neg：已查询数据库为例\n\n1）发送查询数据库请求到controll，controll处理请求\n\n2,3,4,5）controll请求model模块查询数据库，model查询数据库后将数据返回给controll\n\n6,7,8）controll请求view分装html，view将分装渲染后的数据返回给controll，再有controll发送给客户端\n\n从上述例子中不难看出：\n\n * control- 用于接收请求，处理业务逻辑，与model和view交互，返回结果\n\n * model主要分装对数据库的访问，对数据库数据进行增删改查\n\n * view用于分装结果，生成页面展示的htlm内容\n\n2.1.2 MVT模式#\n\n\n\n * mode- 与MVC中的M功能相同，负责和数据库交互\n\n * view与MVC中的C功能相同，接收请求，进行业务处理，返回应答\n\n * template与MVC中的V 功能相同，负责封装构造要返回的html\n\n\n3. 实操搭建django项目#\n\n\n3.1 虚拟环境搭建#\n\n建议使用Python的虚拟环境搭建自己的项目，优点：\n\n * 隔离性：虚拟环境允许你在独立的空间安装Python库和依赖项，而不会影响到系统全局或其他项目的环境。这样可以避免不同项目间依赖冲突的问题，确保每个项目运行\n   在预期的库版本上。\n\n * 可复现性：通过记录虚拟环境中安装的库及其版本，你可以很容易地在其他机器或团队成员之间复现相同的开发或运行环境，这对于团队协作和持续集成尤为重要。\n\n * 易于管理：虚拟环境使库的安装、升级和卸载变得更加简单和安全。你可以在特定的虚拟环境中自由实验，而不必担心破坏系统的Python安装或影响其他项目。\n\n * 清理方便：如果一个项目不再需要或者你想从头开始，只需删除对应的虚拟环境即可，这比手动卸载多个库要快速且彻底。\n\n * 多版本支持：虚拟环境允许你在同一台机器上安装和使用Python的不同版本。这对于需要特定Python版本的项目非常有用，也便于测试代码在不同Python版\n   本下的兼容性。\n\n * 环境配置文件：通常与虚拟环境一起使用的还有环境配置工具（如pipenv或conda），它们可以创建一个包含所有依赖的文件（如requirements.tx\n   t或environment.yml），使得环境的配置和分发更加自动化和标准化。\n\n * 提高开发效率：因为虚拟环境隔离了每个项目，所以你可以在不同项目间快速切换，无需担心依赖冲突导致的错误，从而提高了开发和调试的效率。\n\n总之，Python虚拟环境通过提供一个一致、可控制、易于维护的开发环境，显著提高了开发工作的灵活性、可靠性和协作效率。\n\n这里我们使用virtualenv，以下是搭建virtualenv虚拟环境的操作步骤：\n\n\n\n基本常见命令：\n\n\n\n\n3.2 创建django项目#\n\n3.2.1创建工程#\n\n命令： Django-admin startproject name\n\n\n\n * 拉起服务\n\nPython manage.py runserver name\n\n在uos虚拟机拉起Django服务，需要关闭防火墙，才能在主机访问\n\n3.2.2创建子应用#\n\n命令： python manager.py startapp name\n\n\n\n3.2.3注册子应用到工程中#\n\n * 注册的子应用虽然创建，但是和工程并无关联，需要注册安装才能使用\n\n * 在工程的配置文件setting.py中，INSTALLED_APPS列表保存了工程已经注册安装的子应用。\n\n * 注册安装一个子应用的方法是将子应用中的apps.py中的config类添加到INSTALLED_APPS列表中\n\n\n3.3 模型#\n\n3.3.1 ORM框架\n\nDjango的ORM（Object-Relationa-\nMapping，对象关系映射）框架是Django作为一个高级Web框架的核心组件之一，它提供了一种将数据库操作抽象化的方法，使得开发者可以用Python类和对象\n来操作数据库，而不是直接编写SQL语句。这样做有以下几个显著优点：\n\n * 代码简洁：Django\n   ORM允许开发者使用Python代码来定义数据库模型（即数据表结构），执行查询，更新数据等操作，从而减少了编写和维护原生SQL语句的工作量。\n\n * 数据库无关性：通过配置，Django ORM可以在多种数据库（如SQLite, PostgreSQL, MySQL,\n   Oracle等）之间切换，而不需要修改应用中的大部分代码，因为ORM会处理底层数据库之间的差异性。\n\n * 自动化的SQL管理：Django的ORM能自动生成并执行SQL语句来创建、修改、删除数据库表。当你更改模型定义后，使用makemigrations和mig\n   rate命令，Django会自动为你同步数据库结构变化。\n\n * 强大的查询API：Django提供了丰富的查询API，使得复杂的数据库查询可以通过链式调用和方法调用来完成，这不仅易于阅读和理解，也降低了出错的可能性。\n\n * 关系管理：Django ORM自动处理数据库中的关系（如一对一、一对多、多对多关系），并提供了方便的方法来访问和管理这些关联对象。\n\n * 数据验证：ORM模型可以定义字段的验证规则，确保在数据保存到数据库之前符合业务逻辑要求，提高了数据的一致性和完整性。\n\n * 性能优化：尽管ORM会带来一定的性能开销，但Django也提供了一些机制来优化查询性能，如选择性地使用.select_related()和.prefetc\n   h_related()减少数据库查询次数，或者利用.only()和.defer()只加载需要的字段数据。\n\n总的来说，Django的ORM框架极大地简化了Web开发中的数据库交互过程，提高了开发效率，并帮助开发者专注于业务逻辑的实现而非底层数据库操作。\n\n3.3.1 ORM对应关系#\n\n * model内嵌了ORM框架\n\n * 通过ORM 操作数据库\n\n\n\n\n\n3.3.2模型#\n\n 1. 在模型文件models.py中定义模型类\n\n\n\n 2. 模型迁移\n\npython3 manage.py makemigrations 生成迁移文件\n\n\n\npython3 manage.py migrate 迁移\n\n\n\n此时，如果你的数据库已经生成了对应的表格\n\n\n3.4 视图与URL#\n\n3.4.1视图#\n\n 1. 视图就是一个python函数\n 2. 函数的第一个参数就是 请求 和请求相关 是 HttpRequest的实例对象\n 3. 视图必须要返回一个响应 响应是HttpResponse的实例对象\n\n3.4.2 url匹配过程#\n\n\n\n详细过程：\n\n 1. 项目.urls: 通过 incloud方法引导到 应用的 urls\n\n 2. 应用.urls：\n\n\n\n 3. views.py：\n\n\n\n3.4.5 总结views和URL匹配流程#\n\n\n\n\n3.5 模板#\n\n3.5.1 模板大体工作流程#\n\n 1. 创建模板 （图1）\n 2. 设置模板查找路径 （图2）\n 3. 模板接受输入传入的数据 （图3）\n 4. 模板处理数据\n\n\n\n图1\n\n\n\n图2\n\n\n\n图3\n\n3.5.2总体流程图#\n\n","routePath":"/编程基础/前后端/Django基础知识","lang":"","toc":[{"text":"**1.** Python web框架要点","id":"1-python-web框架要点","depth":2,"charIndex":-1},{"text":"**1.1** web应用程序流程","id":"11-web应用程序流程","depth":3,"charIndex":-1},{"text":"**1.1** web程序框架的意义","id":"11-web程序框架的意义","depth":3,"charIndex":-1},{"text":"**1.2** web应用程序本质","id":"12-web应用程序本质","depth":3,"charIndex":-1},{"text":"1.3.1接收并解析HTTP请求，获取具体的请求信息","id":"131接收并解析http请求获取具体的请求信息","depth":4,"charIndex":136},{"text":"1.3.2处理本次HTTP请求，即完成本次请求的业务逻辑处理","id":"132处理本次http请求即完成本次请求的业务逻辑处理","depth":4,"charIndex":278},{"text":"1.3.3构造并返回处理结果--HTTP响应","id":"133构造并返回处理结果--http响应","depth":4,"charIndex":375},{"text":"**1.3** web框架学习要点","id":"13-web框架学习要点","depth":3,"charIndex":-1},{"text":"1.4.1如何搭建工程","id":"141如何搭建工程","depth":4,"charIndex":545},{"text":"1.4.2如何获取请求数据","id":"142如何获取请求数据","depth":4,"charIndex":597},{"text":"1.4.3如何构造响应数据","id":"143如何构造响应数据","depth":4,"charIndex":1337},{"text":"**2.** Django框架以及工作流程简单梳理","id":"2-django框架以及工作流程简单梳理","depth":2,"charIndex":-1},{"text":"**2.1** django介绍MVC和MVT","id":"21-django介绍mvc和mvt","depth":3,"charIndex":-1},{"text":"**2.1.1** MVC模式","id":"211-mvc模式","depth":4,"charIndex":-1},{"text":"**2.1.2** MVT模式","id":"212-mvt模式","depth":4,"charIndex":-1},{"text":"**3.** 实操搭建django项目","id":"3-实操搭建django项目","depth":2,"charIndex":-1},{"text":"**3.1** 虚拟环境搭建","id":"31-虚拟环境搭建","depth":3,"charIndex":-1},{"text":"**3.2** 创建django项目","id":"32-创建django项目","depth":3,"charIndex":-1},{"text":"3.2.1创建工程","id":"321创建工程","depth":4,"charIndex":3007},{"text":"3.2.2创建子应用","id":"322创建子应用","depth":4,"charIndex":3134},{"text":"3.2.3注册子应用到工程中","id":"323注册子应用到工程中","depth":4,"charIndex":3186},{"text":"**3.3** 模型","id":"33-模型","depth":3,"charIndex":-1},{"text":"3.3.1 ORM对应关系","id":"331-orm对应关系","depth":4,"charIndex":4270},{"text":"3.3.2模型","id":"332模型","depth":4,"charIndex":4324},{"text":"**3.4** 视图与URL","id":"34-视图与url","depth":3,"charIndex":-1},{"text":"3.4.1视图","id":"341视图","depth":4,"charIndex":4483},{"text":"3.4.2 url匹配过程","id":"342-url匹配过程","depth":4,"charIndex":4593},{"text":"3.4.5 总结views和URL匹配流程","id":"345-总结views和url匹配流程","depth":4,"charIndex":4690},{"text":"**3.5** 模板","id":"35-模板","depth":3,"charIndex":-1},{"text":"3.5.1 模板大体工作流程","id":"351-模板大体工作流程","depth":4,"charIndex":4726},{"text":"3.5.2总体流程图","id":"352总体流程图","depth":4,"charIndex":4826}],"domain":"","frontmatter":{"Author":"马涛涛"},"version":""},{"id":95,"title":"创建新文章","content":"Django进阶技巧#\n\n\n用户认证和权限#\n\n\n用户认证#\n\n用户认证是指确认用户声称的身份是否真实的过程，即验证用户名和密码是否匹配。在Django中，这一过程主要由django.contrib.auth应用处理。\n\ndjango.contrib.auth是Django框架中的一个核心应用，专门用于处理用户认证和授权相关的功能。这个应用提供了一整套解决方案，包括用户模型、认证\n视图、权限管理、会话管理等，使得开发者能够方便地实现用户注册、登录、权限控制等功能。下面是对django.contrib.auth几个关键组成部分的详细说明：\n\n * 用户模型(User Model)\n\nDjango默认提供了一个用户模型django.contrib.auth.models.User，这个模型包含了一些常用字段，如username、passwor\nd、email、first_name、last_name等，用于存储用户的基本信息。密码字段经过哈希处理，确保安全性。如果你有更复杂的需求，可以通过继承Abst\nractUser或AbstractBaseUser来自定义用户模型，像研测平台就是来继承AbstractUser来自定义我们自己的业务员需求。\n\n * 认证视图(Authentication Views)\n\nDjango提供了一系列内置的视图函数来处理常见的认证操作，如登录、注销、密码重置、密码更改等。这些视图位于django.contrib.auth.views模\n块中。例如，LoginView用于处理用户登录逻辑，而LogoutView则负责用户注销。开发者只需在URL配置中引用这些视图即可快速搭建认证流程。\n\n * 认证后端(Authentication Backends)\n\n认证后端决定了如何验证用户的凭证（如用户名和密码）。Django支持多种认证机制，并允许开发者自定义认证后端。默认情况下，Django使用ModelBacken\nd，它基于数据库中的用户模型进行认证。此外，还可以添加其他后端，比如LDAP、OAuth等，以支持不同的认证方式。\n\n\n\n通过设置多个认证后端，Django 会依次尝试这些后端来验证用户的登录信息，直到找到一个成功的认证后端或者所有后端都尝试失败。\n\n * 权限和组(Permissions and Groups)\n\nDjango提供了一套简单的权限系统，用于控制用户对模型（及其实例）的操作权限。每个模型都有三个默认的权限：“添加”、“修改”、“删除”。此外，可以为模型定义额\n外的自定义权限。用户可以被直接赋予这些权限，或者通过用户组间接赋予。Group模型允许将权限批量分配给多个用户，便于权限管理。\n\n * 会话管理(Session Management)\n\nDjango的会话系统允许服务器跟踪用户的状态。当用户登录后，会创建一个会话，其中可以存储用户信息。会话数据默认保存在数据库中，但也可以配置为保存在cookie\n或缓存中。会话系统处理登录状态保持、超时及安全性设置，如使用HTTPS-only cookie。\n\n * CSRF保护(CSRF Protection)\n\n跨站请求伪造（CSRF）是一种常见的网络攻击。django.contrib.auth还包含了对跨站请求伪造的防护机制，自动为每个POST请求生成并验证一个CSR\nF令牌，确保表单提交的安全性。\n\n * 密码管理(Password Management)\n\n * Django提供了密码重置和更改的完整工作流，包括发送密码重置邮件、生成一次性密码链接、验证密码等。这些功能通过视图和表单实现，简化了开发者的实现工作。\n\n * 综上所述，django.contrib.auth是Django框架安全性和用户管理的核心组件，其设计旨在简化开发者的工作，同时保证应用的安全性。\n\n\n权限管理#\n\n权限管理涉及决定已认证用户能够访问哪些资源或执行哪些操作。Django的权限系统分为基本权限和对象级权限。\n\n * 基本权限（Basic permissions）: 每个Django模型都可以定义一组全局权限，比如add_, change_,\n   delete_。这些权限自动添加到auth.permission表，并且可以分配给用户组或单独的用户。\n * 对象级权限（Object-level permissions）:\n   除了全局权限，Django也支持对具体对象实例的权限控制。这意味着可以限制用户仅能修改或删除他们自己的某些记录，而不是所有人的记录。这需要手动检查权限，通\n   常在视图函数中完成。\n * 组（Groups）: Django允许将用户分组，并给组分配权限。这样可以批量管理权限，提高效率。\n * 用户权限检查: 使用user.has_perm()方法可以检查用户是否具有某个权限。在模板中也可以使用{% if\n   perms.app_label.codename %}这样的标签来控制内容的显示。\n\n1.2.1在django中实现角色级别的权限控制#\n\n在Django中实现角色级别的权限控制，通常涉及创建自定义用户组，并给这些组分配特定的权限，然后将用户分配到对应的组中。以下是实现这一功能的步骤：\n\n * 1. 创建用户组并分配权限\n\n登录Django管理后台，在“用户权限”部分找到“用户组”(Groups)，创建新的用户组，比如\"管理员\"、\"编辑\"和\"普通用户\"。\n\n为每个组分配特定的权限。权限可以是预定义的模型权限（在模型的Meta类中定义）或自定义权限。在创建或编辑组时，可以找到权限分配的部分，选择适用于该角色的权限。\n\n * 2. 用户与组关联\n\n在添加或编辑用户时，将用户分配到一个或多个组中。这样，用户就继承了所属组的所有权限。\n\n * 3. 视图函数中的权限检查\n\n在视图中，除了直接检查用户的个人权限外，还可以检查当前用户所属的组是否具有执行某项操作的权限。这可以通过遍历用户所属的组并检查组的权限来实现。\n\n示例代码\n\n假设有一个视图需要管理员权限才能访问，可以这样做：\n\n\n\n 4. 自定义权限检查装饰器\n\n如果你频繁地使用某个特定的角色检查，可以创建自定义的装饰器来简化代码：\n\n\n\n1.3.1 在django中实现对象级别的权限控制#\n\n在django中要实现对象级别的权限控制，推荐使用第三方库：django-guardian：\n\n 1. 安装django-guardian：\n\n\n\n 1. 然后，在你的settings.py文件中将其添加到INSTALLED_APPS列表中：\n\n\n\n 1. 并确保配置AUTHENTICATION_BACKENDS：\n\n\n\n 1. 配置模型\n\n确保你的模型中已经定义了权限相关的元数据，尽管这不是必需的，但有助于理解权限的上下文。例如：\n\n\n\n 1. 分配对象权限\n\n你可以使用assign_perm函数给特定的用户或用户组分配对象级别的权限：\n\n\n\n 1. 检查对象权限\n\n在视图中，你可以使用get_perms或has_perm来检查用户是否有特定的对象权限：\n\n\n\n这样，你就可以在Django项目中灵活地实施对象级别的权限控制了。通过django-guardian，你可以精细地管理用户对各个模型实例的操作权限，增强应用的安\n全性和用户体验。\n\n\nRestFul API#\n\nRESTful API 是一种广泛采用的网络 API 设计指南，它利用了 REST（表述性状态转移）架构风格。RESTful API 通过使用标准的 HTTP\n方法来处理数据的 CRUD（创建、读取、更新、删除）操作，使得网络服务的开发和消费变得更加简单和高效。\n\n需要注意的是，RESTful API是一种接口风格，并不是代码框架，目的是统一网络接口的编写规范\n\n\nRESTful API 的核心概念#\n\n2.1.1 资源（Resources）#\n\n在 RESTful 架构中，一切都被视为资源。资源可以是文档、图片、视频，或者是任何可以命名的事物。每个资源都对应一个唯一的 URL。\n\n2.1.2 统一接口（Uniform Interface）#\n\nRESTful API 设计强调使用统一的接口进行资源的操作。这意味着所有的资源都通过相似的接口进行访问，使得用户可以无需了解底层实现，只需通过标准的 HTTP\n方法对资源进行操作。\n\n2.1.3 无状态（Stateless）#\n\nRESTful API 应该是无状态的，这意味着每次请求都包含了完成请求所需的所有信息，服务器不会在请求之间保存任何状态信息。\n\n2.1.4 可缓存（Cacheable）#\n\n响应应该被设计为可缓存的，这可以提高性能并减少服务器的负载。\n\n2.1.5 分层系统（Layered System）#\n\n在 RESTful 架构中，客户端通常不知道它是直接与终端服务器通信，还是通过一个或多个中间层。分层允许你插入缓存、负载均衡器等组件。\n\n\n设计原则#\n\n2.2.1 使用标准 HTTP 方法#\n\n * GET：用于检索资源。\n * POST：用于创建新的资源或触发资源上的处理。\n * PUT：用于更新资源或创建新资源。\n * DELETE：用于删除资源。\n\n2.2.2 资源命名#\n\n使用名词而不是动词来命名资源，并且保持命名直观和易于理解。\n\n2.2.3 分层系统#\n\n设计 API 时，应该考虑系统的分层，使得每个层次都可以独立地扩展和替换。\n\n2.2.4 按需加载代码#\n\n这是一种可选原则，允许服务器发送执行代码（例如 JavaScript）到客户端，以扩展客户端的功能。\n\n2.2.5 HATEOAS#\n\n通过超媒体链接动态提供客户端当前状态下的下一步操作，减少客户端与服务器之间的耦合。\n\n\n常见中间件#\n\n\n什么是中间件#\n\nDjango 中间件是一个轻量级的、底层级的 “插件” 系统，用于在 Django 的请求 / 响应处理过程中插入某些特定的逻辑。中间件组件是 Django\n框架的核心特性之一，允许开发者在全局层面上修改进入和离开 Django 应用的请求和响应。\n\n\n中间件的关键点#\n\n以下是 Django 中间件的一些关键点：\n\n3.2.1 作用时机#\n\n中间件在请求从用户发送到 Django 然后返回响应的整个周期中的多个点被调用。这包括在 Django 处理请求之前、处理请求时、以及生成响应之后。\n\n3.2.2 功能#\n\n中间件可以用于多种多样的任务，比如：\n\n * 用户认证和授权\n * 会话管理\n * CSRF 保护\n * 压缩响应内容\n * 缓存机制\n * 日志记录\n * 设置响应头\n * 防止点击劫持\n * 请求和响应数据的修改\n\n3.2.3 工作原理#\n\n中间件以类或函数的形式实现，并且按照在 Django\n项目设置文件settings.py中的MIDDLEWARE配置列表的顺序来调用。请求和响应会通过这个中间件列表，在每个中间件中可以执行特定的操作。\n\n3.2.4 方法#\n\n一个中间件可以包含以下方法（但不一定要全部实现）：\n\n * init(self, get_response):\n   初始化中间件，接收一个get_response参数，这个参数是一个可调用的对象，用于调用中间件链中的下一个中间件或最终的视图。\n * process_request(self, request): 在 Django 决定哪个视图处理请求之前调用。\n * process_view(self, request, view_func, view_args, view_kwargs): 在 Django\n   调用视图函数之前调用。\n * process_response(self, request, response): 在视图函数处理完请求后，返回响应之前调用。\n * process_exception(self, request, exception): 如果在视图函数中抛出了异常，这个方法会被调用。\n\n\nDRF 架构#\n\n\n简介#\n\nDRF，即 Django REST framework，是一个强大且灵活的工具集，用于构建 Web API 在 Django\n项目中。它提供了序列化器、视图、路由器等工具，让开发者能够快速地开发出符合 RESTful 规范的 API。以下是针对新手小白的 DRF\n介绍，包括一个简单的代码实例。\n\nDRF 的主要优点：\n\n * 符合 RESTful 设计原则：它鼓励使用无状态的、可缓存的通信协议。\n * 高度可扩展：你可以利用它的插件系统来扩展其功能。\n * 强大的文档：自动生成 API 文档，便于开发和测试。\n\n\n4.2 实战例子#\n\n4.2.1 安装#\n\n首先，确保你已经有一个 Django 项目。以下是安装 DRF 的步骤：\n\n\n\n然后在你的settings.py中添加以下内容来注册 DRF：\n\n\n\n下面我们将创建一个简单的 API 来管理博客文章。\n\n4.2.2 定义模型#\n\n首先，在models.py中定义一个简单的模型：\n\n\n\n4.2.3 创建序列化器#\n\n在serializers.py中创建一个序列化器：\n\n\n\n4.2.4 创建视图#\n\n在views.py中创建视图，使用 DRF 的APIView：\n\n\n\n4.2.5 配置 URLs#\n\n在urls.py中配置 URL：\n\n\n\n4.2.6 运行服务器#\n\n确保你的数据库表已经被创建：\n\n\n\n然后运行开发服务器：\n\n\n\n4.2.7 测试 API#\n\n现在，你可以使用浏览器或者 Postman 等工具来测试你的 API。\n\n * 获取文章列表：访问 http://127.0.0.1:8000/articles/\n * 创建新文章：发送 POST 请求到 http://127.0.0.1:8000/articles/，并在请求体中包含title, author,\n   和 body字段。\n\n以下是使用curl的一个例子：\n\n\n获取文章列表#\n\ncurl http://127.0.0.1:8000/articles/\n\n\n创建新文章#\n\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"title\": \"My Title\",\n\"author\": \"Me\", \"body\": \"This is my article body.\"}'\nhttp://127.0.0.1:8000/articles/","routePath":"/编程基础/前后端/Django进阶技巧","lang":"","toc":[{"text":"用户认证和权限","id":"用户认证和权限","depth":2,"charIndex":13},{"text":"用户认证","id":"用户认证","depth":3,"charIndex":24},{"text":"权限管理","id":"权限管理","depth":3,"charIndex":1611},{"text":"1.2.1在django中实现角色级别的权限控制","id":"121在django中实现角色级别的权限控制","depth":4,"charIndex":2085},{"text":"1.3.1 在django中实现对象级别的权限控制","id":"131-在django中实现对象级别的权限控制","depth":4,"charIndex":2593},{"text":"RestFul API","id":"restful-api","depth":2,"charIndex":3049},{"text":"RESTful API 的核心概念","id":"restful-api-的核心概念","depth":3,"charIndex":3247},{"text":"2.1.1 资源（Resources）","id":"211-资源resources","depth":4,"charIndex":3267},{"text":"2.1.2 统一接口（Uniform Interface）","id":"212-统一接口uniform-interface","depth":4,"charIndex":3358},{"text":"2.1.3 无状态（Stateless）","id":"213-无状态stateless","depth":4,"charIndex":3483},{"text":"2.1.4 可缓存（Cacheable）","id":"214-可缓存cacheable","depth":4,"charIndex":3571},{"text":"2.1.5 分层系统（Layered System）","id":"215-分层系统layered-system","depth":4,"charIndex":3626},{"text":"设计原则","id":"设计原则","depth":3,"charIndex":3725},{"text":"2.2.1 使用标准 HTTP 方法","id":"221-使用标准-http-方法","depth":4,"charIndex":3732},{"text":"2.2.2 资源命名","id":"222-资源命名","depth":4,"charIndex":3835},{"text":"2.2.3 分层系统","id":"223-分层系统","depth":4,"charIndex":3879},{"text":"2.2.4 按需加载代码","id":"224-按需加载代码","depth":4,"charIndex":3931},{"text":"2.2.5 HATEOAS","id":"225-hateoas","depth":4,"charIndex":3998},{"text":"常见中间件","id":"常见中间件","depth":2,"charIndex":4058},{"text":"什么是中间件","id":"什么是中间件","depth":3,"charIndex":4067},{"text":"中间件的关键点","id":"中间件的关键点","depth":3,"charIndex":4203},{"text":"3.2.1 作用时机","id":"321-作用时机","depth":4,"charIndex":4236},{"text":"3.2.2 功能","id":"322-功能","depth":4,"charIndex":4325},{"text":"3.2.3 工作原理","id":"323-工作原理","depth":4,"charIndex":4446},{"text":"3.2.4 方法","id":"324-方法","depth":4,"charIndex":4561},{"text":"DRF 架构","id":"drf-架构","depth":2,"charIndex":4988},{"text":"简介","id":"简介","depth":3,"charIndex":4998},{"text":"4.2 实战例子","id":"42-实战例子","depth":3,"charIndex":5263},{"text":"4.2.1 安装","id":"421-安装","depth":4,"charIndex":5274},{"text":"4.2.2 定义模型","id":"422-定义模型","depth":4,"charIndex":5387},{"text":"4.2.3 创建序列化器","id":"423-创建序列化器","depth":4,"charIndex":5428},{"text":"4.2.4 创建视图","id":"424-创建视图","depth":4,"charIndex":5472},{"text":"4.2.5 配置 URLs","id":"425-配置-urls","depth":4,"charIndex":5520},{"text":"4.2.6 运行服务器","id":"426-运行服务器","depth":4,"charIndex":5556},{"text":"4.2.7 测试 API","id":"427-测试-api","depth":4,"charIndex":5602}],"domain":"","frontmatter":{"Author":"马涛涛"},"version":""},{"id":96,"title":"FastAPI—8小时入门版","content":"#\n\n\n一、简介#\n\nFastAPI 是一个 Web 服务框架，其主要特点就是\"快\"。\n\n在 Python Web 服务领域比较知名的就是 Django、Flask，但其性能一直为大家所诟病，以至于很多大型项目会选择基于 Go 语言的 Web\n服务框架，比如 beego。而 Django、Flask 较多应用于一些小型网站或者一些个人博客类网站。\n\n应该说，Python 在 Web 后端服务领域是失败的，而 FastAPI 的出现或许有可能为 Python 扳回一局。\n\nFastAPI 之所以能突破 Python 语言本身所带来的性能瓶颈，是因为其主要采用了异步的设计思路，无论是源码还是示例，都有大量协程的写法。\n\n协程，是 Python 唯一能突破线程 GIL（全局解释器锁）、突破进程 CPU 数量限制的高阶编码模式，它使得任务间的切换能够像调用函数一样轻松。协程也是\nPython 里面最不好理解的内容之一。\n\n但是没关系，FastAPI 通过非常精良的设计让你不用真正弄懂协程就能轻松使用它。\n\n\n二、安装#\n\n系统环境: deepin\n\n\n\n安装 ASGI 服务器，用于启动服务\n\n\n\n\n三、简单的例子#\n\n定义一个接口，返回简单的 json 响应：\n\n\n\n这是固定写法，后面的内容就不重复写这两行了；\n\n\n\n在终端通过命令启动服务：\n\n\n\n在本机浏览器访问：http://127.0.0.1:8000/；\n\n我个人喜欢在 py 文件里面写启动：\n\n\n\n这样直接运行 py 脚本：\n\n\n\n\nOpenAPI 文档#\n\nFastAPI 的一个特点就是自带接口文档，只需要在 url 后面加 docs：\n\n\n\n你如果不喜欢 Swagger 风格的文档，可以将 docs 改成 redoc，FastAPI 默认携带两种风格的接口文档。\n\n\n四、Pydantic#\n\nFastAPI 是借助 Pydantic 来进行类型声明的，主要有两个用途：\n\n * 对请求体和响应体的参数类型进行声明；\n * 在编辑器里面享受代码补全的乐趣；\n\n使用过 Python 的 typing 的同学应该知道【类型标注】，它可以校验参数及返回的类型，使得代码更加严禁，且更具有可读性。\n\nPydantic 提供了更加强大的类型定义和更加友好的错误提示功能。即使不用 FastAPI，在其他编码中你也可以很有效的使用它。\n\n使用举例：\n\n\n\n传递参数进去：\n\n\n\nfrom pydantic import BaseModel 里面的 BaseModel 记住，通常都是继承这个类来写我们的自定义类型；\n\n将 Pydantic 数据类型转换成 JSON：\n\n\n\n\n五、参数#\n\nFastAPI 是 RESTful 风格的框架，后面例子的接口请求我都使用 Postman 来做，这个只是个人习惯，你可以使用接口文档里面提供的【Try it\nout】接口调试功能，也可以使用 requests 这类的 HTTP 库进行接口请求，效果是一样的。\n\n\n1、路径参数#\n\n1.1 普通路径参数#\n\n声明路径参数：\n\n\n\n路径参数 item_id 可以传入到函数中，比如：http://10.8.13.224:5000/items/mikigo\n\n传递参数为：mikigo，响应如下：\n\n\n\n1.2 有类型的路径参数#\n\n声明路径参数：\n\n\n\n区别是给参数 item_id 指定了一个类型 int；\n\n如果还是传递参数为：mikigo，http://10.8.13.224:5000/items/mikigo 会报错：\n\n\n\n必须要给一个数字才行 http://10.8.13.224:5000/items/520 响应：\n\n\n\n这样就完成了路径参数的数据校验；\n\n\n2、查询参数#\n\n不属于路径参数的其他函数参数，会被被自动解释为\"查询字符串\"参数。\n\n\n\n查询参数的键值在 URL 的 ？ 之后，并以 & 符号分隔，就和我们理解的普通 GET 请求参数传递方式是一样的；\n\n\n\n响应：\n\n\n\n注意我们在 read_item(name: str = \"\") 给了一个默认值，说明参数是可选的（不传参也可以），如果 直接用read_item(name:\nstr) 说明参数是必传的，否则会报错。\n\n\n3、请求体#\n\n请求体是客户端发送给 API 的数据。响应体是 API 发送给客户端的数据。\n\n一般我们说GET方法没有请求体，POST、PUT等方法才有请求体。\n\n举例：\n\n\n\n发一个 POST 请求，参数为：\n\n\n\n返回值：\n\n\n\n\n4、内建参数类型#\n\n4.1、Query#\n\nQuery 一般是用在查询参数里面：\n\n\n\nQuery(default=None, max_length=10) 里面:\n\n * default=None 表示参数可选，默认值为 None，和 name: str = None 写法是一个意思；\n   \n   如果想要参数必填：default=...（没错哈，就是三个点，三个点在 Python 里面是一个省略对象）；\n\n * max_length=10 定义了参数的最大长度；\n\nQuery 支持的参数还有点多，感兴趣可以一个个试：\n\n\n\n请求：\n\n\n\n响应：\n\n\n\n4.2、Path#\n\nPath 一般是用在路径参数里面：\n\n\n\n可以看的出来 Path(default=..., max_length=10) 和 Query 用法几乎一样，不是几乎，就是一样的。\n\n请求：\n\n\n\n响应：\n\n\n\n4.3、Body#\n\nBody 一般是用于请求体：\n\n\n\n请求：\n\n\n\n需要构造请求体：\n\n\n\n响应：\n\n\n\n4.4、Field#\n\nField 一般用于请求体的字段，对请求体的参数做进一步的约束，它是从 pydantic 导入的：\n\n\n\n请求：\n\n\n\n构造请求体如下：\n\n\n\n响应：\n\n\n\n4.5、Cookie#\n\n先设置 cookie：\n\n\n\n请求一下，查看 cookie 设置是否成功:\n\n\n\n然后再定义 Cookie 参数：\n\n\n\nCookie 参数的结构与声明 Query 参数和 Path 参数时相同\n\n请求一把：\n\n\n\n4.6、Header#\n\nHeader 使用和Path, Query and Cookie 一样;\n\n\n\n请求：\n\n\n\n响应：\n\n\n\nHeader 有个特殊的参数 convert_underscores: bool = True；\n\n因为大多数标准的headers用 \"连字符\" 分隔，因此默认将参数名称的字符从下划线 (_) 转换为连字符 (-) ；\n\n\n六、响应#\n\n\n1、响应限制#\n\nPydantic 不仅可以对请求参数进行校验和限制，对响应同样可以；\n\n\n\n在装饰器 @app.post 里面有个参数 response_model 可以声明响应的模型；\n\nresponse_model=Item 表示响应信息也是 Item 的类型，API 文档里面也会有响应信息的示例，否则就是空的；\n\n\n2、响应状态码#\n\n\n\n请求成功，返回状态码为：201;\n\nAPI 文档里面也会有展示；\n\nfastapi 提供了一个 status 模块来表示状态码：\n\n\n\nstatus.HTTP_201_CREATED 这种方式更容易理解状态码的意思，因此我个人更推荐这种写法。\n\n\n3、返回错误信息#\n\n\n\n发送请求：\n\n\n\n\n七、表单及文件#\n\n\n1、Form表单#\n\n常见的，登录接口会提交 Form 表单：\n\n\n\n重启服务，厚礼谢，你会发现报错，提示要安装依赖：python-multipart，啥也别问直接装：\n\n\n\n再重启服务之后，通过表单字段发送，注意不能用 JSON 发送；\n\n\n\n\n2、上传文件#\n\n上传文件功能也依赖：python-multipart；\n\n2.1、File#\n\n\n\nFile 是直接继承自 Form 的类，把文件当做表单上传，源码：\n\n\n\n以 bytes 形式读取和接收文件内容，这种方式把文件的所有内容都存储在内存里，适用于小型文件。\n\n2.2、UploadFile#\n\n\n\nUploadFile 与 bytes 相比更好一点，即使是大文件也不会占用所有内存，因为它内部有个文件最大限制，超过就会先存入磁盘；\n\n\n\nspool_max_size 就是限制文件的大小；\n\n通过上面源码的构造函数可以看出有 2 个必传参数：\n\n * filename：上传文件名字符串（str），例如， mikigo.jpg；\n * content_type：内容类型（MIME 类型 / 媒体类型）字符串（str），例如，image/jpeg；\n\n如果 file 参数不传，默认为 None，那么实际调用的是 tempfile 模块子的 SpooledTemporaryFile\n，这个类会将数据缓存在内存中直到文件大小超过 max_size，这时文件内容会被写入磁盘；\n\nUploadFile 源码里面有这几个方法：\n\n\n\n这些方法都是异步(async)方法：\n\n * write(data)：把 data （str 或 bytes）写入文件；\n * read(size)：按指定数量的字节或字符（size (int)）读取文件内容；\n * seek(offset)：移动至文件 offset（int）字节处的位置；\n   * 例如，await myfile.seek(0) 移动到文件开头；\n   * 执行 await myfile.read() 后，需再次读取已读取内容时，这种方法特别好用；\n * close()：关闭文件。\n\n使用异步的时候用 await ：\n\n\n\n\n八、依赖项#\n\n依赖项也叫“依赖注入”，使用 Depends：\n\n\n\nDepends 需要传入一个可调用对象，一般就给函数对象，也就是依赖函数，注意不是调用函数，没有括号；\n\n依赖函数的参数和查询参数的一样；\n\n\n九、安全性#\n\n\n1、OAuth2#\n\n功能也依赖：python-multipart；\n\nOAuth2 主要用于验证用户身份：\n\n\n\n查看 OpenAPI 文档你会发现，右上角有个 Authorize 按钮，点它：\n\n\n\n弹出授权表单，输入 username 与 password 及其它可选字段；\n\n这个是 FastAPI 的安全工具；\n\n\n2、获取当前用户#\n\n\n\n先创建一个请求体模型 User；\n\n再创建一个 get_current_user 依赖项，它的依赖项是 oauth2_scheme，这里接受一个 token 字符串，在给另外一个函数\nfake_decode_token 进行解码后，返回 user 对象；\n\n最后，通过 read_users_me 依赖项，返回当前用户；\n\n这里实际是一个嵌套依赖的关系。\n\n\n十、中间件#\n\n中间件就相当于一个钩子函数，在每个请求被处理之前，以及没饿响应返回之前工作。工作原理类似于 Python 里面的属性拦截器就可以理解。\n\n\n1、创建中间件#\n\n使用装饰器 @app.middleware(\"http\") ，固定用法，记住就好了；\n\n\n\n参数：\n\n * request，FastAPI 的请求对象；\n * 一个函数 call_next 它将接收 request 作为参数；\n   * 这个函数将 request 传递给相应的 路径操作；\n   * 然后它将返回由相应的路径操作生成的 response；\n * 然后你可以在返回 response 前进一步修改它；\n\n\n2、跨域资源共享(CORS)#\n\n在同一个IP地址中，但使用不同的协议或者端口，就是不同的域；\n\n使用 CORSMiddleware ：\n\n\n\n\n十一、SQL数据库#\n\nFastAPI 使用数据一般采用 Python 社区最流行的 ORM 库：SQLAlchemy；\n\n如果你会用 Django 的 model，那基本上就很简单了；\n\n\n1、创建数据库工程文件#\n\n先创建一个数据库的目录，里面包含这些文件：\n\n\n\n\n2、安装#\n\n安装 SQLAlchemy 非常简单：\n\n\n\n\n3、创建SQLAlchemy部件#\n\nSQLAlchemy 支持多种常用的数据类型：\n\n以 sqlite 举例：\n\n\n\n\n4、创建数据库模型#\n\n\n\n当访问 my_user.items 时，SQLAlchemy 实际上会从 items 表中的获取一批记录并在此处填充进去。\n\n注意，数据库模型都是将类型作为参数传给 Column 来定义的，例如：\n\n\n\n\n5、创建 Pydantic 模型#\n\nPydantic 模型和数据库模型的属性一致：\n\n\n\n\n6、CRUD工具#\n\n用来与数据库中的数据进行交互，CRUD分别为：增加、查询、更改和删除，即增删改查；\n\n6.1、读取数据#\n\n\n\n6.2、创建数据#\n\n\n\n\n7、主程序#\n\n\n\n\n8、执行项目#\n\n\n\n\n\n以上内容是入门版知识，还有一些进阶的内容或者更加工程化的内容，我想放到 FastAPI 实战里面去写，好啦就先到这里吧，期待进阶内容。","routePath":"/编程基础/前后端/FastAPI—8小时入门版","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":456},{"text":"三、简单的例子","id":"三简单的例子","depth":2,"charIndex":502},{"text":"OpenAPI 文档","id":"openapi-文档","depth":3,"charIndex":653},{"text":"四、Pydantic","id":"四pydantic","depth":2,"charIndex":774},{"text":"五、参数","id":"五参数","depth":2,"charIndex":1123},{"text":"1、路径参数","id":"1路径参数","depth":3,"charIndex":1263},{"text":"1.1 普通路径参数","id":"11-普通路径参数","depth":4,"charIndex":1272},{"text":"1.2 有类型的路径参数","id":"12-有类型的路径参数","depth":4,"charIndex":1381},{"text":"2、查询参数","id":"2查询参数","depth":3,"charIndex":1569},{"text":"3、请求体","id":"3请求体","depth":3,"charIndex":1785},{"text":"4、内建参数类型","id":"4内建参数类型","depth":3,"charIndex":1904},{"text":"4.1、Query","id":"41query","depth":4,"charIndex":1915},{"text":"4.2、Path","id":"42path","depth":4,"charIndex":2187},{"text":"4.3、Body","id":"43body","depth":4,"charIndex":2301},{"text":"4.4、Field","id":"44field","depth":4,"charIndex":2356},{"text":"4.5、Cookie","id":"45cookie","depth":4,"charIndex":2447},{"text":"4.6、Header","id":"46header","depth":4,"charIndex":2568},{"text":"六、响应","id":"六响应","depth":2,"charIndex":2747},{"text":"1、响应限制","id":"1响应限制","depth":3,"charIndex":2755},{"text":"2、响应状态码","id":"2响应状态码","depth":3,"charIndex":2918},{"text":"3、返回错误信息","id":"3返回错误信息","depth":3,"charIndex":3054},{"text":"七、表单及文件","id":"七表单及文件","depth":2,"charIndex":3077},{"text":"1、Form表单","id":"1form表单","depth":3,"charIndex":3088},{"text":"2、上传文件","id":"2上传文件","depth":3,"charIndex":3212},{"text":"2.1、File","id":"21file","depth":4,"charIndex":3250},{"text":"2.2、UploadFile","id":"22uploadfile","depth":4,"charIndex":3350},{"text":"八、依赖项","id":"八依赖项","depth":2,"charIndex":4011},{"text":"九、安全性","id":"九安全性","depth":2,"charIndex":4118},{"text":"1、OAuth2","id":"1oauth2","depth":3,"charIndex":4127},{"text":"2、获取当前用户","id":"2获取当前用户","depth":3,"charIndex":4290},{"text":"十、中间件","id":"十中间件","depth":2,"charIndex":4483},{"text":"1、创建中间件","id":"1创建中间件","depth":3,"charIndex":4561},{"text":"2、跨域资源共享(CORS)","id":"2跨域资源共享cors","depth":3,"charIndex":4782},{"text":"十一、SQL数据库","id":"十一sql数据库","depth":2,"charIndex":4855},{"text":"1、创建数据库工程文件","id":"1创建数据库工程文件","depth":3,"charIndex":4951},{"text":"2、安装","id":"2安装","depth":3,"charIndex":4991},{"text":"3、创建SQLAlchemy部件","id":"3创建sqlalchemy部件","depth":3,"charIndex":5022},{"text":"4、创建数据库模型","id":"4创建数据库模型","depth":3,"charIndex":5083},{"text":"5、创建 Pydantic 模型","id":"5创建-pydantic-模型","depth":3,"charIndex":5200},{"text":"6、CRUD工具","id":"6crud工具","depth":3,"charIndex":5247},{"text":"6.1、读取数据","id":"61读取数据","depth":4,"charIndex":5301},{"text":"6.2、创建数据","id":"62创建数据","depth":4,"charIndex":5314},{"text":"7、主程序","id":"7主程序","depth":3,"charIndex":5328},{"text":"8、执行项目","id":"8执行项目","depth":3,"charIndex":5339}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":97,"title":"JS基础教程","content":"#\n\n\n简介#\n\nJavaScript 是一种轻量级的编程语言，广泛用于网页开发中，为网页添加动态功能。\n\n\n基本用法#\n\n\n输出语句#\n\n在浏览器窗口弹出警告框\n\n\n\n在控制台输出信息，执行过程中会将输出的信息打印在控制台上\n\n * 控制台输出信息多用于调试\n\n\n\n例子，需结合HTML来实现\n\n\n\n浏览器打开编写的HTML文件\n\n\n\n\nJS代码引入方式#\n\n在HTML中使用js的几种方式\n\n\n\n外链式引入本地js文件例子\n\njs本地文件，simple.js\n\n\n\nHTML文件中引入\n\n\n\n页面效果和上节一样\n\n\nJS基础语法#\n\n\n变量的声明与赋值#\n\n\n\n\n变量声明和区别#\n\nvar 是 JavaScript 最初用于声明变量的关键字。以下是 var 的特点：\n\n * 函数作用域：var 声明的变量拥有函数作用域，这意味着如果 var 在函数外部声明，它是全局变量；如果在函数内部声明，它只能在该函数内部访问。\n\n * 变量提升：使用 var 声明的变量会被提升到其所在作用域的顶部，但是赋值不会提升。\n\n * 可重声明：在同一作用域内，可以多次声明同一个变量。\n\nlet 是 ES6（ECMAScript 2015）中引入的新关键字，用于声明块级作用域的变量：\n\n * 块级作用域：let 声明的变量仅在它被声明的代码块（如 {} 内部）中可见。\n\n * 不会变量提升：在声明之前访问 let 变量会导致一个引用错误（ReferenceError）。\n\n * 不可重声明：在同一作用域内，不能重新声明同一个变量。\n\n\n常量#\n\nconst 也同样是 ES6 引入的，用于声明常量，即一旦赋值后就不能更改其值的变量。\n\n * 块级作用域：与 let 一样，const 声明的变量具有块级作用域。\n * 不会变量提升：同 let，const 声明的变量也不会被提升。\n * 不可更改：一旦声明并初始化，const 变量的值就不能更改（对于基本数据类型而言）。但是，如果 const\n   变量引用的是一个对象，那么对象的属性是可以被修改的。\n * 不可重声明：与 let 一样，在同一作用域内不可重声明。\n\n\n\n\n基本数据类型#\n\n布尔型\n\n\n\n数字型\n\n\n\n字符串\n\n\n\n未定义\n\n\n\n\n数据类型检查#\n\n使用typeof关键字\n\n\n\n\n算数运算符#\n\n加法 (+)\n\n加法运算符用于两个数值相加，或者连接两个字符串。\n\n\n\n减法 (-)\n\n减法运算符用于从一个数值中减去另一个数值。\n\n\n\n乘法 (*)\n\n乘法运算符用于两个数值相乘。\n\n\n\n除法 (/)\n\n除法运算符用于一个数值除以另一个数值。\n\n\n\n取模 (%)\n\n取模运算符（有时称为取余运算符）返回两个数值相除后的余数。\n\n\n\n指数 (**)\n\n指数运算符用于计算幂运算，即一个数的指数次方。\n\n\n\n自增 (++)\n\n自增运算符将变量的值增加 1。它有两种形式：前置自增（++variable）和后置自增（variable++）。\n\n\n\n自减 (--)\n\n自减运算符将变量的值减少 1。它也有两种形式：前置自减（--variable）和后置自减（variable--）。\n\n\n\n\n字符串运算符&隐式转换#\n\n两个字符串：当使用加号运算符连接字符串时，它会将两个字符串拼接起来。\n\n\n\n字符串与数值：如果操作数之一是字符串，另一个是数值，那么数值会被转换为字符串，然后执行字符串连接。\n\n\n\n数值与布尔值：如果操作数之一是数值，另一个是布尔值，那么布尔值 true 会被转换为 1，false 会被转换为 0，然后执行数值运算。\n\n\n\n布尔值与字符串：如果操作数之一是布尔值，另一个是字符串，那么布尔值会被转换为字符串，然后执行字符串连接。\n\n\n\nnull 和 undefined：null 和 undefined 在进行字符串连接时会被转换为字符串 \"null\" 和 \"undefined\"。\n\n\n\n如果操作数是对象，那么对象会调用其 toString() 方法转换为字符串。\n\n\n\n以下是一些隐式转换的例子：\n\n\n\n理解隐式转换对于避免在编程中遇到意外的结果非常重要。通常，为了代码的可读性和可维护性，建议避免依赖隐式转换，并在需要时进行显式类型转换。\n\n\n赋值运算符#\n\n将右侧表达式的值赋给左侧的变量。\n\n\n\n复合赋值运算符将一个算术运算符与赋值运算符组合在一起，使得操作更加简洁。\n\n加法赋值 (+=)\n\n将右侧表达式的值与左侧变量的值相加，然后将结果赋给左侧变量。\n\n\n\n减法赋值 (-=)\n\n将右侧表达式的值从左侧变量的值中减去，然后将结果赋给左侧变量。\n\n\n\n乘法赋值 (*=)\n\n将右侧表达式的值与左侧变量的值相乘，然后将结果赋给左侧变量。\n\n\n\n除法赋值 (/=)\n\n将左侧变量的值除以右侧表达式的值，然后将结果赋给左侧变量。\n\n\n\n取模赋值 (%=)\n\n将左侧变量的值除以右侧表达式的值并取余数，然后将结果赋给左侧变量。\n\n\n\n\n比较运算符#\n\n\n\n\n逻辑运算符#\n\n * && 逻辑运算符 一假则假\n * || 逻辑或运算符 一真则真\n\n\n\n\n三元表达式#\n\nJavaScript 中的三元表达式是一种简洁的条件表达式，它由三个操作数和一个问号 (?) 以及一个冒号 (:) 组成。它是一种简化版的 if-else\n语句，允许在单行内完成条件判断和相应的操作。\n\n\n\n这里的 condition 是要判断的条件，它应该是一个能够返回布尔值 true 或 false 的表达式。如果 condition 为真\n(true)，则表达式的结果是 valueIfTrue；如果 condition 为假 (false)，则表达式的结果是 valueIfFalse。\n\n\n\n\nif选择结构#\n\nif 选择结构是一种基本的控制流语句，它允许程序根据指定的条件执行不同的代码块。if 语句根据条件的真值来决定执行哪个代码块。\n\n基本用法\n\n\n\n\n\n\n\n例子\n\n\n\n嵌套写法\n\n可以在一个 if 语句内部嵌套另一个 if 语句\n\n\n\n\n循环结构#\n\n\nfor循环#\n\nfor 循环是一种用于重复执行一段代码的循环控制结构，通常当你提前知道需要执行循环的次数时使用\n\nfor 循环的四个部分：\n\n 1. 初始化表达式（initialization）：在循环开始前执行一次，通常用于声明和初始化一个计数器变量。\n\n 2. 条件表达式（condition）：在每次循环迭代之前检查，如果为真（true），则执行循环体。如果为假（false），循环终止。\n\n 3. 迭代表达式（iteration）：在每次循环体执行后执行，通常用于更新计数器变量。\n\n 4. 循环体（body）：这是循环中重复执行的代码块。\n\n\n\n在这个例子中：\n\n * let i = 0 是初始化表达式，它声明了一个变量 i 并将其初始化为 0。\n\n * i < 10 是条件表达式，它在每次迭代前检查 i 是否小于 10。\n\n * i++ 是迭代表达式，它在每次循环体执行后增加 i 的值。\n\n * console.log(i); 是循环体，它会重复执行，直到条件表达式返回 false。\n\n\nwhile循环#\n\nwhile 循环是一种基本的循环控制结构，用于重复执行一段代码直到指定的条件为假（false）。与 for 循环不同，while\n循环通常用于当你事先不知道循环要执行多少次，只是需要根据某个条件来结束循环时。\n\n\n\n这里的 condition 是循环每次迭代前都要检查的表达式。如果 condition 的计算结果为真（true），则循环体中的代码块会被执行。一旦\ncondition 的结果为假（false），循环就会终止。\n\n\n\n在这个例子中，循环会一直执行直到 i 的值不再小于 10。在每次循环的末尾，i 的值都会通过 i++ 递增。\n\n\ndo...while循环#\n\ndo...while 循环，这是 while 循环的变体，它至少执行一次循环体，然后根据条件判断是否继续执行。\n\n\n\n在 do...while 循环中，循环体会在检查条件之前先执行一次，然后条件会被检查以确定是否继续循环。\n\n\n\n在这个例子中，循环的行为与上面的 while 循环类似，不同之处在于即使初始条件为假，循环体也至少会执行一次。\n\n\n循环控制#\n\nfor 循环， while 和 do...while 循环中使用 break 和 continue 语句来控制循环的流程：\n\n * break 用于立即退出循环。\n\n * continue 用于跳过当前迭代中剩余的代码，直接进入下一次迭代的条件检查。\n\n\n数组#\n\n数组是一种特殊的对象，用于存储多个值的有序集合。数组中的每个值都有一个索引，索引从 0 开始计数，这使得你可以方便地访问和操作数组中的元素。\n\n\n创建数组#\n\n使用数组字面量\n\n\n\nArray 构造函数\n\n\n\n创建一个具有特定长度的空数组：\n\n\n\n使用索引来访问数组中的元素：\n\n\n\n可以直接通过索引修改数组中的元素：\n\n\n\n使用 length 属性可以获取或设置数组的长度：\n\n\n\n\n数组方法#\n\n添加元素#\n\npush()：向数组的末尾添加一个或多个元素，并返回新的长度。\n\n\n\nunshift()：向数组的开头添加一个或多个元素，并返回新的长度。\n\n\n\n删除元素#\n\npop()：删除数组的最后一个元素，并返回该元素。\n\n\n\nshift()：删除数组的第一个元素，并返回该元素。\n\n\n\n其他方法#\n\nslice()：提取数组的一部分，并返回一个新数组。\n\n\n\nsplice()：通过删除现有元素和 / 或添加新元素来更改数组的内容。\n\n\n\nmap()、filter()、reduce() 等迭代方法用于对数组的每个元素执行操作。\n\n\n\n遍历数组#\n\n使用 for 循环可以遍历数组中的所有元素：\n\n\n\n使用 forEach() 方法：\n\n\n\n\n函数#\n\n\n函数定义#\n\n * 函数用于封装完成一段特定功能的代码\n\n * 相当于将一条或多条语句组成的代码块包裹起来\n\n * 用户在使用时只需要关心参数和返回值,就能完成特定的功能,而不用了解具体的实现\n\n\n\nfunction是用来声明函数的一个语句\n\n * name是函数名\n\n * params是函数参数\n\n * {}内放函数的具体功能\n\n\n函数返回值#\n\n函数的返回值是指函数在调用后获得的数据\n\n在定义函数时,可以为函数指定一个返回值并退出函数，使用 return 语句来返回一个值。如果没有指定返回值，则函数会返回 undefined。\n\n\n\n\n获取函数调用时传递所有实参#\n\n\n\n\n...扩展运算符#\n\n\n\n\narguments 对象#\n\n如果不确定形参的个数,可以不设置形参，在函数体中直接通过arguments对象获取函数调用时传递的实参\n\n\n\n\n函数中变量作用域#\n\n全局变量: 在函数体外声明的变量或者在函数体内省略var关键字声明的变量\n\n\n\n局部变量:在函数体内利用let关键声明的变量\n\n\n\n\n匿名函数#\n\n在声明函数的时候没有指定函数名，而是赋值给一个变量\n\n\n\n\n箭头函数#\n\n\n\n\n定时器#\n\nsetInterval()\n\n指定时间间隔，间隔时间一到，代码就会执行一次\n\n\n\nsetTimeout\n\n用来指某个函数或某段代码在多少毫秒以后执行\n\nsetTinmeout指定的代码,必须等同步代码执行完成后执行\n\n\n\n\n对象#\n\n对象是一种复杂数据类型，以赋值的形式存储多个数据\n\n新建对象\n\n\n\n对象查询\n\n\n\n对象新增\n\n\n\n对象修改\n\n * 对于对象的属性,如果有这个属性,是修改属性值:如果没有这个属性,是新增\n\n\n\n对象删除\n\n\n\n对象遍历\n\n\n\n\nString对象#\n\nString 对象是用于表示和操作字符串的内置对象。字符串是表示文本数据的字符序列。在 JavaScript\n中，字符串是不可变的，这意味着字符串一旦创建，其值就不能更改。\n\n\n创建字符串#\n\n字面量\n\n\n\nString 构造函数\n\n\n\n\n字符串的属性#\n\nlength获取字符串的长度\n\n\n\n\n字符串方法#\n\n查找和替换\n\n * charAt(index)：返回指定索引位置的字符。\n * charCodeAt(index)：返回在指定的索引处字符的 Unicode 编码。\n * indexOf(searchValue, fromIndex)：返回指定值第一次出现的索引，如果不存在，则返回 - 1。\n * lastIndexOf(searchValue, fromIndex)：返回指定值最后一次出现的索引，如果不存在，则返回 - 1。\n * search(regexp)：对正则表达式和指定的字符串进行匹配搜索。\n * replace(searchFor, replaceWith)：在字符串中用一些字符替换另一些字符，或者替换一个与正则表达式匹配的子串。\n\n\n\n切片和分割\n\n * slice(startIndex, endIndex)：提取字符串的某个部分，并返回一个新的字符串。\n * substring(startIndex, endIndex)：返回字符串中介于两个指定索引之间的字符。\n * split(separator, limit)：把一个字符串分割成字符串数组。\n\n\n\n转换大小写\n\n * toLowerCase()：将字符串转换为小写。\n * toUpperCase()：将字符串转换为大写。\n * toLocaleLowerCase()：根据当前区域设置，将字符串转换为小写。\n * toLocaleUpperCase()：根据当前区域设置，将字符串转换为大写。\n\n\n\n其他方法\n\n * concat(value1, value2, ..., valueN)：连接两个或多个字符串，并返回新的字符串。\n * includes(searchString, position)：判断字符串是否包含指定的子字符串。\n * startsWith(searchString, position)：判断字符串是否以指定的子字符串开头。\n * endsWith(searchString, position)：判断字符串是否以指定的子字符串结尾。\n * trim()：从字符串的两端删除空白字符。\n\n\n\n\nArray对象#\n\nArray 对象用于表示一组有序的数据集合，数组中的每个数据项称为元素。数组是动态的数据结构，可以包含任意数量的元素，这些元素可以是不同类型的值。\n\n\n创建数组#\n\n使用数组字面量\n\n\n\n使用 Array 构造函数\n\n\n\n如果 Array 构造函数只接收一个数字参数，它将创建一个具有指定长度的空数组。\n\n\n\n\n数组属性#\n\nlength：表示数组中元素的个数。\n\n\n\n\n数组方法#\n\n这些方法会改变原数组。\n\n * push(element1, ..., elementN)：在数组末尾添加一个或多个元素，并返回新的长度。\n * pop()：删除数组的最后一个元素，并返回该元素。\n * shift()：删除数组的第一个元素，并返回该元素。\n * unshift(element1, ..., elementN)：在数组开头添加一个或多个元素，并返回新的长度。\n * splice(start, deleteCount, item1, ..., itemN)：通过删除现有元素和 / 或添加新元素来更改数组内容。\n * sort()：对数组元素进行排序。\n * reverse()：颠倒数组中元素的顺序。\n\n\n\n这些方法返回数组的一个部分或新数组，不会改变原数组。\n\n * slice(start, end)：提取数组的一部分，并返回一个新数组。\n * join(separator)：将数组元素连接成一个字符串，用指定的分隔符分隔每个元素。\n * concat(value1, value2, ..., valueN)：合并多个数组，并返回一个新数组。\n\n\n\n检查方法\n\n * indexOf(searchElement, fromIndex)：返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 - 1。\n * lastIndexOf(searchElement, fromIndex)：返回指定元素在数组中的最后一个的索引，如果不存在则返回 - 1。\n\n\n\n迭代方法\n\n这些方法对数组的每个元素执行一个提供的函数。\n\n * forEach(callback(currentValue, index, array), thisArg)：对数组的每个元素执行一次提供的函数。\n * map(callback(currentValue, index, array),\n   thisArg)：创建一个新数组，其结果是该数组中的每个元素调用一次提供的函数后的返回值。\n * filter(callback(element, index, array), thisArg)：创建一个新数组，包含通过所提供函数实现的测试的所有元素。\n\n\n\n其他方法\n\n * some(callback(element, index, array), thisArg)：测试数组中的元素是否至少有一个满足提供的测试函数。\n * every(callback(element, index, array), thisArg)：测试数组中的所有元素是否都满足提供的测试函数。\n\n\n\n\nDate对象#\n\nJavaScript 的 Date 对象用于处理日期和时间。它基于 1970 年 1 月 1 日（UTC）以来的毫秒数来表示日期。\n\n\n创建Date对象#\n\n创建一个表示当前日期和时间的 Date 对象。\n\n\n\n使用时间戳\n\n时间戳是自 1970 年 1 月 1 日（UTC）以来经过的毫秒数。\n\n\n\n使用日期字符串\n\n你可以传递一个表示日期的字符串给 Date 构造函数。\n\n\n\n使用年、月、日等参数\n\n你可以直接指定年、月、日、时、分、秒和毫秒来创建一个 Date 对象。\n\n\n\n\n属性#\n\nDate 对象没有直接可供访问的属性，但以下方法返回日期的组成部分：\n\n * getTime()：返回自 1970 年 1 月 1 日以来的毫秒数（时间戳）。\n\n * getUTCFullYear()：返回表示年份的整数（根据 UTC）。\n\n * getUTCMonth()：返回表示月份的整数（0-11，根据 UTC）。\n\n * getUTCDate()：返回表示月份中的某一天（1-31，根据 UTC）。\n\n * getUTCHours()：返回表示小时数的整数（0-23，根据 UTC）。\n\n * getUTCMinutes()：返回表示分钟数的整数（0-59，根据 UTC）。\n\n * getUTCSeconds()：返回表示秒钟数的整数（0-59，根据 UTC）。\n\n * getUTCMilliseconds()：返回表示毫秒数的整数（0-999，根据 UTC）。\n\n\n方法#\n\n以下方法用于获取日期和时间的不同部分：\n\n * getTime()：获取时间戳（毫秒）。\n\n * getUTCDate()：获取月份中的某一天（UTC）。\n\n * getUTCDay()：获取星期中的某一天（0-6，UTC）。\n\n * getUTCFullYear()：获取四位数的年份（UTC）。\n\n * getUTCHours()：获取小时数（UTC）。\n\n * getUTCMilliseconds()：获取毫秒数（UTC）。\n\n * getUTCMinutes()：获取分钟数（UTC）。\n\n * getUTCMonth()：获取月份（0-11，UTC）。\n\n * getUTCSeconds()：获取秒数（UTC）。\n\n以下方法用于设置日期和时间的不同部分：\n\n * setTime(milliseconds)：设置时间戳（毫秒）。\n\n * setUTCDate(day)：设置月份中的某一天（UTC）。\n\n * setUTCFullYear(year, month, day)：设置年份（UTC）。\n\n * setUTCHours(hours, minutes, seconds, milliseconds)：设置小时数（UTC）。\n\n * setUTCMinutes(minutes, seconds, milliseconds)：设置分钟数（UTC）。\n\n * setUTCMonth(month, day)：设置月份（UTC）。\n\n * setUTCSeconds(seconds, milliseconds)：设置秒数（UTC）。\n\n以下方法用于转换格式\n\n * toString()：将 Date 对象转换为易读的字符串形式。\n\n * toUTCString()：将 Date 对象转换为对应的 UTC 字符串。\n\n * toISOString()：将 Date 对象转换为 ISO 格式的字符串。\n\n * toJSON()：将 Date 对象转换为 JSON 格式的字符串。\n\n其他方法\n\n * valueOf()：返回 Date 对象的原始值（时间戳）。\n * toLocaleString()：根据本地时间格式，将 Date 对象转换为字符串。\n * toLocaleDateString()：根据本地时间格式，将 Date 对象的日期部分转换为字符串。\n * toLocaleTimeString()：根据本地时间格式，将 Date 对象的时间部分转换为字符串。","routePath":"/编程基础/前后端/JS基础","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"基本用法","id":"基本用法","depth":2,"charIndex":54},{"text":"输出语句","id":"输出语句","depth":3,"charIndex":62},{"text":"JS代码引入方式","id":"js代码引入方式","depth":2,"charIndex":169},{"text":"JS基础语法","id":"js基础语法","depth":2,"charIndex":259},{"text":"变量的声明与赋值","id":"变量的声明与赋值","depth":3,"charIndex":269},{"text":"变量声明和区别","id":"变量声明和区别","depth":2,"charIndex":283},{"text":"常量","id":"常量","depth":2,"charIndex":666},{"text":"基本数据类型","id":"基本数据类型","depth":2,"charIndex":912},{"text":"数据类型检查","id":"数据类型检查","depth":2,"charIndex":950},{"text":"算数运算符","id":"算数运算符","depth":2,"charIndex":975},{"text":"字符串运算符&隐式转换","id":"字符串运算符隐式转换","depth":2,"charIndex":1326},{"text":"赋值运算符","id":"赋值运算符","depth":2,"charIndex":1766},{"text":"比较运算符","id":"比较运算符","depth":2,"charIndex":2061},{"text":"逻辑运算符","id":"逻辑运算符","depth":2,"charIndex":2072},{"text":"三元表达式","id":"三元表达式","depth":2,"charIndex":2119},{"text":"if选择结构","id":"if选择结构","depth":2,"charIndex":2380},{"text":"循环结构","id":"循环结构","depth":2,"charIndex":2507},{"text":"for循环","id":"for循环","depth":3,"charIndex":2515},{"text":"while循环","id":"while循环","depth":3,"charIndex":2969},{"text":"do...while循环","id":"dowhile循环","depth":3,"charIndex":3253},{"text":"循环控制","id":"循环控制","depth":3,"charIndex":3441},{"text":"数组","id":"数组","depth":2,"charIndex":3576},{"text":"创建数组","id":"创建数组","depth":3,"charIndex":3654},{"text":"数组方法","id":"数组方法","depth":3,"charIndex":3774},{"text":"添加元素","id":"添加元素","depth":4,"charIndex":3781},{"text":"删除元素","id":"删除元素","depth":4,"charIndex":3861},{"text":"其他方法","id":"其他方法","depth":4,"charIndex":3927},{"text":"遍历数组","id":"遍历数组","depth":4,"charIndex":4052},{"text":"函数","id":"函数","depth":2,"charIndex":4106},{"text":"函数定义","id":"函数定义","depth":3,"charIndex":4112},{"text":"函数返回值","id":"函数返回值","depth":3,"charIndex":4280},{"text":"获取函数调用时传递所有实参","id":"获取函数调用时传递所有实参","depth":3,"charIndex":4385},{"text":"...扩展运算符","id":"扩展运算符","depth":3,"charIndex":4404},{"text":"arguments 对象","id":"arguments-对象","depth":3,"charIndex":4418},{"text":"函数中变量作用域","id":"函数中变量作用域","depth":3,"charIndex":4489},{"text":"匿名函数","id":"匿名函数","depth":3,"charIndex":4567},{"text":"箭头函数","id":"箭头函数","depth":3,"charIndex":4604},{"text":"定时器","id":"定时器","depth":2,"charIndex":4614},{"text":"对象","id":"对象","depth":2,"charIndex":4732},{"text":"String对象","id":"string对象","depth":2,"charIndex":4852},{"text":"创建字符串","id":"创建字符串","depth":3,"charIndex":4952},{"text":"字符串的属性","id":"字符串的属性","depth":3,"charIndex":4983},{"text":"字符串方法","id":"字符串方法","depth":3,"charIndex":5011},{"text":"Array对象","id":"array对象","depth":2,"charIndex":5925},{"text":"创建数组","id":"创建数组-1","depth":3,"charIndex":6011},{"text":"数组属性","id":"数组属性","depth":3,"charIndex":6091},{"text":"数组方法","id":"数组方法-1","depth":3,"charIndex":6121},{"text":"Date对象","id":"date对象","depth":2,"charIndex":7221},{"text":"创建Date对象","id":"创建date对象","depth":3,"charIndex":7298},{"text":"属性","id":"属性","depth":3,"charIndex":7473},{"text":"方法","id":"方法","depth":3,"charIndex":7869}],"domain":"","frontmatter":{"Author":"lixintao"},"version":""},{"id":98,"title":"Linux 上安装 Nodejs","content":"#\n\n在官网下载：https://nodejs.cn/download/current/\n\n以下代码可以直接复制下来，一键执行；\n\n\n\n安装完之后查看版本，没报错就说明安装好了；\n\n","routePath":"/编程基础/前后端/Linux上安装Nodejs","lang":"","toc":[],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":99,"title":"","content":"MySQL基础#\n\n\n一、数据库基础#\n\n\n1、数据库概述#\n\n①概念：依照某种数据模型组织起来并存放在二级存储器（硬盘）中的数据集合。\n\n②主流的数据库：关系型的有 MySQL、SQLserver、oracle、DB2，非关系型：HBase、NoSQL（mongoDB、redis、memache）\n\n\n2、概念模型#\n\n① 概念：是现实世界到机器世界的一个中间层侧，是数据库设计人员和用户之间交流的工具，通过它可以转换得到数据模型。\n\n② 特点：简单清晰，易于理解，较强的语义表达能力。\n\n③ 涉及到的基本概念：\n\n * 实体（一本书，一个人）\n\n * 属性（对实体的描述）\n\n * 码：\n   \n   * 超码：能够唯一确定的一个实体的一个或多个属性的集合。\n   \n   * 候选码：能够确定一个实体的多个属性。\n   \n   * 主码：能够唯一确定的一个实体的属性。\n\n * 实体型和实体集：课程（课程号、课程名）就是一个实体型，所有课程组成一个实体集。\n\n * 联系\n   \n   * 一对一（1:1）\n   \n   * 一对多（1：n）\n   \n   * 多对多（m：n）\n\n④ E-R模型和E-R图\n\n * 用矩形表示实体，用椭圆表示属性，用菱形表示关系，用直线连接。\n\n\n3、数据模型#\n\n① 数据模型的特点\n\n * 能比较真实的模拟现实世界；\n\n * 容易理解；\n\n * 便于在计算机上实现；\n\n② 数据模型的组成要素\n\n * 数据结构（静态特性的描述）\n\n * 数据操作（主要是查询和更新）\n\n * 完整性约束条件\n\n③ 常见的数据模型\n\n * 层次模型\n   \n   * 定义：用树型结构表示实体之间的联系的模型\n   \n   * 特点：在一个层次模型中的限制条件是：有且仅有一个节点，无父节点，此节点为树的根；其他节点有且仅有一个父节点。\n\n * 网状模型\n   \n   * 定义：用网络结构表示实体类型及其实体之间联系的模型\n   \n   * 特点：\n     \n     * 允许一个以上的节点无父节点\n     \n     * 一个节点可以有多于一个父节点\n\n * 关系模型\n   \n   * 定义：用二维表的形式表示实体和实体之间联系的数据模型\n   \n   * 特点：\n     \n     * 数据结构简单（二维表）\n     \n     * 扎实的理论基础：\n   \n   * 关系运算理论\n   \n   * 关系模式设计理论\n   \n   * 关系数据模型的三种约束完整性\n     \n     * 实体完整性：实体的主键不能取空值。\n     \n     * 参照完整性：是指参照关系中每个元素的外码要么为空(NULL)，要么等于被参照关系中某个元素的主码。\n     \n     * 用户定义完整性：指对关系中每个属性的取值作一个限制(或称为约束)的具体定义。比如 性别属性只能取”男“或”女“\n       ，再就是年龄的取值范围，可以取值0-130 ，但不能取负数，因为年龄不可能是负数。\n\n\n二、MySQL基本知识#\n\n\n1.MySQL概述#\n\n（1）MySQL 是一个小型关系型数据库管理系统。\n\n（2）特点：\n\n * 图形化用户界面，使得系统管理和数据库管理跟家直观、简单。\n\n * 丰富的编程接口工具\n\n * 支持多用户、多线程\n\n * 跨平台使用\n\n\n2.MySQL的安装#\n\n(1) MySQL为免费开源，可以在官网下载安装；Github 链接：https://github.com/mysql/mysql-server\n\n(2) DBeaver 是 MySQL 的图形化管理软件，Github 链接：https://github.com/dbeaver/dbeaver\n\n(3) 点击【连接】，选择 MySQL\n\n(4) 输入连接名（可以自己取名字），输入服务器 IP 地址（本次直接用 localhost 即可），输入服务器端口号、用户名（root）和密码（可以为空）\n\n\n3.远程访问数据库#\n\n(1) 服务器端需要授权：MySQL查询编辑上输入：\n\n\n\n%，是指对所有人，如果是针对某个人，可替换为对应的 IP\n\n(2) 关闭防火墙\n\n(3) Flush privileges（刷新权限）\n\n\n4.MySQL系统数据简介#\n\n(1) 四个系统数据库\n\n * Information schema 是信息数据库。保存 MySQL 服务器维护的其他数据库的信息。\n * MySQL 系统数据库，主要存储了一些存储 MySQL 服务的系统信息表。\n * Performance_schema 用于收集数据库服务器性能参数。\n * Sys 系统数据库，可以了解系统的元数据信息。\n\n(2) 常用的 MySQL 数据类型\n\n * int 整型，可以存储 2 的 31 次方到 2 的 31 次方之间的整数。占用4个字节。\n * Float 浮点型，小数，在 MySQL 里是 4 个字节单精度。\n * Char 字符型，存储制定长度的定长非统一编码型的数据。（固定长度）\n * Varchar 字符型，指定最大长度。（可以小于）\n\n(3) 数据库的基本操作\n\n * create database dbname;（创建数据库）\n\n * Drop database dbname;（删除数据库）\n\n * Create table name;（创建表）\n\n * Varchar(5) 长度为5个字符以内\n\n * Primary key`（主键）\n\n * Not null`（不能为空）\n\n * Create database dbname default character set utf8 collate utf8_general_ci;\n   (创建一个字符集为utf8的数据库，否则输入汉字时，会变成问号）\n\n * Create database test ：代表的是创建数据库 test；\n\n * default character set utf8 ：代表的是将默认编码格式设置为utf8格式；\n\n * collate utf8_general_ci ：代表的是数据库校对规则；\n\n\n三、数据库基本操作#\n\n\n1.数据库对象#\n\n（1）表：有行和列表示；\n\n * 每列为一个字段。\n\n * 每行为一条记录。\n\n * 有一个唯一的主键，主键不能为空。\n\n（2）外键：两个实体中的主键，在关系表中成为外键。\n\n（3）索引（index）：根据指定的数据库表列建立起来的顺序；它提供了快速访问数据的途径。索引所指向的列中的数据不重复。\n\n（4）视图（view）：是查询数据库产生的，从数据库去相应的数据进行呈现，视图内数据无法修改，在基表中修改后，视图表会自动修改。\n\n（5）触发器（trigger .扳机、开枪）：设置一个触发的动作，对表自动进行增删改查。\n\n（6）存储过程（store procedure）:存储在数据库的 SQL 程序。\n\n\n2.表约束#\n\n * 主键约束（primary key）\n   \n   * 一个表通过一个列或多个列组合的数据来唯一标识表总的每一行，这一列或多个列的组合成为主键。\n     \n     * 主键列具有唯一性；\n     \n     * 一个表只有一个主键；\n     \n     * MySQL 通过主键建议唯一索引，加快对主键的查询速度；\n   \n   * 主键约束两种写法\n     \n     * 列级约束：直接在字段后定义 primary key；\n       \n       \n     \n     * 表级约束：先写完表，再定义表里的 primary key；\n       \n       \n\n * 外键约束（foreign）\n   \n   定义：建立和强调两个表之间的关系，即关系表的一个列与另一个表中的具有唯一性的列相关，这个列就是关系表中的外键。\n\n * 唯一性约束（unique）\n   \n   * 保证在非主键的指定唯一性的列上不会出现重复的数据（在学生表中指定了学好为主键，身份证列作为非主键建立唯一性约束，则身份证号不能重复）；\n   \n   * 唯一性约束可以建立在多个非主键的列上，而且允许为空值（和主键约束的区别）；\n\n * 检查约束（check）：在 MySQL 上没有用；\n\n * 默认值约束（default）：如果用户没有明确出某一列的值，将显示为默认值；\n\n * 空值约束（null）：不为空时约束为 not null， 为空为 null，为空可以不写。\n\n\n3.SQL结构化查询语句#\n\nSQL（structrued query language）查询语句包含四类：\n\n * 数据定义语言（DDL，data definition language）\n\n * 数据操纵语言（DML,data manipulation language）\n\n * 数据控制语言（DCL,data control language）\n\n * 系统存储语言（System Stored procedure）\n\n3.1.数据定义语言#\n\n(1) Create table（建表）\n\n\n\n(2) Create index（建索引）\n\n(3) Alter table（修改表）\n\n(4) Drop table（删表）\n\n① Drop table 表名（删除某个表）\n\n(5) Drop index（删索引）\n\n(6) Insert into....select... 表示将一个表中的数据插入到另一个表中\n\n\n\n(7) update 表名 set 列名=’更新值’ Where.. (表示更新某个字段数据）\n\n\n\n(8) delete from 表名 Where.. （表示删除某行数据）(drop 是直接删表，delete是对表中的数据进行删除)\n\n\n\n（9）alter table修改表\n\n * 修改表名：Alter table 原表名 rename to 目标表名\n   \n   \n\n * 新增字段：Alter table 表名 add 字段名 varchar(50) null\n   \n   \n\n * 修改字段属性：Alter table 表名 change 原字段名 新字段名 varchar(4)\n   \n   \n\n * 删除字段：alter table 表名 drop column 字段名\n   \n   \n\n3.2.数据操纵语言#\n\n(1) insert插入语句#\n\n\n\n表示向 student表中插入一行数据。\n\n\n\n表示将 student1 中的内容插入到 student2 中。\n\n(2) select查询#\n\n① Select * From student\n\n(查询 student 表中所有列)\n\n② Distinct 过滤重复行\n\n\n\n（从成绩表中查询剔重后的学号）\n\n(3) Where 子句，指定条件查询#\n\n① 范围运算符 between...and..，not between....and...（（不）在什么之间）\n\n\n\n② 列表运算符 in ，not in（表示在指定项中）\n\n\n\n③ 空值判断符 is null , is not null （是否为空）\n\n\n\n④ 逻辑运算符 and , or\n\n * And 表示同时满足\n * Or 表示满足一个条件即可\n\n(4) 模糊匹配like ， not like#\n\n① 匹配任意类型长度的字符用 %，固定长度字符用下划线 _\n\n\n\n表示查询命中中带有“王”的姓名\n\n② 指定一个字符、字符串或范围用[ ]、[^ ]\n\n\n\n表示名字开头是 b-k 的姓名\n\n(5) 集合函数（聚合函数）#\n\n① 平均值 avg\n\n② 总和 sum\n\n③ 最小值 min\n\n④ 最大值 max\n\n⑤ 计数 count\n\n集合函数使用在select 后面\n\n\n\n表示在表中，取价格的最小值，min(price) as 价格\n\n(6) Group by 子句，分组#\n\n① Group by 子句中，不能使用集合函数\n\n\n\n表示已性别作为分组，统计显示姓名和性别\n\n② select 中多个非集合项出现时，group by 里面也要有同样的非集合项\n\n(7) Order by 排序：#\n\n对查询结果按照升序（asc）或降序（desc）排列。\n\n\n\n表示将 student 表中的男生，按照年龄降序排列，显示姓名和年龄\n\n(8)having ...条件#\n\nHaving 子句与 group by 使用表示增加某个条件。\n\n\n\n(9)嵌套查询#\n\n①Where 表达式 （not）in (子查询)\n\n\n\n②比较运算符\n\n * Any : where degree >any(81.85) 表示degree 大于81或85中的任意一个。\n * All : where degree >all(81.85) 表示degree 大于81或85中的每一个。\n * Some ：同 any\n\n③联接查询\n\n * 内连接\n   \n   \n   \n   或\n   \n   \n\n * 外连接\n   \n   * 左联接：（以左边表为基准，左边所有数据要出现，右边表无数据的，为空值）\n     \n     \n   \n   * 右联接： (以右边表为基准，右边所有数据要出现，左边表无数据的，为空值）\n     \n     \n\n3.3.数据控制语言（DCL）#\n\n（1）grant 语句\n\nGrant 权限1，权限2 on 表名 to uername\n\n为某个用户授予某个权限\n\n\n\n（2）Revoke 语句\n\nRevoke 权限1，权限2 on 表名 from uername\n\n收回某个用户的某个权限\n\n\n\n3.4.View 视图#\n\n（1）视图是某个查询结果的虚表。试图对应的数据并不实际存在。\n\n（2）语法：create view 视图名称 As Select 列名称 from 表名称 where 条件\n\n\n\n（3）修改视图：drop view 视图名称。\n\n3.5.procedure 存储过程#\n\n（1）存储过程的三个组成部分。\n\n * 所有的输入参数以及传给调用者的输出参数；\n * 被执行的正对数据库的操作语句，包括调用其它存储过程的语句；\n * 返回给调用者的状态值，以指明调用是否成功；\n\n（2）使用 DBeaver 创建存储过程\n\n * 点击函数右键，选择新建函数，输入定义模式、参数名、数据类型；\n\n * 点击完成，在 begin 和 end 之间存储过程语句，点击保存，设置过程名；\n   \n   \n   \n   调用的使用：call 过程名（赋值）；\n\n3.6.trigger 触发器#\n\n（1）触发器是一种特殊类型的存储过程，主要通过事件进行触发而被执行。触发器用于MySQL约束、默认值和规则的完整新的检查。\n\n（2）触发器类型：\n\n * Update 在更新时触发；\n * Insert 在插入时触发；\n * Delete 在删除操作时触发；\n * After 在一个触发动作之后激活；\n\n（3）语法：\n\n\n\n表示当对 student 表进行更新之后，将一组数据插入到 student_1 表中。\n\n3.7.常见函数#\n\n（1）Left/right 函数\n\nSelect left (‘kdhoa’,3) 表示从左向右，截取3个字节\n\n（2）Length 函数\n\nSelect length(‘ijgoado’) 表示括号内字符的长度\n\n（3）Replace 函数\n\nSelect replace (‘ydk’,’k’,’a’) 表示将字符中的k 替换成a\n\n（4）Substring 函数\n\nSelect substring (‘eohgdhd’,2,3) 表示从第2位开始取，往后取3位(ohg)\n\n（5）日期函数\n\n * Now( )：表示当前日期，精确到时分秒 2019-10-29 19:31:20 ；\n * curdate( )：表示当前时间，精确到日 2019-10-29\n * Year( )：表示日期年份 2019\n * Month( )：表示日期月份 10\n * Day( )：表示日期的日 29\n\n（6）Datediff 函数\n\n * 表示函数返回两个日期之间的天数\n * Select datediff (‘time1’,’time2’) 计算逻辑是 time1-time2","routePath":"/编程基础/前后端/MySQL基础","lang":"","toc":[{"text":"MySQL基础","id":"mysql基础","depth":2,"charIndex":-1},{"text":"一、数据库基础","id":"一数据库基础","depth":2,"charIndex":10},{"text":"1、数据库概述","id":"1数据库概述","depth":3,"charIndex":21},{"text":"2、概念模型","id":"2概念模型","depth":3,"charIndex":152},{"text":"3、数据模型","id":"3数据模型","depth":3,"charIndex":544},{"text":"二、MySQL基本知识","id":"二mysql基本知识","depth":2,"charIndex":1271},{"text":"1.MySQL概述","id":"1mysql概述","depth":3,"charIndex":1286},{"text":"2.MySQL的安装","id":"2mysql的安装","depth":3,"charIndex":1405},{"text":"3.远程访问数据库","id":"3远程访问数据库","depth":3,"charIndex":1669},{"text":"4.MySQL系统数据简介","id":"4mysql系统数据简介","depth":3,"charIndex":1781},{"text":"三、数据库基本操作","id":"三数据库基本操作","depth":2,"charIndex":2575},{"text":"1.数据库对象","id":"1数据库对象","depth":3,"charIndex":2588},{"text":"2.表约束","id":"2表约束","depth":3,"charIndex":2903},{"text":"3.SQL结构化查询语句","id":"3sql结构化查询语句","depth":3,"charIndex":3556},{"text":"3.1.数据定义语言","id":"31数据定义语言","depth":4,"charIndex":3770},{"text":"3.2.数据操纵语言","id":"32数据操纵语言","depth":4,"charIndex":4324},{"text":"3.3.数据控制语言（`DCL`）","id":"33数据控制语言dcl","depth":4,"charIndex":-1},{"text":"3.4.View 视图","id":"34view-视图","depth":4,"charIndex":5690},{"text":"3.5.procedure 存储过程","id":"35procedure-存储过程","depth":4,"charIndex":5819},{"text":"3.6.trigger 触发器","id":"36trigger-触发器","depth":4,"charIndex":6076},{"text":"3.7.常见函数","id":"37常见函数","depth":4,"charIndex":6302}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":100,"title":"Vue基础","content":"#\n\n\nVue简介#\n\nVue.js（通常简称为 Vue）是一个用于构建用户界面的渐进式 JavaScript\n框架。它被设计为易于上手的同时，也能在需要时支持高级功能和复杂的应用架构。\n\n核心特点\n\n 1. 声明式渲染：Vue 使用声明式语法，使得开发者只需描述应用的状态，Vue 会自动渲染视图。这简化了 DOM 操作的复杂性。\n\n 2. 组件系统：Vue 允许开发者通过小型、独立的可复用组件构建大型应用。组件可以独立编写，然后组合在一起。\n\n 3. 响应式原理：Vue 的数据模型是响应式的，当数据变化时，视图会自动更新。这种数据绑定大大减少了 DOM 操作的代码量。\n\n 4. 虚拟 DOM：Vue 使用虚拟 DOM 来提高渲染性能。在数据变化时，Vue 会先在虚拟 DOM 上进行操作，然后通过对比算法找出实际 DOM\n    需要变更的最小部分。\n\n 5. 过渡效果：Vue 提供了过渡效果的封装，使得在插入、更新或移除 DOM 元素时，可以轻松实现动画效果。\n\n 6. 插件和生态系统：Vue 拥有一个丰富的插件生态系统，包括路由器（Vue Router）和状态管理库（Vuex），以及其他工具和服务。\n\n 7. 单文件组件：使用 Vue 的单文件组件（.vue 文件），可以将模板、脚本和样式封装在一个文件中，使得组件更加模块化。\n\n\n使用Vue的三种方式#\n\n官方文档：https://cn.vuejs.org\n\n使用vue的三中方式：\n\n * 直接下载并用<script>标签导入\n\n * CDN方式引入：<script\n   src=\"https://cdn.jsdelivr.net/npm/vue@2.5.16/dist/vue.js\"></script>\n\n * npm install vue\n\nCDN方式\n\n\n\nnpm 安装的方式\n\n要使用vue需要先下载安装nodejs，下载地址：https://nodejs.org/en/，其自带包管理器：npm。\n\n新建一个项目目录，在该项目目录下安装vue: npm install vue --save\n\n\n基本语法#\n\nVue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML\n，所以能被遵循规范的浏览器和 HTML 解析器解析。\n\n在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。\n\n\n创建Vue对象#\n\n使用 new Vue() 创建一个 Vue 实例是使用 Vue.js 框架构建应用的第一步\n\n当你创建一个新的 Vue 实例时，基本的语法结构如下：\n\n\n\nel\n\n * 提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是 DOM 元素本身。\n   \n   \n\ndata\n\n * Vue 实例的数据对象\n   \n   \n\n\nHTML插值#\n\n格式：{{XXX}} 功能：用于解析标签体内容。 写法：xxx是js表达式，且可以直接读取到data中的所有属性。\n\n\n\n\n\n\n指令系统#\n\n在vue中提供了一套为(数据驱动视图)更方便的操作，这些操作称为指令系统，以v-xxx表示。\n\n\nv-text和v-html#\n\nv-text等价于{{}}插值，内部实现原理 innerText v-html内部实现原理 innerHTML\n\n\n\n\n\n\nv-if 和 v-else#\n\n根据表达式的布尔值(true/false)进行判断是否渲染/显示该元素\n\n * v-if\n\n * v-else\n\n * v-else-if\n\n\n\n\nv-if和v-show#\n\n两者都可以用来对当前DOM显示或者隐藏，当isShow是true时显示，是false时隐藏。\n\n不过两者隐藏的方式不一致。\n\n * v-if 是一个条件渲染指令，它确保在切换过程中条件块内的事件监听器和子组件被适当地销毁和重建。当条件为假时，元素不会被渲染到 DOM\n   中；当条件为真时，元素会被渲染到 DOM 中。换句话说，v-if 是 “真正” 的条件渲染，因为它会根据条件动态地添加或移除 DOM 元素。\n\n * v-show 则简单得多，不管初始条件是什么，元素总是会被渲染到 DOM 中，并且仅仅通过切换 CSS 的 display\n   属性来控制显示和隐藏。当条件为真时，元素的 display 属性设置为默认值（通常是 display: block），当条件为假时，display\n   属性被设置为 display: none。\n\n性能影响的区别\n\n * v-if 有更高的切换开销，因为每次切换时它都必须进行 DOM 的添加或删除操作，以及事件监听器和子组件的销毁和重建。\n\n * v-show 有更高的初始渲染开销，因为无论条件如何，元素都会被渲染到 DOM 中。但是，由于它只是简单地切换 CSS\n   属性，所以在条件频繁变化时，v-show 的性能通常比 v-if 更好。\n\n\n\n\n\nv-if不仅可以插入数据属性，也可以做运算判断来判断是否显示\n\n\n\n\nv-for#\n\nVue 中的 v-for 指令用于基于一个数组渲染一个列表。它可以遍历数组或对象，然后为每个元素生成模板中定义的 DOM 结构。\n\n\n\n\n\n\nv-bind#\n\n用于动态地绑定一个或多个属性，或者一个组件 prop 到表达式。这意味着绑定后的属性值会随着表达式的变化而变化。\n\nv-bind 指令的基本语法格式如下：\n\n\n\n或者使用简写形式：\n\n\n\n其中 attribute 是 HTML 元素的属性名（如 href, src, title, class 等），而 expression 是一个 Vue.js\n表达式，其结果会被计算然后用于更新相应的属性。\n\n\n\n\nv-on#\n\nVue 中的 v-on 指令用于监听 DOM 事件，当指定的事件被触发时，可以执行相应的 JavaScript\n代码。它是最常用的指令之一，尤其是在构建用户交互界面时。\n\nv-on 指令的基本语法格式如下：\n\n\n\n或者使用简写形式：\n\n\n\n其中 event 是要监听的事件名称（如 click, submit, mouseover 等），而 handler 是一个方法名或者内联 JavaScript\n代码。\n\n通常，handler 是组件方法中的一个函数名：\n\n\n\n在这个例子中，当按钮被点击时，increment 方法将被调用。\n\n点击button会对指定DOM进行隐藏和显示\n\n\n\n\n\n\nv-models#\n\n它用于在输入和应用状态之间创建双向数据绑定。这意味着当用户在输入框中输入内容时，绑定的数据模型会实时更新；反之，当更新了数据模型，绑定的输入也会更新其显示值。\n\n基本语法\n\n\n\n这里的 dataProperty 是 Vue 实例数据对象中的一个属性。v-model 会监听用户的输入事件，并在输入框的值变化时更新\ndataProperty。\n\n双向绑定原理\n\n在 Vue 中，v-model 是一个语法糖，本质上它是由两个操作组成的：\n\n 1. v-bind 用于绑定一个 value 属性到输入元素上。\n\n 2. v-on 用于监听输入事件（如 input 事件），并在事件触发时更新数据。\n\n以下是一个等价的例子，展示了 v-model 背后的原理：\n\n\n\n这里的 :value 是 v-bind:value 的缩写，而 @input 是 v-on:input 的缩写。\n\n\n\n\n\n\n组件#\n\n\n简介#\n\n在 Vue 中，组件是可复用的\nUI片段，它封装了特定的功能和外观。可以将组件视为独立的小模块，每个组件负责一部分特定的任务，比如显示一个按钮、一个表单或者一个复杂的页面布局。\n\n\n\n\n组件作用#\n\n * 提高可维护性：将应用拆分成多个小的组件，使得每个组件的功能相对单一，易于理解和修改。当应用的某个部分出现问题时，可以快速定位到相应的组件进行修复。\n * 可复用性：一旦创建了一个组件，可以在不同的地方重复使用，减少代码重复。例如，一个通用的输入框组件可以在多个页面中使用。\n * 团队协作：不同的开发人员可以同时开发不同的组件，提高开发效率。\n\n\n组件的本质#\n\n组件的本质是一个带有 template、script 和 style 的自包含模块：\n\ntemplate：定义了组件的结构和内容。\n\n * script：包含组件的逻辑，如数据、方法和生命周期钩子。\n\n * style：定义了组件的样式，可以使用 Scoped CSS 来确保样式仅作用于当前组件。\n\n\n组件分类#\n\n组件分为\n\n * 全局组件\n\n * 局部组件\n\n全局组件： 在整个应用中都可以使用的组件。通过在 Vue 实例创建之前使用 Vue.component() 方法进行注册。例如：\n\n\n\n局部组件： 只在特定的组件内部使用的组件。在组件的选项中通过 components 属性进行注册。例如：\n\n\n\n局部组件创建和使用\n\n\n\n使用全局组件\n\n单文件组件是 Vue 中推荐的组件编写方式，它将一个组件的模板、脚本和样式写在一个以 .vue 为后缀的文件中\n\n\n\n全局组件注册，注册后用法和局部组件一样\n\n\n\n\n组件命名格式#\n\n组件的命名可以使用驼峰式命名法或短横线分隔命名法。在注册组件时，需要保持命名的一致性。例如：\n\n","routePath":"/编程基础/前后端/Vue基础","lang":"","toc":[{"text":"Vue简介","id":"vue简介","depth":2,"charIndex":3},{"text":"使用Vue的三种方式","id":"使用vue的三种方式","depth":2,"charIndex":576},{"text":"基本语法","id":"基本语法","depth":2,"charIndex":893},{"text":"创建Vue对象","id":"创建vue对象","depth":3,"charIndex":1088},{"text":"HTML插值","id":"html插值","depth":3,"charIndex":1284},{"text":"指令系统","id":"指令系统","depth":2,"charIndex":1357},{"text":"v-text和v-html","id":"v-text和v-html","depth":3,"charIndex":1413},{"text":"v-if 和 v-else","id":"v-if-和-v-else","depth":3,"charIndex":1491},{"text":"v-if和v-show","id":"v-if和v-show","depth":3,"charIndex":1581},{"text":"v-for","id":"v-for","depth":3,"charIndex":2188},{"text":"v-bind","id":"v-bind","depth":3,"charIndex":2267},{"text":"v-on","id":"v-on","depth":3,"charIndex":2478},{"text":"v-models","id":"v-models","depth":3,"charIndex":2782},{"text":"组件","id":"组件","depth":2,"charIndex":3187},{"text":"简介","id":"简介","depth":3,"charIndex":3193},{"text":"组件作用","id":"组件作用","depth":3,"charIndex":3291},{"text":"组件的本质","id":"组件的本质","depth":3,"charIndex":3475},{"text":"组件分类","id":"组件分类","depth":3,"charIndex":3635},{"text":"组件命名格式","id":"组件命名格式","depth":3,"charIndex":3894}],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"web基础","content":"dom,请求方式,事件，浏览器开发工具介绍\n\n\nweb基础#\n\n本教程旨在帮助初学者了解 Web 开发的基础知识，包括 DOM 操作、请求方式、事件处理以及如何使用浏览器开发工具。\n\n\nDOM#\n\nDOM它提供了对文档的结构化的表述，并定义了一种方式可以使程序和脚本能够对文档的内容、结构和样式进行访问和操作。\n\n\nDOM 树结构#\n\n * 文档：整个 HTML 页面\n * 元素：页面中的所有标签，如 <div>, <a>, <span> 等\n * 属性：元素的属性，如 class, id, href 等\n * 文本：元素中的文本内容\n\n\n操作 DOM 元素简述#\n\nDOM 操作是指对页面标签进行操作。如：设置样式、设置文本、设置属性、删除标签、事件绑定等\n\n\n获取标签#\n\ndocument.getElementById()\n\n返回对拥有指定 id 的第一个元素的引用。ID 是唯一的，所以这个方法每次最多只返回一个元素。\n\n\n\ndocument.getElementsByTagName()\n\n返回一个包含所有指定标签名称的元素的 HTML 集合（HTMLCollection）。这是一个动态的集合，意味着如果文档中的元素发生变化，它也会随之更新。\n\n\n\ndocument.getElementsByClassName()\n\n此方法返回一个包含了所有拥有指定类名的元素的 HTML 集合（HTMLCollection）。\n\n\n\ndocument.querySelector()\n\n此方法返回文档中第一个匹配指定选择器的元素。选择器可以是 CSS 选择器。\n\n\n\ndocument.querySelectorAll()\n\n此方法返回一个包含了所有匹配指定选择器的元素的 节点 集合。与querySelector()不同，它返回所有匹配的元素而不仅是第一个。\n\n\n\nelement.querySelector()&element.querySelectorAll()\n\n与 document.querySelector() 和 document.querySelectorAll() 类似，但它们是在已存在的 DOM\n元素上调用，用于查找该元素的后代元素。\n\n\n\nelement.children & element.childNodes\n\n * element.children 是一个 HTMLCollection，包含了元素的所有子元素（不包含文本节点和注释）。\n\n * element.childNodes 是一个 NodeList，包含了元素的所有子节点，包括元素节点、文本节点和注释节点。\n\n\n\nelement.parentNode 和 element.parentElement\n\n * element.parentNode 返回元素的父节点，可能是元素节点，也可能是文本节点或其他类型的节点。\n * element.parentElement 返回元素的父元素节点（不包括文本节点和注释节点）。\n\n\n\n\n修改内容#\n\ninnerHTML\n\ninnerHTML 属性设置或获取 HTML 元素的内容。当用来设置时，它会解析字符串中的 HTML 标签，并将其插入到元素中。\n\n\n\ntextContent 或 innerText\n\n * textContent 属性设置或获取元素及其后代的文本内容。与innerHTML不同，textContent不会解析 HTML 标签。\n\n * innerText 是一个类似的属性，但它在处理空白符时与textContent有所不同，并且不是标准的 DOM 属性。\n\n\n\nvalue\n\n对于表单元素（如<input>, <textarea>），可以使用value属性来获取或设置其值。\n\n\n\nsetAttribute()\n\nsetAttribute() 方法用于设置元素属性的值。\n\n\n\n\n创建标签#\n\n通过 document.createElement(\"标签名\") 创建标签。\n\n\n\n\n插入和删除#\n\n在元素内部的末尾插入内容\n\n\n\n在元素内部的开头插入内容\n\n\n\n移除元素\n\n\n\n替换元素内容，使用replaceChild()替换子元素\n\n\n\n\n事件#\n\n事件是指某种程序的驱动行为。事件就是行为，行为发生了，代码块被执行了 ，触发了事件。用户或浏览器自身执行的某种动作，如点击按钮、加载页面或按下键盘按键等事件。\n\n通常通过 dom. 事件行为 = function(){函数内容} 绑定事件。\n\n\n事件的基本概念#\n\n * 事件（Event）：是文档或浏览器窗口中发生的特定交互瞬间。\n\n * 事件监听器（Event Listener）：也称为事件处理器，是等待事件发生并触发响应代码的函数。\n\n * 事件目标（Event Target）：是发生事件的对象，例如按钮、输入框等。\n\n\n事件类型#\n\n鼠标事件：\n\n * click：鼠标点击\n\n * dblclick：鼠标双击\n\n * mousedown：鼠标按钮被按下\n\n * mouseup：鼠标按钮被释放\n\n * mousemove：鼠标移动\n\n * mouseover：鼠标移入元素\n\n * mouseout：鼠标移出元素\n\n * contextmenu：右键点击\n\n键盘事件：\n\n * keydown：键盘按键被按下\n\n * keyup：键盘按键被释放\n\n * keypress：键盘按键被按下并释放\n\n表单事件：\n\n * submit：表单提交\n\n * change：表单元素值改变\n\n * focus：元素获得焦点\n\n * blur：元素失去焦点\n\n文档事件：\n\n * DOMContentLoaded：文档加载完成\n\n * load：整个页面及所有依赖资源加载完成\n\n * unload：页面正在卸载\n\n窗口事件：\n\n * resize：窗口大小改变\n\n * scroll：页面滚动\n\n\n事件处理#\n\n行内事件处理：直接在 HTML 标签内添加事件处理属性，例如 onclick。\n\n\n\n属性添加事件处理：在 JavaScript 中获取 DOM 元素，然后为其事件属性赋值一个函数。\n\n\n\n添加事件监听器：使用addEventListener方法为元素添加事件监听器。\n\n\n\n\n事件对象#\n\n当一个事件被触发时，浏览器会自动生成一个事件对象并将其作为参数传递给事件处理函数。这个事件对象包含了有关该事件的各种信息可以用来获取和操作事件的相关属性和方法。\n\n * event.type：事件的类型\n\n * event.target：触发事件的目标元素\n\n * event.clientX / event.clientY：鼠标事件发生时的窗口坐标\n\n * event.key：键盘事件中按下的键的值\n\n\n请求方式#\n\n在 Web 开发中，HTTP 请求方式定义了客户端与服务器之间的不同类型的交互，以下是常见请求方式的详解：\n\n\nGET#\n\n用于请求服务器发送资源或数据。\n\n * 数据在 URL 中传递，通过查询字符串的形式附加在请求地址后。\n\n * 没有请求体（body）。\n\n * 安全性较低，因为数据在 URL 中暴露。\n\n * 幂等操作，意味着多次执行同一请求，资源的状态不会改变。\n\n适用场景：获取资源，如检索页面、查询数据。\n\n\nPOST#\n\n用于向服务器提交数据。\n\n * 数据在请求体中传递。\n * 可以发送大量数据。\n * 不是幂等操作，多次执行同一请求可能会产生不同的结果。\n * 更安全，因为数据不会在 URL 中暴露。\n\n适用场景：表单提交、上传文件、创建资源。\n\n\nPUT#\n\n用于更新服务器上的资源。\n\n * 数据在请求体中传递。\n * 通常用于完整地替换资源或集合。\n * 幂等操作，多次执行同一请求，资源的状态最终是相同的。\n\n适用场景：更新资源，如更新用户信息。\n\n\nDELETE#\n\n用于删除服务器上的资源。\n\n * 通常没有请求体。\n\n * 幂等操作，多次执行同一请求，资源最终都会被删除。\n\n适用场景：删除资源，如删除一条用户记录。\n\n\nPATCH#\n\n用于对资源进行部分更新。\n\n * 数据在请求体中传递。\n\n * 不是幂等操作，因为多次执行同一请求可能会得到不同的结果\n\n适用场景：对资源进行部分修改，如修改用户的部分信息。\n\n\nHEAD#\n\n类似于 GET 请求，但服务器不会返回请求的资源，只返回响应头。\n\n * 用于检查资源的元数据，如验证资源是否存在或获取资源的最后修改时间。\n\n适用场景：获取资源的元信息。\n\n\nOPTIONS#\n\n用于获取指定 URL 支持的方法列表。\n\n允许客户端查看服务器支持哪些 HTTP 方法。\n\n适用场景：CORS（跨源资源共享）中的 “预检” 请求。\n\n\nAJAX发送各种请求#\n\nAJAX，全称“Asynchronous JavaScript and\nXML”（异步JavaScript和XML），是一种用于创建交互式网页应用的网页开发技术。\n\n它允许浏览器与服务器之间进行异步数据交互，可以在不重新加载整个页面的情况下，更新页面的部分内容。\n\n\n结合jQuery发送AJAX请求#\n\n使用 jQuery 结合 AJAX 发送 HTTP 请求可以更加简洁和方便，因为 jQuery 提供了一套高层次的 AJAX 实现。以下是使用 jQuery\n发送各种 HTTP 请求的示例。\n\n引入 jQuery\n\n首先，确保在 HTML 文件中引入了 jQuery 库。\n\n\n\nGET 请求\n\n\n\nPOST 请求\n\n\n\nPUT 请求\n\n\n\nDELETE 请求\n\n\n\nPATCH 请求\n\n\n\nHEAD 请求\n\n\n\nOPTIONS 请求\n\n\n\n\n结合HTML发送#\n\n\n\n\n浏览器开发工具#\n\n浏览器开发者工具是一套内置于浏览器中的工具集，用于帮助开发者调试网页、查看源代码、检查网络请求等。\n\n\n初识开发者工具#\n\n打开浏览器开发者工具。你可以通过右键点击页面，选择“检查”，会打开浏览器开发者工具。或者使用快捷键Ctrl + Shift + I\n\n\n\n重要面板简介\n\n * Elements（元素）面板：用于查看和编辑HTML结构。你可以通过这个面板直接修改页面元素的HTML代码，实时预览修改效果。\n\n * Console（控制台）面板：用于输出调试信息、执行JavaScript代码等。这个面板在开发过程中非常有用，可以快速测试代码片段和查看错误信息。\n\n * Sources（源代码）面板：用于查看和管理网页的JavaScript、CSS等资源文件。你可以在这里查看文件内容、设置断点以及单步执行代码。\n\n * Network（网络）面板：用于监控网页加载过程中发送和接收的所有网络请求。你可以查看请求的详细信息、请求/响应头和内容等。\n\n * Performance（性能）面板：用于分析网页性能瓶颈，通过记录和分析页面加载过程中的事件，找出影响性能的因素。\n\n * Memory（内存）面板：用于分析内存使用情况，帮助查找内存泄漏和优化内存使用。\n\n\nElements 元素面板#\n\n主要用于查看和编辑网页的HTML结构。通过Elements面板，开发者可以方便地导航和修改HTML代码，实时预览修改后的效果。\n\n\n\n以下是Elements面板的详细作用：\n\n * 查看和编辑HTML：在Elements面板中，你可以直接查看网页的HTML源代码，并且可以即时地编辑这些代码。这种交互式编辑的特点使得开发者可以快速尝试不\n   同的代码修改，实时查看修改后的效果。\n\n * 定位和选择元素：通过使用鼠标或键盘快捷键，你可以在Elements面板中定位和选择特定的HTML元素。这对于精确地定位和修改页面中的特定部分非常有用。\n\n * 查找和替换文本：在Elements面板中，你可以在整个HTML文档中查找和替换特定的文本或标记，这在需要批量修改页面内容时非常方便。\n\n * 检查元素属性：每个HTML元素都有一系列的属性和方法。在Elements面板中，你可以查看和编辑这些属性，进一步了解元素的特性和行为。\n\n * DOM树形视图：Elements面板以树形结构展示了整个HTML文档的结构，这有助于开发者更好地理解页面布局和结构。\n\n * 样式编辑器：除了可以查看和编辑HTML外，Elements面板还提供了样式编辑器，允许你直接编辑元素的CSS样式。这使得开发者可以更快地调整样式，而无\n\n * 需在HTML和CSS之间来回切换。\n\n * 实时预览：在编辑HTML或CSS时，Elements面板会实时预览所做的更改。这意味着你无需刷新页面就可以看到修改后的效果，大大提高了开发效率。\n\n查看和编辑HTML，直接在Elements中编辑元素页面即可立即呈现\n\n直接左键双击页面元素进行编辑，下面将<a>标签中的内容修改，页面立即展示出修改的内容\n\n\n\n根据页面内容定位元素位置，点击面板左上角的箭头，就可以选中页面中的内容直接定位到面板中的元素位置\n\n\n\n点击后，图标颜色变为蓝色说明启动了该功能，鼠标在页面上滑动，右侧面板中实时展示到对应元素的位置\n\n\n\n\nConsole 控制台面板#\n\n主要用于显示网页在加载过程中产生的各类信息，包括错误、警告、调试信息等，也可以直接在这个面板中编辑js代码\n\n\n\n以下是Console面板的主要功能和使用方法：\n\n * 日志输出：Console面板可以显示由JavaScript代码输出的日志信息，包括普通信息（log）、警告（warning）、错误（error）等。这些信\n   息对于调试和排查问题非常有用。\n\n * 命令行交互：Console面板提供了一个类似于命令行的界面，允许你直接输入和执行JavaScript代码。你可以在这里测试代码片段、查看变量值、调用函数等\n   。\n\n * 自动完成和历史记录：Console提供了自动完成功能，根据你输入的内容提供代码补全建议。此外，还会保存你输入的历史记录，方便你快速复用之前的命令。\n\n * 格式化输出：Console面板支持格式化输出，允许你控制日志信息的显示格式，包括控制台输出的颜色、字体等。\n\n * 清除控制台：如果你在控制台中输出了很多日志信息，可以使用清除按钮来清空控制台的内容。你也可以使用快捷键（通常是Ctrl+L或Cmd+K）来快速清除控制台。\n\n使用Console面板是开发过程中排查问题、调试代码的重要手段之一。通过查看控制台中的日志信息，你可以快速定位和解决潜在的问题。同时，利用控制台的命令行交互功能\n，你可以方便地进行代码测试和调试。\n\n\nSources 源代码面板#\n\n主要用于浏览和管理网页的源代码，页面请求和加载的源代码都在这个面板中可见。\n\n\n\n以下是Sources面板的主要功能和使用方法：\n\n * 浏览源代码：在Sources面板中，你可以查看网页的HTML、CSS、JavaScript等源文件。这些文件通常保存在本地或在服务器上，Sources面板\n   允许你方便地访问和查看它们。\n\n * 实时编辑：在Sources面板中，你可以实时编辑网页的源代码。对于JavaScript代码，你甚至可以设置断点，进行单步执行等操作。这种交互式的编辑方式使\n   得开发者可以快速尝试不同的代码修改，实时查看修改后的效果。\n\n * 调试代码：在编辑器中打开JavaScript文件时，你可以在代码行号旁边单击来设置断点。当代码执行到断点处时，执行会暂停，允许你检查当前作用域中的变量值、\n   调用栈等信息。你可以使用控制台来输出调试信息、执行特定命令等。\n\n * 控制台输出：在Sources面板中，你可以使用控制台来输出调试信息、执行JavaScript代码等。控制台提供了一个交互式的环境，方便你进行代码测试和调试\n   。\n\n * 资源管理：除了浏览和编辑源代码，Sources面板还提供了资源管理功能。你可以查看和管理网页加载的所有资源文件，包括脚本、样式表、图片等。这些资源文件可以\n   在面板中直接编辑或删除。\n\n\nNetwork 网络面板#\n\n主要用于监控和记录网页加载过程中发生的所有网络请求\n\n\n\n以下是Network面板的主要功能和使用方法：\n\n * 请求监控：Network面板以表格形式列出了所有网络请求的详细信息，包括请求的URL、方法、状态码、响应大小等。你可以实时查看每个请求的详细信息，了解请求\n   的流程和状态。\n\n * 时间轴视图：除了表格视图外，Network面板还提供了时间轴视图，以更直观的方式展示网络请求的顺序和加载时间。你可以查看每个请求的发起时间、完成时间以及在\n   时间轴上的位置。\n\n * 筛选和排序：Network面板提供了筛选和排序功能，你可以根据请求的类型、状态码、资源类型等对请求进行筛选，或者按照时间、大小等对请求进行排序。这有助于你\n   快速找到特定的请求或分析请求的性能瓶颈。\n\n * 查看请求/响应详情：对于每个网络请求，Network面板提供了详细的请求和响应头信息，以及响应的内容。你可以查看HTTP请求和响应的完整内容，以便更好地理\n   解网络请求的过程和结果。\n\n * 性能分析：通过Network面板，你可以分析网页加载的性能瓶颈。你可以查看每个请求的加载时间、大小以及在时间轴上的位置，找出导致性能问题的原因。","routePath":"/编程基础/前后端/Web基础","lang":"","toc":[{"text":"DOM","id":"dom","depth":2,"charIndex":92},{"text":"DOM 树结构","id":"dom-树结构","depth":3,"charIndex":157},{"text":"操作 DOM 元素简述","id":"操作-dom-元素简述","depth":3,"charIndex":271},{"text":"获取标签","id":"获取标签","depth":3,"charIndex":333},{"text":"修改内容","id":"修改内容","depth":3,"charIndex":1262},{"text":"创建标签","id":"创建标签","depth":3,"charIndex":1622},{"text":"插入和删除","id":"插入和删除","depth":3,"charIndex":1672},{"text":"事件","id":"事件","depth":2,"charIndex":1753},{"text":"事件的基本概念","id":"事件的基本概念","depth":3,"charIndex":1881},{"text":"事件类型","id":"事件类型","depth":3,"charIndex":2024},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":2458},{"text":"事件对象","id":"事件对象","depth":3,"charIndex":2604},{"text":"请求方式","id":"请求方式","depth":2,"charIndex":2815},{"text":"GET","id":"get","depth":3,"charIndex":2878},{"text":"POST","id":"post","depth":3,"charIndex":3035},{"text":"PUT","id":"put","depth":3,"charIndex":3160},{"text":"DELETE","id":"delete","depth":3,"charIndex":3265},{"text":"PATCH","id":"patch","depth":3,"charIndex":3353},{"text":"HEAD","id":"head","depth":3,"charIndex":3451},{"text":"OPTIONS","id":"options","depth":3,"charIndex":3547},{"text":"AJAX发送各种请求","id":"ajax发送各种请求","depth":2,"charIndex":3634},{"text":"结合jQuery发送AJAX请求","id":"结合jquery发送ajax请求","depth":3,"charIndex":3781},{"text":"结合HTML发送","id":"结合html发送","depth":3,"charIndex":4022},{"text":"浏览器开发工具","id":"浏览器开发工具","depth":2,"charIndex":4036},{"text":"初识开发者工具","id":"初识开发者工具","depth":3,"charIndex":4098},{"text":"Elements 元素面板","id":"elements-元素面板","depth":3,"charIndex":4582},{"text":"Console 控制台面板","id":"console-控制台面板","depth":3,"charIndex":5441},{"text":"Sources 源代码面板","id":"sources-源代码面板","depth":3,"charIndex":6046},{"text":"Network 网络面板","id":"network-网络面板","depth":3,"charIndex":6646}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"HTML 基础","content":"#\n\n\nHTML、CSS、JS三者关系#\n\nHTML、CSS、JS共同构建了我们看到的所有网页展示和交互。\n\n 1. HTML (HyperText Markup Language):\n    * HTML 是构建网页的标准标记语言。\n    * 它定义了网页的结构和内容，比如标题、段落和链接等。\n    * HTML 文档由一系列的元素构成，这些元素通过标签（如<html>、<title>、<body>等）来定义。\n 2. CSS (Cascading Style Sheets):\n    * CSS 用于设置 HTML 文档的样式和布局。\n    * 它允许你指定字体、颜色、间距和其他页面元素的外观属性。\n    * CSS 规则由选择器和一组属性构成，它们定义了如何显示选定的 HTML 元素。\n 3. JavaScript (JS):\n    * JavaScript 是一种编程语言，用于使网页具有交互性。\n    * 它可以用来动态更新内容、控制多媒体、制作动画效果、以及与用户进行交互。\n    * JavaScript 代码可以直接嵌入 HTML 页面中，或在单独的.js 文件中定义。\n\n三者之间的关系：\n\n * 结构（HTML）：HTML 提供了网页的骨架和内容。没有 HTML，网页就失去了结构和意义。\n * 样式（CSS）：CSS 用于装饰 HTML 结构，使网页看起来更加美观和用户友好。\n * 行为（JavaScript）：JavaScript 则负责网页的行为，它使得网页不仅仅是静态的文档，而是能够响应用户操作并与用户互动的动态界面。\n\n在创建现代的、动态的、交互式的网页时，通常需要同时使用 HTML、CSS 和 JS：\n\n * HTML 定义了网页的内容。\n\n * CSS 描述了网页的外观和格式。\n\n * JavaScript 则增加了网页的交互性和功能。\n\n\nHTML语法概述和基本结构#\n\n语法\n\n 1. 标签：HTML 文档由一系列标签组成，标签通常成对出现，如<p>和</p>。\n 2. 属性：标签可以包含属性，用于提供额外的信息，如<img src=\"image.jpg\" alt=\"图片描述\">。\n 3. 注释：注释用于解释代码，不会被浏览器显示。格式为：<!-- 注释内容 -->。\n\n基本结构\n\n * 将代码保存在本地以html结尾，使用浏览器打开即可看到页面效果\n\n\n\n\n常用标签#\n\n文档结构\n\n * <html>: 根元素，包含整个页面的内容。\n * <head>: 文档头部，包含页面的元数据，如字符编码声明、页面标题、引用 CSS 和 JavaScript 文件等。\n * <title>: 定义文档的标题，显示在浏览器标签页上。\n * <body>: 文档主体，包含可见的页面内容。\n\n文本和段落\n\n * <h1> - <h6>: 标题标签，定义六级标题，<h1> 是最高级别。\n * <p>: 段落标签，定义文本段落。\n * <br>: 换行标签，用于在文本中插入换行。\n * <hr>: 水平线标签，用于创建一条水平分隔线。\n\n格式化\n\n * <strong> 或 <b>: 加粗文本。\n * <em> 或 <i>: 斜体文本，<em> 表示强调，<i> 表示文本的风格。\n * <del> 或 <s>: 删除线文本，表示文本已被删除或不再准确。\n * <ins> 或 <u>: 下划线文本，表示文本是插入的。\n * <sup> 标签用于上标文本，<sub> 标签用于下标文本。\n\n链接和图像\n\n * <a>: 锚点标签，用于创建超链接。\n * <img>: 图像标签，用于嵌入图像。\n\n列表\n\n * <ul>: 无序列表。\n * <ol>: 有序列表。\n * <li>: 列表项，用于 <ul> 或 <ol> 中。\n * <dl>, <dt>, <dd>: 描述列表，用于项目及其描述。\n\n表格\n\n * <table>: 表格标签。\n * <tr>: 表格行。\n * <th>: 表格头单元格。\n * <td>: 表格数据单元格。\n\n表单\n\n * <form>: 表单标签，用于收集用户输入。\n * <input>: 输入标签，可以是文本框、复选框、单选按钮等。\n * <label>: 标签标签，定义输入字段的描述性标签。\n * <button>: 按钮标签，用于在表单中创建按钮。\n\n分区和布局\n\n * <div>: 分区标签，用于布局，是一个块级容器。\n * <span>: 用来组合文档中的行内元素。\n\n元数据\n\n * <meta>: 元数据标签，提供关于 HTML 文档的元信息，如页面描述、关键词、作者等。\n\n其他\n\n * <script>: 脚本标签，用于嵌入或引用 JavaScript 代码。\n * <style>: 样式标签，用于嵌入 CSS 样式。\n\n\n标签详解#\n\n\nhead 标签#\n\n<head>标签定义了文档的头部，它是一个包含所有头部元素的容器。头部元素通常包含了与页面显示内容不直接相关的信息，但这些信息对于浏览器来说是非常重要的，因为它\n们描述了页面的整体属性和设置。\n\n例子:\n\n\n\n解释:\n\n<meta>标签\n\n提供了关于 HTML 文档的元信息，不会显示在页面上。它可以用来指定页面的字符集、页面描述、关键词、作者、视图窗口设置等。\n\n * charset: 指定字符编码，如<meta charset=\"UTF-8\">。\n * name: 提供文档级别的元数据，如描述、关键词、作者等。\n * http-equiv: 相当于 HTTP 头的作用，用于浏览器和服务器之间的通信，如内容类型、缓存政策、刷新等。\n\n<title> - 页面标题\n\n定义了浏览器工具栏的标题，当网页添加到收藏夹时，显示在收藏夹中的标题也是这个。它还显示在搜索结果中。\n\n\n\n<link>用于链接外部资源，最常用的是链接 CSS 样式表和网站图标（favicon）。\n\n * rel: 定义了当前文档与链接资源的关系。\n * href: 指定了资源的 URL。\n * 链接的css样式可直接使用\n\n网站图标：\n\n\n\n<script> - 脚本\n\n用于在文档中嵌入或引用 JavaScript 脚本。脚本可以放在<head>或<body>中，具体取决于脚本的作用和是否需要等待页面加载。\n\n * 内置脚本\n   \n   \n\n * 外部脚本，引入外部脚本后可直接使用外部脚本中的功能\n   \n   \n\n\nbody 标签#\n\nHTML <body> 标签是网页中不可或缺的一个元素，它代表了 HTML 文档的主体部分，包含了用户在浏览器中看到的所有内容，如文本、图片、视频、表单等。\n\n * 在body标签中，可以自由组合内容标签来构建页面展示的内容\n\n\n\n\n\nbody标签中的属性\n\n * text 指定文本颜色\n\n * bgcolor 指定背景颜色\n\n * backgroud 指定背景图片\n\n * 设置边框\n   \n   \n\n设置文本颜色和页面背景颜色\n\n\n\n\n\n设置边框和背景照片\n\n\n\n\n\n\n文本和段落标签#\n\n<h1>-<h6>\n\n标题标签用于定义六级标题，<h1> 是最高级别的标题，<h6> 是最低级别的标题。\n\n\n\n\n\n<p>标签\n\n段落标签用于定义文本段落。浏览器会自动在段落之间添加空白。\n\n\n\n\n\n<br>标签\n\n对一行内容进行换行\n\n\n\n\n\n<hr>\n\n水平线标签，用于创建一条水平分隔线。\n\n\n\n\n\n\n格式化文本#\n\n<strong> 或 <b>: 加粗文本。\n\n<em> 或 <i>: 斜体文本，<em> 表示强调，<i> 表示文本的风格。\n\n<del> 或 <s>: 删除线文本，表示文本已被删除或不再准确。\n\n<ins> 或 <u>: 下划线文本，表示文本是插入的。\n\n<sup> 标签用于上标文本，<sub> 标签用于下标文本。\n\n\n\n\n\n\n链接和图像#\n\n<a>: 锚点标签，用于创建超链接。\n\n * 点击链接跳转目标网址\n\n<img>: 图像标签，用于嵌入图像。\n\n\n\n\n\n\n列表#\n\n<ul>: 无序列表。\n\n<ol>: 有序列表。\n\n<li>: 列表项，用于 <ul> 或 <ol> 中。\n\n<dl>, <dt>, <dd>: 描述列表，用于项目及其描述。\n\n无序列表#\n\n无序列表用于表示没有特定顺序的项目列表。它由 <ul> 标签定义，列表项则使用 <li> 标签。\n\n\n\n\n\n有序列表#\n\n有序列表用于表示有特定顺序或优先级的项目列表。它由 <ol> 标签定义，列表项同样使用 <li> 标签。\n\n\n\n\n\n<ul>和<ol>的属性\n\n * type: 设置列表项标记的类型（对于 <ol> 可以为 1, A, a, I, i；对于 <ul> 可以为 disc, circle, square）。\n * start: 仅适用于 <ol>，设置列表项的起始编号。\n * reversed: 仅适用于 <ol>，设置列表项编号是否倒序。\n\n\n\n有序列表排序是大写字母形式\n\nstart是开始的数字\n\nreversed是倒叙排列\n\n\n\n<li> 的属性\n\n * value: 仅适用于 <ol> 中的 <li>，设置当前列表项的编号。\n\n\n\n\n\n自定义列表(描述列表)#\n\n自定义列表用于描述列表项，通常用于术语和定义。它由 <dl> 标签定义，列表项的标题使用 <dt> 标签，描述则使用 <dd> 标签。\n\n\n\n\n\n嵌套列表#\n\n列表中可以嵌套其他列表来创建复杂的列表结构\n\n\n\n\n\n\n表格#\n\n表格是一种用于展示数据的结构化方式。表格由 <table> 元素创建，其中包含行 (<tr>)、单元格 (<td> 或 <th>) 等标签。\n\n<table>定义 HTML 文档中的表格。\n\n * 属性：\n   * border：设置表格边框的宽度。\n   * width：设置表格的宽度。\n   * height：设置表格的高度。\n   * align：设置表格在页面中的水平对齐方式（left, center, right）。\n   * cellspacing：设置单元格之间的空间。\n   * cellpadding：设置单元格内容与其边框之间的空间。\n   * summary：提供表格内容的摘要，主要用于辅助技术如屏幕阅读器。\n\n<tr>定义表格中的行。\n\n * 属性：\n   * align：设置行内单元格内容的水平对齐方式。\n   * valign：设置行内单元格内容的垂直对齐方式。\n\n<td>定义表格中的标准单元格。\n\n * 属性：\n   * align：设置单元格内容的水平对齐方式。\n   * valign：设置单元格内容的垂直对齐方式。\n   * colspan：设置单元格应该横跨的列数。\n   * rowspan：设置单元格应该横跨的行数。\n\n<th>定义表格中的表头单元格。其内容通常呈现为粗体并且居中。\n\n * 属性：与 <td> 标签具有相同的属性。\n\n<thead>, <tbody>, <tfoot>这些标签用于将表格内容分为三个部分：表头 (<thead>), 表体 (<tbody>), 和表脚\n(<tfoot>)。它们有助于文档的语义结构，并允许浏览器进行更复杂的表格处理。\n\n简单表格\n\n\n\n\n\n结合上面标签及属性的表格例子\n\n * <thead>, <tbody>, <tfoot> 是可选标签，在表格也可以不使用\n\n\n\n\n\n\n表单#\n\n表单通常由以下部分组成：\n\n * <form> 标签：定义了表单的边界，action 属性指定了表单数据提交到的 URL，method 属性指定了数据的提交方式（通常是 GET 或\n   POST）。\n * 输入元素：如文本框、密码框、单选按钮、复选框等，通常使用 <input> 标签创建。\n * 标签 <label>：用于定义输入元素的描述性标签。\n * 提交按钮：用于提交表单数据。\n\n简单例子\n\n\n\n\n\n<input> 元素\n\n * type=\"text\"：创建单行文本输入框。\n * type=\"password\"：创建密码输入框，输入内容会被隐藏。\n * type=\"checkbox\"：创建复选框。\n * type=\"radio\"：创建单选按钮。\n * type=\"submit\"：创建提交按钮。\n * type=\"reset\"：创建重置按钮，可以重置表单字段。\n * type=\"button\"：创建一个普通按钮，通常与 JavaScript 一起使用。\n\n<input> 属性\n\n * name：定义输入字段的名称。这是当表单提交时，发送到服务器的数据的一部分。\n * value：定义输入字段的初始值。对于 type=\"button\", type=\"submit\", type=\"reset\", 它定义了按钮上的文本。\n * id: id属性是一个全局属性，意味着它可以用于任何 HTML 元素。它用于为元素指定一个唯一的标识符（ID）。\n\n<select> 和 <option> 元素\n\n * <select> 创建下拉列表。\n * <option> 定义下拉列表中的一个选项。\n\n<select> 和 <option> 属性\n\n<textarea> 元素\n\n * 创建一个多行文本输入框。\n\n表单属性\n\n * action：指定服务器上处理表单数据的脚本的 URL。\n\n * method：指定提交表单数据的方法（GET 或 POST）。\n\n * enctype：当 method 属性为 POST 时，enctype\n   属性指定表单数据的编码类型（例如，application/x-www-form-urlencoded 或 multipart/form-data）。\n\n\n\n\n\n\n分区和布局#\n\n\n块级标签#\n\n块级元素通常表示一个 “块”，它们会开始新的行，并占据其父元素的全部宽度。以下是一些块级标签的例子和特性：\n\n例子: <p>, <div>, <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <ul>, <ol>, <li>, <dl>,\n<dt>, <dd>, <form>, <table>,<div>等。\n\n特性:\n\n * 默认情况下，块级元素占据整个容器的宽度。\n * 每个块级元素都会在其前后创建一个 “换行”。\n * 可以设置宽度、高度、内边距（padding）和外边距（margin）。\n * 宽度默认是它的容器的 100%，即占满整个容器宽度。\n\n\n行内标签#\n\n行内元素通常表示文档中的 “内容”，它们不会开始新的行，并且只占据必要的宽度以容纳其内容。以下是一些行内标签的例子和特性：\n\n例子: <a>, <span>, <em>, <strong>, <b>, <i>, <u>, <del>, <ins>, <label>等。\n\n特性:\n\n * 行内元素不会占据整行，它们允许其他元素在同一行显示。\n * 一般情况下，行内元素的宽度、高度、内边距的顶部和底部以及外边距的顶部和底部不会影响布局。\n * 宽度和高度通常由其内容决定。\n\n\ndiv 标签#\n\n<div> 是一个块级元素，这意味着它在页面中会开始一个新的块，并默认占据其父元素的全部宽度。<div> 元素通常用于对页面进行分区，组织内容和创建布局结构。\n\n使用场景\n\n * 页面布局：<div> 常用于创建网页的布局框架，如创建页眉、页脚、主要内容区域、侧边栏等。\n\n * 内容分组：当一组内容在逻辑上属于一个整体时，可以使用 <div> 将其包裹起来，以便于样式化和脚本操作。\n\n * 样式应用：通过给 <div> 添加 class 或 id 属性，可以应用 CSS 样式来定制其外观和行为。\n\n\n\n","routePath":"/编程基础/前后端/html基础","lang":"","toc":[{"text":"HTML、CSS、JS三者关系","id":"htmlcssjs三者关系","depth":2,"charIndex":3},{"text":"HTML语法概述和基本结构","id":"html语法概述和基本结构","depth":2,"charIndex":803},{"text":"常用标签","id":"常用标签","depth":2,"charIndex":1017},{"text":"标签详解","id":"标签详解","depth":2,"charIndex":2027},{"text":"head 标签","id":"head-标签","depth":3,"charIndex":2035},{"text":"body 标签","id":"body-标签","depth":3,"charIndex":2698},{"text":"文本和段落标签","id":"文本和段落标签","depth":3,"charIndex":2946},{"text":"格式化文本","id":"格式化文本","depth":3,"charIndex":3110},{"text":"链接和图像","id":"链接和图像","depth":3,"charIndex":3284},{"text":"列表","id":"列表","depth":3,"charIndex":3353},{"text":"无序列表","id":"无序列表","depth":4,"charIndex":3447},{"text":"有序列表","id":"有序列表","depth":4,"charIndex":3508},{"text":"自定义列表(描述列表)","id":"自定义列表描述列表","depth":4,"charIndex":3839},{"text":"嵌套列表","id":"嵌套列表","depth":4,"charIndex":3926},{"text":"表格","id":"表格","depth":3,"charIndex":3961},{"text":"表单","id":"表单","depth":3,"charIndex":4754},{"text":"分区和布局","id":"分区和布局","depth":3,"charIndex":5715},{"text":"块级标签","id":"块级标签","depth":3,"charIndex":5724},{"text":"行内标签","id":"行内标签","depth":3,"charIndex":6025},{"text":"div 标签","id":"div-标签","depth":3,"charIndex":6271}],"domain":"","frontmatter":{"Author":"lixintao"},"version":""},{"id":103,"title":"测开前端学习基础分享","content":"#\n\n\n基础部分#\n\nhtml，css，javascript\n\n\nTS 与 JS#\n\nTS是JS的一个超集，支持静态类型检查。\n\n\n调试工具（按F12打开浏览器的调试工具）#\n\n\n元素#\n\n展示页面元素（html） 页面样式（css）\n\n\n源代码#\n\n展示页面使用的动态脚本（js）\n\n\n控制台#\n\n展示脚本执行的日志 执行调试脚本\n\n\n网络#\n\n展示页面需要的网络调用（接口信息、资源获取信息，包括响应信息和标头）\n\n\n应用#\n\n存储#\n\n展示本地存储和会话存储、cookie、缓存等\n\n\n学习VUE#\n\nVUE基础\n\n\n快速开始#\n\n创建项目#\n\nnpm create vue@latest\n\n\n\n启动项目#\n\n\n\n访问前端#\n\n通过启动项目提示的访问链接，即可打开项目首页\n\n编译和部署#\n\nvue代码需要编译成 js，css，html 才能被浏览器解析或执行\n\nnpm run dev 可以访问是因为 npm 对 vue 代码进行了动态实时转化，您也因此可以在开发中动态修改代码\n\n\n\n项目目录说明#\n\n\n\n> vite 是一个 vue 的打包工具，它提供了 vue 的开发服务（npm run dev）和包的编译功能（npm run build）\n\n\n开始 VUE 代码#\n\n从main.js开始#\n\n使用 npm create vue@latest 生成的项目，会从 main.js 开始执行 vue 代码。\n\n新建、挂载应用\n\n\n\n模块导入\n\n\n\n组件#\n\n组件，在用户端，可以理解为一个页面，一个页面可以由1个根组件和多个子组件组成。\n\n组件代码#\n\n组件代码主要包括3个部分：模板（template）、脚本（script，和模板至少有1个）、样式（style，可选）\n\n\n\n使用组件#\n\n\n\n组件引用#\n\n可以在父组件中，引用子组件，使用子组件暴露的对象(变量、方法)\n\n\n\n组件 Props#\n\nProps 可以理解为组件的属性，可以在使用组件的时候，传入 props\n\n子组件 components/TestComponent.vue 内容：\n\n\n\n在父组件 App.vue 中使用组件：\n\n\n\n> 属性透传：如果自组件未定义 props，但是父组件传递了属性，子组件会将属性传递给自身的子节点。\n\n组件 Slots#\n\nslots 为组件插槽，用来为组件传递模板内容\n\n子组件TestComponent\n\n\n\n父组件\n\n\n\n> 具名插槽：当需要多个插槽时，可以使用<slot>的name属性指定插槽，而在父组件中，使用 v-slot:<name> 为指定的插槽传递内容\n\n事件#\n\n子组件可以注册事件，并被父组件捕获并响应。\n\n子组件\n\n\n\n父组件\n\n","routePath":"/编程基础/前后端/测开前端学习基础分享","lang":"","toc":[{"text":"基础部分","id":"基础部分","depth":2,"charIndex":3},{"text":"TS 与 JS","id":"ts-与-js","depth":2,"charIndex":32},{"text":"调试工具（按F12打开浏览器的调试工具）","id":"调试工具按f12打开浏览器的调试工具","depth":2,"charIndex":65},{"text":"元素","id":"元素","depth":3,"charIndex":89},{"text":"源代码","id":"源代码","depth":3,"charIndex":119},{"text":"控制台","id":"控制台","depth":3,"charIndex":143},{"text":"网络","id":"网络","depth":3,"charIndex":168},{"text":"应用","id":"应用","depth":3,"charIndex":210},{"text":"存储","id":"存储","depth":4,"charIndex":215},{"text":"学习VUE","id":"学习vue","depth":2,"charIndex":245},{"text":"快速开始","id":"快速开始","depth":3,"charIndex":261},{"text":"创建项目","id":"创建项目","depth":4,"charIndex":268},{"text":"启动项目","id":"启动项目","depth":4,"charIndex":300},{"text":"访问前端","id":"访问前端","depth":4,"charIndex":309},{"text":"编译和部署","id":"编译和部署","depth":4,"charIndex":340},{"text":"项目目录说明","id":"项目目录说明","depth":4,"charIndex":446},{"text":"开始 VUE 代码","id":"开始-vue-代码","depth":3,"charIndex":530},{"text":"从`main.js`开始","id":"从mainjs开始","depth":4,"charIndex":-1},{"text":"组件","id":"组件","depth":4,"charIndex":630}],"domain":"","frontmatter":{"Author":"路斐"},"version":""},{"id":104,"title":"平台权限管理前端设计","content":"#\n\n\n用户登录流程#\n\n\n用户认证#\n\n平台使用 JWT(JSON Web Token) 进行用户认证，客户端通过登录接口获取 JWT 并保存，在访问接口数据时，需要携带 JWT，将 JWT\n放在请求的 Authorization 头部。例如：\n\n登录\n\n\n\n访问数据\n\n\n\n> 上面用到的两个函数 setStorage 和 getStorage，\n> 分别是保存和读取存储中的数据，具体会根据前端环境去实现。例如当前我们将用户数据保存在浏览器的 localStorage 中:\n\n\n\n> JWT 的详细设计可以参考 官方文档。\n\n> 当 access token 过期时，客户端可以通过 refresh token 刷新 access token。\n\n> http://10.7.55.191:8000/api/ 使我们的开发 API 地址\n\n\n用户资源#\n\n登录后，客户端会开始获取用户资源，包括：\n\n 1. 菜单列表及菜单中的按钮权限\n 2. 用户角色、用户部门\n\n研测平台的策略是仅显示用户有权限访问的菜单和对应的按钮。\n\n\n研测平台的权限设计#\n\n研测平台前端的权限主体是角色，例如【管理员】、【测试】，客体是菜单和按钮，例如【新建】、【删除】。\n\n对应的后端权限的客体是 接口 + 方法，前端的每个按钮与之对应。这种对应关系由管理员用户维护，即【系统管理】->【菜单管理】中的【按钮配置】功能。\n\n一般来说前端菜单对应后端不同的接口，按钮对应接口的不同操作（GET,PUT,POST,PATCH,DELETE），但研测平台的不同的菜单可能对应后端同一个接口，\n不同的按钮也可能对应不同的接口。例如：\n\n * 【版本测试】和【系统测试】其实是同一个后端接口实现的，但是有不同的前端菜单；\n * 同一个任务页面【启动】按钮和【新建】按钮对应的不同的后端接口。\n\n因此前端的权限还需要按照菜单区分，例如菜单A和菜单B都使用接口A，但是角色A和角色B需要对菜单A和菜单B有不同的权限，可以看到【按钮配置】是在对不同的菜单进行配\n置的。\n\n研测平台前端通过权限确认是否显示某个菜单或按钮。例如下面是控制按钮显示的函数：\n\n\n\n权限主体和客体的关联即【权限配置】由管理员在【系统管理】-> 【权限管理】中维护。\n\n\n研测平台的伪权限#\n\n伪权限是前端自己实现的权限，例如：用户作为权限主体（即每个用户有专属的权限）。\n\n在机器的占用和释放中，需要对单个用户做权限控制。这里则由机器的用户名属性来控制，平台会判断当前用户是否该机器的占用用户来实现伪权限。下面是一个控制伪权限的函数：\n\n\n\n> getStorage 是获取存储数据的函数。我们在登录的时候，通过 setStorage 将 uiserId 保存在浏览器中。","routePath":"/编程基础/前后端/研测平台权限管理前端设计","lang":"","toc":[{"text":"用户登录流程","id":"用户登录流程","depth":2,"charIndex":3},{"text":"用户认证","id":"用户认证","depth":3,"charIndex":13},{"text":"用户资源","id":"用户资源","depth":3,"charIndex":374},{"text":"研测平台的权限设计","id":"研测平台的权限设计","depth":2,"charIndex":467},{"text":"研测平台的伪权限","id":"研测平台的伪权限","depth":2,"charIndex":958}],"domain":"","frontmatter":{"Author":"路斐"},"version":""},{"id":105,"title":"Httpx","content":"#\n\n\n1、简介#\n\n虽然 Requests 基本已经可以解决大部分问题，但仍然有少部分问题无法解决，比如：HTTP/2（Requests\n只支持HTTP/1.1）、异步请求等，这就需要用到 httpx；\n\nhttpx 号称下一代 HTTP 客户端，最开始是为了解决 Requests 不支持异步请求的问题，工程名称就叫：requests-async，后面整体迁移到\nhttpx 仓库中。\n\n由于 httpx 从一开始就是基于 Requests 来搞的，所以它提供的接口几乎和 Requests 保持一致，这对于我们使用来说就简单多了。\n\n\n2、安装#\n\n系统环境：deepin\n\n\n\n它还提供命令行工具：\n\n\n\n我一般不咋习惯用命令行做接口请求，所以基本都不装这玩意儿。\n\n\n3、简单的例子#\n\n前面说了 httpx 和 Requests 提供的接口几乎一致，咱们就用 Requests 教程里面的例子；\n\n\n3.1、GET请求#\n\n\n\n执行后终端输出：\n\n\n\n\n3.2、POST请求#\n\n\n\n执行后终端输出：\n\n\n\n你看，简直是一毛一样。\n\n行啦，都一样咱们就不聊了，后面重点讲讲不一样的。\n\n\n4、异步请求#\n\n异步是一种并发方式，也就是通常说的“协程”，比多线程效率高很多；\n\nhttpx 的异步请求主要依赖于标准库 asyncio，使用 async 和 await 关键词；\n\n\n\nclient 对象你可以理解为 Requests 里面的 Session 对象。\n\n\n5、HTTP/2#\n\n老实讲 HTTP/2 的网站我还没机会爬过，所以我这里还不太好找例子；\n\n如果你在不小心遇到了也别慌，只需要加一个参数就好了；\n\n\n\n在 httpx.AsyncClient() 里面，默认参数:\n\n\n\n也就是说默认是开启的 http1，所以只需要在实例化 client 对象的时候，传入参数 http2=True 即可；","routePath":"/编程基础/网络爬虫/Httpx","lang":"","toc":[{"text":"1、简介","id":"1简介","depth":2,"charIndex":3},{"text":"2、安装","id":"2安装","depth":2,"charIndex":270},{"text":"3、简单的例子","id":"3简单的例子","depth":2,"charIndex":338},{"text":"3.1、GET请求","id":"31get请求","depth":3,"charIndex":405},{"text":"3.2、POST请求","id":"32post请求","depth":3,"charIndex":432},{"text":"4、异步请求","id":"4异步请求","depth":2,"charIndex":499},{"text":"5、HTTP/2","id":"5http2","depth":2,"charIndex":638}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":106,"title":"Requests","content":"#\n\n\n1、简介#\n\nRequests 是 Python 最久负盛名的 HTTP 库，没有之一；K 神（Kenneth Reitz）的 for humans 系列中最有名的一个；\n\n\n\n做爬虫、数据分析、接口自动化会经常用到它，非常多有名的 Python 库依赖于 Requests 提供基础能力，比如：httpx（支持异步的 HTTP\n库）、locust（性能[负载]测试框架）、HttpRunner（接口自动化框架）等等，都是基于 Requests 构建起来的。\n\n有人甚至建议将 Requests 库合入 Python 标准库发布。只要你想做 HTTP 请求，你肯定会想到 Requests。\n\nRequests 特点：简单、简洁、优雅。\n\n\n2、安装#\n\n系统环境：deepin\n\n\n\n\n3、请求#\n\n\n3.1、导入#\n\n\n\n所有的功能都在 requests 这个名称空间下。\n\n\n3.2、GET 请求#\n\n\n\n终端打印：\n\n\n\n\n3.3、POST 请求#\n\nhttps://httpbin.org 是 K 神的一个简单的 HTTP 服务，主要用于试用 requests 里面的一些功能，方便理解；\n\n\n\n终端打印：\n\n\n\n\n3.4、其他请求#\n\n其他请求方式不常用，如下：\n\n\n\n\n3.5、请求头（headers）#\n\n请求头通常会加 UA（user agent），这个主要是模仿浏览器的行为，比如模仿使用 Firefox 浏览器：\n\n\n\n\n3.6、参数#\n\n(1) get 请求参数\n\nget 请求的参数可以直接在url后面加参数，url?key1=value1&key2=value2，即 url\n后面加问号，然后紧接着多个参数的键和值，多个键值之间用 & 符号链接；\n\n这种方式简单是简单，但是参数多了之后，url 会变得很长，看起来胀眼睛，为了更好的可读性，requests 支持这样传递 get 请求的参数：\n\n\n\n通过打印 r.url 你会发现，实际上也是给你转换成了前面那种 & 连接的方式；\n\n（2）post 请求参数\n\npost 请求参数一般是通过data参数传递，通常 data 是一个字典形式：\n\n\n\n执行后终端输出：\n\n\n\n如果你拿到的参数，是一个 json 格式，可以直接传递给 json 参数：\n\n\n\n执行后终端输出：\n\n\n\n\n4、响应#\n\n其实前面的例子已经有体现一点响应了；\n\n\n\nr 为返回值的对象（Response），通常在项目中我一般用 rsp 来表示（后面的 rsp 和 r 是一个意思，都是表示返回值的对象）；\n\nrsp 既然是对象，那来看下对象的方法和属性，咱们 Debug 跑一下就很清楚：\n\n\n\n接下来讲几个比较常用的属性和方法；\n\n\n4.1、响应内容#\n\n\n\n前面例子已经打印过，这里就不打印了；\n\ntext 的解码是自动的，大多数情况下都能正常解码；\n\n可以通过 encoding 来查看或修改编码方式：\n\n\n\n修改编码方式之后，再使用 r.text 就会以新的编码方式解码。\n\n如果你发现返回的内容编码不对，你可以尝试修改不同的编码，这是个经验积累的过程。\n\n\n4.2、二进制响应内容#\n\n非文本类请求，一般返回的是二进制内容，此时我们应该使用 content 方法：\n\n\n\n将二进制文件保存下来，比如请求返回一个 mp3 文件：\n\n\n\n\n4.3、JSON响应内容#\n\n一些 RESTful API 返回通常是 json 内容，我们可以直接使用：\n\n\n\n获取的类型为 Python 的字典类型；\n\n如果响应包含无效JSON，会抛 requests.exceptions.JSONDecodeError 异常。\n\n\n5、高阶用法#\n\n\n5.1、Session#\n\nSession 对象可以在一次会话中可以有效的处理 cookie 持久化的问题；\n\n\n\n执行后终端输出：\n\n\n\n\n5.2、Request#\n\n无论是前面讲到的 GET 、 POST 等请求方法：\n\n\n\n其底层都是通过调用 Request 这个类来实现的：\n\n\n\n因此我们当然可以直接跨过这一步，不让中间商赚差价，直接用 Request：\n\n\n\n还没完，记得调用一下 prepare() 方法，然后使用 Session 里面的 send 方法：\n\n举例：\n\n\n\n执行终端输出：\n\n","routePath":"/编程基础/网络爬虫/Requests","lang":"","toc":[{"text":"1、简介","id":"1简介","depth":2,"charIndex":3},{"text":"2、安装","id":"2安装","depth":2,"charIndex":324},{"text":"3、请求","id":"3请求","depth":2,"charIndex":347},{"text":"3.1、导入","id":"31导入","depth":3,"charIndex":355},{"text":"3.2、GET 请求","id":"32get-请求","depth":3,"charIndex":394},{"text":"3.3、POST 请求","id":"33post-请求","depth":3,"charIndex":419},{"text":"3.4、其他请求","id":"34其他请求","depth":3,"charIndex":516},{"text":"3.5、请求头（headers）","id":"35请求头headers","depth":3,"charIndex":545},{"text":"3.6、参数","id":"36参数","depth":3,"charIndex":625},{"text":"4、响应","id":"4响应","depth":2,"charIndex":982},{"text":"4.1、响应内容","id":"41响应内容","depth":3,"charIndex":1146},{"text":"4.2、二进制响应内容","id":"42二进制响应内容","depth":3,"charIndex":1312},{"text":"4.3、JSON响应内容","id":"43json响应内容","depth":3,"charIndex":1401},{"text":"5、高阶用法","id":"5高阶用法","depth":2,"charIndex":1538},{"text":"5.1、Session","id":"51session","depth":3,"charIndex":1548},{"text":"5.2、Request","id":"52request","depth":3,"charIndex":1619}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":107,"title":"Scrapy","content":"#\n\n\n1、简介#\n\nScrapy 是现阶段 Python 社区最流行的爬虫框架，它能够极大的简化爬虫的编写难度，简化代码。\n\n当然它不是 Python 社区唯一的爬虫框架，但我认为是现阶段最好用的爬虫框架。\n\n经常用同学问，为啥要用 Scrapy，我用 requests 不可以吗？\n\n我觉得这样解释：\n\n * 不是一个类型\n\nrequests\n最多算是爬虫工具，不同的人写出来的爬虫代码都不同，重复代码还多，而且对于一些高级的应用场景，如：多线程处理、异步处理、持久化等，估计没几个人能处理的很完美，最后\n爬下来的数据还要找一堆工具来解析处理，比如：re、BeautifulSoup、lxml等，属实让人挠头；\n\n而爬虫框架通常提供了简单的配置，使用很少的代码就能实现复杂的功能，代码量少了，而且底层也为你处理了很对问题，框架在解析数据也有自带的方案，所以你只需要按照框架所\n定义好的规范，就可以轻松完成各种任务；\n\n * 不是一个圈子\n\nScrapy 主要用于数据爬取，所以说它是爬虫框架，你说用它来做一些 POST 请求发个数据啥的，咱们貌似没这么用过；\n\n而 requests 只要是网络接口请求都能用，爬数据也可以，但你要说爬数据有多强呢，就要看使用的人有多强了；\n\n总结：\n\n * 新手、老司机做小任务，用哪个都无所谓，用框架的话会轻松很多；\n * 新手做大任务，用框架，不要想，省时省力；\n * 老司机做大任务，用工具可以做，就是有点麻烦；用框架也能搞，但是不能秀出你的实力；\n\n\n2、安装#\n\n系统环境：deepin\n\n\n\n\n3、创建项目#\n\n咱们就爬取 deepin 论坛的贴子，找找感觉；\n\n创建一个爬虫项目名为：deepin_bbs_spider\n\n\n\n工程目录结构：\n\n\n\n\n4、开始写爬虫#\n\n在 ~/deepin_bbs_spider/deepin_bbs_spider/spiders\n目录下写我们的爬虫脚本文件，创建一个爬虫，目标是爬取论坛里面帖子内容：\n\n\n\n啥也不说，先跑起来试试：\n\n\n\n跑完之后，终端就会有输出爬取到的帖子信息：\n\n\n\n你先别管其他的，至少咱们能爬到数据了，接下来咱们慢慢介绍上面这些代码是怎么来的~；\n\n\n5、逻辑讲解#\n\n\n5.1、生成爬虫模板#\n\n看了上面的示例，有同学肯定要问，你咋知道要写个类呢，你咋知道要写个 parse 函数呢？\n\n我确实不知道，scrapy 也知道咱们不知道，所以做了个工具自动生成：\n\n\n\n用子命令 genspider，后面加爬虫的名称（spider name），再加要爬取地址（url），就可以在 spiders 目录下自动生成一个 py 文件；\n\n比如，咱们像这样：\n\n\n\n执行之后就会自动生成 py 文件：\n\n\n\n简单讲解一下：\n\n * 爬虫类是要继承 scrapy.Spider 的，这个不要去动，知道继承就对了；\n * 类变量 name 是爬虫的名称，这玩意儿就是个代号，你想改成王大锤都行，一般赖得去管；\n * 类变量 allowed_domains 爬虫域名；\n * 类变量 start_urls 爬虫目标地址，可以给多个；\n * 实例方法 parse(self, response) 也是固定写法，函数名称最好不动，参数名称不能改，因为是 scrapy 返回的一个 Selector\n   对象；\n\n这里面核心逻辑就是在 parse 函数里面去写，你可以理解成 response 就是返回的页面信息，你只需要在这里面去提取想要的数据就好了；\n\nresponse 提供一些方法，能够很方便的进行页面信息提取；\n\n\n5.2、爬虫编写方法#\n\n前面说到爬虫脚本里面 response，它是我们编写代码的核心，所有的数据提取都从这里来；\n\n下面我们讲讲数据的提取方法，这里多嘴一句，我默认大家都是有一点前端基础的，不然下面部分内容可能需要去学习下 html、css相关知识；\n\n首先来讲 css 提取方法，css 的解析是非常灵活的，先用 F12 看下 html 源码：\n\n\n\n可以看到所有的帖子都在 app-post-pc 标签下面，咱们可以这样写：\n\n\n\n如果你是使用右键复制的选择器，可能是一个很长的表达式，不太优雅也不利于维护，我个人不太建议使用直接复制表达式，而应该通过观察自己写；\n\n这样的话，post_items 就获取到了所有帖子的 app-post-pc 标签，再看下 app-post-pc 标签下都有啥：\n\n\n\n可以看到在 app-post-pc 标签下还有 a 标签，保存了帖子的详情地址(post_url)，然后在 a 标签下的 span\n标签保存了帖子的类型和标题(title)，因此咱们想办法把这两个拿到：\n\n\n\n先用 for 循环把 post_items 里面每个 Selector 对象里面的 url 和 title 拿到；\n\npost_item 就是单个的 Selector 对象，我们在它的基础上再通过 css 方法获取到我们想要的数据；（也可以使用 Xpath 技术获取）\n\n * url 是在 a 标签里面的 href 属性里面，因此：\n\n\n\n表达式里面的 ::attr(href) 这部分是 Scrapy 特有的，:: 表示取值，attr(href) 表示通过 href 属性取值；\n\nget() 方法表示取第一个值，getall() 方法表示取所有的值；（也兼容老版本的 extract_first() 和 extract()\n方法，意思是对应一样的，不过明显get() 这种可读性更好更易于理解。）\n\n * title 在 span 标签里面：\n\n\n\ntext 也是 Scrapy 特有的，表示把标签的文本取出来；\n\n非常好理解对吧，只要你稍微有点前端知识，就能够轻松把表达式写出来；\n\n\n5.3、获取数据#\n\n前面例子是将获取到的数据打印出来，实际业务里面我们肯定是需要将数据保存下来的；\n\n首先我们在 items.py 里面定义数据类型：\n\n\n\n写法非常简单，统一使用 scrapy.Field() 来定义就行了；\n\n然后，回到爬虫脚本里面：\n\n\n\n将 items.py 里面的 DeepinBbsSpiderItem 导进来，实例化一个对象，然后将获取到的数据复制给这个对象，使用 item[\"url\"]\n这种给字典添加的方式，注意要和 items.py 里面定义的字段名称保持一致；\n\n最后，使用 yield 将数据返回出来就行了；\n\n将数据写入到 csv 文件里面：\n\n\n\n-o 表示导出数据，执行后，查看 bbs.csv 文件：\n\n\n\n这样就将爬取到的数据保存到了一个 csv 文件；\n\n\n5.4、处理数据#\n\n在爬虫脚本里面获取到原始数据之后，我们还有可能会拿数据做进一步处理，比如还想写入数据库、写入 Excel等等；\n\n这些进一步的操作，我们通常是在数据管道 pipelines.py 里面来处理：\n\n\n\n这里的 item 就是每一条数据；\n\n比如，你想写入 MySQL数据库（首先要确保数据库表、字段等正常）：\n\n\n\n在上面注释里面写了写入数据库的编写逻辑，由于我们主要想讲解数据管道的操作逻辑，数据库的代码数据基本操作，就不做详细代码示例了，往上搜 pymysql\n的使用很多，按照注释的逻辑，对号入座就行了；\n\n如果想写入 Excel 表格逻辑是一样的，也可以表格和数据库同时写入，在 pipelines.py 里面再定义一个管道类就行了；\n\n注意，数据管道逻辑写完之后，要在 settings.py 里面修改配置：\n\n\n\nITEM_PIPELINES 是一个字典，key 是数据管道，value 是一个数字；\n\nvalue 主要用于多个管道排序的，因为在 pipelines.py 里面可以定义多个数据管道类，它们执行的先后顺序由 value 来控制，数字越小越先执行；\n\n如果你就一个数据管道类，这个 value 给多少都无所谓；\n\n另外提醒，在 process_item() 最后一定要 return item ，不然存在多个数据管道的时候，后执行的数据管道就拿不到数据了；\n\n好，配置完之后，就可以再次执行了；\n\n\n5.5、从下层页面解析数据#\n\n这部分内容相对来讲是难点，搞懂了这部分，就几乎能处理对大部分数据爬取了；\n\n来，开始燥起来~~\n\n前面我们获取到了帖子的 url 和 title，有同学可能要问了，这个帖子的正文内容哪里；\n\n正文内容在帖子的 url 里面，如果我们要同时获取帖子的正文内容，就需要做以下处理；\n\n\n\n5.5.1、回调逻辑#\n\n首先，前面获取的 url 不是一个完整的链接，咱们需要稍微处理以下：\n\n\n\n我们前面获取的 url 是这样的: /en/post/254787 ，因此做一个替换处理；\n\n然后，咱们拿着这个 url 继续做请求：\n\n\n\n这里需要用 yield 返回并构造 scrapy.Request 对象，传入三个参数：\n\n * url 就是下层页面的地址；\n\n * callback 传入回调函数对象，因为 parse() 这个函数是处理当前页面的逻辑，下层页面就不能在这个函数里面继续处理了，而是要新写一个函数来处理；\n   \n   写法和 parse() 类似，函数名可以自己定， 参数仍然是 response 对象；\n   \n   注意，参数传入是 callback=self.post_parse，后面没有加括号哈，因为我们不是在这里调用函数，是传入函数对象，也就是只要函数名；\n\n * cb_kwargs 是为了给 post_parse() 函数传递 item 参数，是一个字典类型，这样在 post_parse(self,\n   response, **kwargs) 里面的 kwargs 就能拿到 item 的值，咱们后续拿到正文之后，继续组装到 item 里面就行了；\n\n5.5.2、下层页面解析#\n\n下层页面的解析，逻辑和前面一样，先看下 html 源码：\n\n\n\n获取正文：\n\n\n\npost_info 获取的结果为：\n\n\n\n做一个字符串组装：\n\n\n\n这样的话，我们就获取到了正文的数据，添加到 item 对象中：\n\n\n\n注意，在 items.py 中把新的字段也添加上：\n\n\n\n最后，跑一下爬虫；\n\n5.5.3、多层数据传递问题#\n\n到目前位置，完整的爬虫脚本：\n\n\n\n使用命令跑一下爬虫：\n\n\n\n你会惊奇的发现，怎么所有的 title 和 url 数据相同，开始怀疑自己逻辑是不是写错了；\n\n其实，我们代码逻辑是没问题的，只不过在多层数据传递的过程中，需要特殊处理下，处理方法很简单：\n\n * 导入from copy import deepcopy模块，将cb_kwargs={'item': item} 更改为\n   cb_kwargs={'item': deepcopy(item)；\n * 最后一行代码yield item 修改成 yield deepcopy(item)就完全 ok 了；\n\n改完之后再跑一下，简直完美。\n\n5.5.4、多页面爬取#\n\n到现在我们怕去了第一页的数据，那还想爬取后面的页怎么办？\n\n有同学说，好办，start_urls 不是一个列表吗，把多个 url 放进去不就完了；\n\n不得不说，这样是可以的，就是不够优雅。\n\n通过仔细观察，我们可以发现一些规律：\n\n\n\n在地址中只有 offset 参数在变化，第一页是 0，第二页是 1，非常有规律，因此咱们可以动态生成：\n\n\n\n使用 start_requests() 函数替代 start_urls；\n\n在里面写个 for 循环，要爬取多少页填入 range 函数就行了，动态生成多个 scrapy.Request 对象，注意要用 yield 哦~~\n\n5.5.5、完整的示例#\n\n爬虫脚本 bbs_spider.py：\n\n\n\n数据类型 items.py：\n\n\n\n配置 settings.py：（省略了没有启用的配置项）\n\n\n\n如果你自己玩起来有点小问题，可以尝试参考我的代码：https://github.com/mikigo/deepin_bbs_spider\n\n\n6、调试#\n\n\n6.1、数据获取调试#\n\n在使用 response.css() 表达式时，通常我们需要进行调试，看表达式写得对不对，当然你可以通过执行爬虫然后打印数据，但是这种方式有点麻烦；\n\nScrapy 提供了一个快捷的调试方法，在终端输入：\n\n\n\n<scrapy url> 是你要爬取的地址，比如前面我们想获取帖子正文的内容，可以这样调试：\n\n\n\n进入终端交互式，输入：\n\n\n\n可以看到返回的结果，如果返回为空，就说明表达式可能有点问题；\n\n\n6.2、Pycharm Debug#\n\nScrapy 由于封装得比较好，启动爬虫是通过命令行启动，但是这有个问题，就是不支持在编辑器里面 Debug\n运行，导致你调试代码过程中可能会不停的在终端启动爬虫，有点费劲；\n\n经过一番折腾，终于道破了天机~\n\n（1）先在工程下随便找一个 py 文件，里面啥也不写，执行一下，然后点这里：\n\n\n\n（2）在系统中找到 scrapy 包中的 cmdline.py 文件，这个你得稍微知道点 Python 包管理的一些知识，比如我的在这里：\n\n\n\n（4）在 Name 里面写个你喜欢的名字，比如我写：Scrapy\n\n（4）在 Script path 里面把 cmdline.py 的路径填进去；\n\n（5）在 Parameters 里面填入 Scrapy 的参数：crawl bbs_spider -o bbs.csv；\n\n\n\n（6）点击右下角的 【ok】，在主界面点【Debug】就可以进行调试了，妙啊~~\n\n\n\n\n7、结束语#\n\n到这里 Scrapy 的基础入门就结束了，一般的小网站可以轻松快速的搞定，简直 yyds~~\n\n从完整示例我们不难看出，爬虫脚本简单的 30 来行代码加上简单的配置，就可以爬取大量的数据，而且速度非常快，对比你用 requests\n去裸写看看，你会发现差距不是一般的大；\n\n对于其他的一些细节还可以完善，比如：代理、异步、中间件、与其他自动化工具扩展（Selenium），后续精力再补充~~","routePath":"/编程基础/网络爬虫/Scrapy","lang":"","toc":[{"text":"1、简介","id":"1简介","depth":2,"charIndex":3},{"text":"2、安装","id":"2安装","depth":2,"charIndex":648},{"text":"3、创建项目","id":"3创建项目","depth":2,"charIndex":671},{"text":"4、开始写爬虫","id":"4开始写爬虫","depth":2,"charIndex":750},{"text":"5、逻辑讲解","id":"5逻辑讲解","depth":2,"charIndex":932},{"text":"5.1、生成爬虫模板","id":"51生成爬虫模板","depth":3,"charIndex":942},{"text":"5.2、爬虫编写方法","id":"52爬虫编写方法","depth":3,"charIndex":1509},{"text":"5.3、获取数据","id":"53获取数据","depth":3,"charIndex":2418},{"text":"5.4、处理数据","id":"54处理数据","depth":3,"charIndex":2774},{"text":"5.5、从下层页面解析数据","id":"55从下层页面解析数据","depth":3,"charIndex":3397},{"text":"5.5.1、回调逻辑","id":"551回调逻辑","depth":4,"charIndex":3555},{"text":"5.5.2、下层页面解析","id":"552下层页面解析","depth":4,"charIndex":4106},{"text":"5.5.3、多层数据传递问题","id":"553多层数据传递问题","depth":4,"charIndex":4271},{"text":"5.5.4、多页面爬取","id":"554多页面爬取","depth":4,"charIndex":4588},{"text":"5.5.5、完整的示例","id":"555完整的示例","depth":4,"charIndex":4888},{"text":"6、调试","id":"6调试","depth":2,"charIndex":5046},{"text":"6.1、数据获取调试","id":"61数据获取调试","depth":3,"charIndex":5054},{"text":"6.2、Pycharm Debug","id":"62pycharm-debug","depth":3,"charIndex":5271},{"text":"7、结束语","id":"7结束语","depth":2,"charIndex":5696}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":108,"title":"Appium—6小时入门版","content":"#\n\n\n简介#\n\nAppium 主要用于做 APP UI 自动化测试。\n\n\n安装#\n\n\n安装 Appium 应用#\n\n\n\n安装完之后把 appium 映射到环境变量里面：\n\n\n\n最后在终端输入：\n\n\n\n如果得到这样的输出：\n\n\n\n说明安装没问题。\n\n\n安装驱动程序 UiAutomator2#\n\nAppium UiAutomator2 Driver 是 Android 设备的测试自动化框架。Appium UiAutomator2 Driver\n可自动执行本机、混合和移动 Web 应用程序，并在模拟器和真实设备上进行测试。\n\nGithub地址：https://github.com/appium/appium-uiautomator2-driver\n\n1、安装 Android SDK 平台工具\n\nAndroid SDK Platform-Tools 是 Android SDK 的一个组件。它包含与 Android 平台进行交互的工具，主要是 adb 和\nfastboot。\n\n下载链接：https://developer.android.com/studio/releases/platform-tools?hl=zh-cn\n\n选择 Linux 版本下载即可得到一个压缩包：platform-tools_r34.0.4-linux.zip ；\n\n我这里就直接放到 ~/Downloads/ 下面：\n\n解压后得到这样的文件：\n\n\n\n2、设置环境变量\n\n\n\n你可以在终端输入 env 查看这两个环境变量是否存在。\n\n3、安装 Java JDK\n\n\n\n4、Android设备必须启用USB调试；\n\n5、安装\n\n\n\n\n安装 Appium Python 客户端#\n\n\n\n文档地址：https://appium.github.io/python-client-sphinx/\n\n\nAppium基础#\n\n\nadb工具#\n\n1.android debug brige 安卓调试桥接器。\n\n2.adb 常用命令\n\n * adb devices 查看链接的设备\n\n * adb pull/push 在设备与 pc 之间拷贝文件\n   \n   \n\n * adb install/uninstall 安装/卸载\n   \n   \n\n * adb shell 进入shell界面（支持Linux命令）\n\n * adb connect/disconnect 链接某个设备\n   \n   \n\n\nPackage和Activity#\n\n * package 包，告知工具包名是什么；\n\n * Activity 就是一个个的页面，要指定一个主 Activity，才能启动；\n\n * 获取 package 和 activity\n   \n   \n\n\n控件布局#\n\n1.常见布局（Layout）\n\n（1）LinearLoyout 线性布局\n\n（2）RelativeLayout 相对布局\n\n（3）FrameLayout 框架布局\n\n2.常见控件\n\n（1）TextView 界面上的一段文字，但不允许用户修改\n\n（2）Button 按钮\n\n（3）EditText 相当于input输入框\n\n（4）ImageView 展示图片的控件\n\n（5）ListView 就是一个列表的展示\n\n\nAppium脚本#\n\n\n认识appium#\n\n1.安装 appium 之后，点击打开\n\n2.界面有三个选项\n\n（1）Simple 默认配置\n\n（2）Advanced 高级设置，可自定义配置\n\n（3）Presets 修改高级设置中的配置项\n\n\n启动APP的脚本#\n\n\n\n\n常用Capability#\n\n * noReset 默认每次都按第一次安装的状态启动\n   \n   \n\n * newCommandTimeout 等待发送新消息的时间，默认是60秒\n   \n   \n\n * browserName 指定浏览器的名称（Chrome、safari）\n   \n   \n\n\nAppium元素定位#\n\n\n1、元素探测工具-appium-inspector#\n\nGithub地址：https://github.com/appium/appium-inspector\n\n\n2、元素探测工具-UIAutomatorviewer#\n\n（1）打开在 Android_sdk_windows/tools_xpaths/uiautomatorviewer.bat\n\n（2）点击左上角按钮，获取 APP 快照\n\n（3）鼠标指定快照上的元素，右侧即会显示该元素的信息\n\n（4）保存功能，可将页面快照和元素信息保存下来，方便下次查看。\n\n\n3、原生应用的定位#\n\n定位的方式有以下几种\n\n * 用过 id，但 id 并不唯一\n   \n   \n\n * 通过class name定位\n   \n   \n\n * 通过xpath定位\n   \n   \n\nxpath轴\n\n用法：\n\n\n\n轴名称                  结果\nancestor             选择当前节点的所有先辈（父、祖父等）\nancestor-or-self     选取对当前节点的所有先辈（父、祖父等）以及当前节点本身\nattribute            选取当前节点的所有属性\nchild                选择当前节点的所有属性\ndescendant           选取当前节点的所有后代元素（子、孙等）\ndescendant-or-self   选取当前节点的所有后代元素以及当前节点本身\nfollowing            选取文档当前节点的结束标签之后的所有节点\nnamespace            选取当前节点的所有命名空间节点\nparent               选取当前节点的父节点\npreceding            选取文档中当前节点的开始标签之前的所有节点\npreceding-sibling    选取当前节点之前的所有统计节点\n\n（4）层级定位，就是元素再查找\n\n\n\n（5）引入By类\n\n\n\n\n4、UIAutomator#\n\n\n\n① new UiSelector().text(\"text\")\n\n② new UiSelector().classname(\"class\")\n\n层级关系定位\n\n③当前类往下递归找符合条件的子级控件\n\n\n\n④从父类往下递归找符合条件的控件\n\n\n\n（6）获取元素列表\n\n\n\n\n5、混合应用hybrid#\n\n（1）Chrome 远程调试\n\n①在浏览器中输入：\n\n\n\n②浏览器上会显示手机上所有APP的web网页的地址\n\n③复制地址在浏览器中访问，即可对元素进行定位\n\n（2）driver.contexts\n\n查看 context 的情况\n\n\n\n跳转到原生应用的 context\n\n（3）appium inspector 定位\n\n在 appium 右上角点击放大镜符号，填入 desired_capabilities 里面的参数\n\n\n6、web应用#\n\n通过 pc 端 chrome 操作\n\n\n\n\nAppium操作#\n\n\n基本操作#\n\n1.点击\n\n\n\n2.多点触摸\n\n\n\n3.清除文本\n\n\n\n\n滚动操作#\n\n1.元素滚动\n\n按住不放，拖动\n\n\n\n传入两个元素\n\n2.元素拖拽\n\n在开始元素长按（1000毫秒）\n\n\n\n3.屏幕滑动\n\n\n\n分别传入开始和结束位置的xy轴值\n\n4.快速滑动\n\n\n\n\n输入、键盘和输入法控制#\n\n1.模拟输入\n\n\n\n2.发送按键码\n\n\n\n常用的按键码\n\n\n\n3.输入法操作\n\n\n\n\n获取页面内容#\n\n1.获取上下文信息\n\n\n\n2.获取当前所在的activity\n\n\n\n\n\n3.获取元素相关内容\n\n① 获取文本值\n\n\n\n②获取元素属性值\n\n\n\n③获取元素大小\n\n\n\n④获取元素坐标\n\n\n\n4.检查元素状态\n\n①检查元素是否被选中\n\n\n\n②检查元素是否可用\n\n\n\n③获取窗口大小\n\n\n\n\n等待#\n\n1.wait_activity\n\n等待某个 activity 加载完\n\n\n\n2.强制等待\n\n\n\n3.隐式等待\n\n只需要声明一次，一般在打开浏览器后进行声明，声明之后对整个driver的生命周期都有效。\n\n\n\n4.显示等待\n\n等待某个元素出现\n\n\n\n\n截图#\n\n1.截图保存为文件\n\n\n\n2.截图并保存为字符串\n\n\n\n\nAPP弹窗处理#\n\n * Dialog 对话框，确定或取消等弹窗\n * Actionbar 功能框，分享功能从下方弹出的窗口\n * Toast 提示信息，页面小提示，过几秒钟就自动消失\n * Snackbar 提示对话框\n * Dialog 和 Actionbar 可以直接用元素定位\n\n\n触屏操作#\n\nTouchAction 要使用到这个类里面的方法\n\n\n\n1.tap 触摸\n\n\n\n2.press 短按\n\n\n\n3.long_press 长按\n\n\n\n4.wait 等待\n\n\n\n5.move_to 移动\n\n\n\n6.release 释放\n\n\n\n7.perform 提交\n\n","routePath":"/自动化技术/UI自动化/Appium—6小时入门版","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"安装","id":"安装","depth":2,"charIndex":37},{"text":"安装 Appium 应用","id":"安装-appium-应用","depth":3,"charIndex":43},{"text":"安装驱动程序 UiAutomator2","id":"安装驱动程序-uiautomator2","depth":3,"charIndex":125},{"text":"安装 Appium Python 客户端","id":"安装-appium-python-客户端","depth":3,"charIndex":707},{"text":"Appium基础","id":"appium基础","depth":2,"charIndex":786},{"text":"adb工具","id":"adb工具","depth":3,"charIndex":798},{"text":"Package和Activity","id":"package和activity","depth":3,"charIndex":1033},{"text":"控件布局","id":"控件布局","depth":3,"charIndex":1156},{"text":"Appium脚本","id":"appium脚本","depth":2,"charIndex":1370},{"text":"认识appium","id":"认识appium","depth":3,"charIndex":1382},{"text":"启动APP的脚本","id":"启动app的脚本","depth":3,"charIndex":1491},{"text":"常用Capability","id":"常用capability","depth":3,"charIndex":1505},{"text":"Appium元素定位","id":"appium元素定位","depth":2,"charIndex":1654},{"text":"1、元素探测工具-appium-inspector","id":"1元素探测工具-appium-inspector","depth":3,"charIndex":1668},{"text":"2、元素探测工具-UIAutomatorviewer","id":"2元素探测工具-uiautomatorviewer","depth":3,"charIndex":1750},{"text":"3、原生应用的定位","id":"3原生应用的定位","depth":3,"charIndex":1926},{"text":"4、UIAutomator","id":"4uiautomator","depth":3,"charIndex":2529},{"text":"5、混合应用hybrid","id":"5混合应用hybrid","depth":3,"charIndex":2683},{"text":"6、web应用","id":"6web应用","depth":3,"charIndex":2910},{"text":"Appium操作","id":"appium操作","depth":2,"charIndex":2942},{"text":"基本操作","id":"基本操作","depth":3,"charIndex":2954},{"text":"滚动操作","id":"滚动操作","depth":3,"charIndex":2990},{"text":"输入、键盘和输入法控制","id":"输入键盘和输入法控制","depth":3,"charIndex":3090},{"text":"获取页面内容","id":"获取页面内容","depth":3,"charIndex":3147},{"text":"等待","id":"等待","depth":3,"charIndex":3298},{"text":"截图","id":"截图","depth":3,"charIndex":3428},{"text":"APP弹窗处理","id":"app弹窗处理","depth":3,"charIndex":3462},{"text":"触屏操作","id":"触屏操作","depth":3,"charIndex":3607}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":109,"title":"Playwright—8小时入门版","content":"#\n\n\n一、简介#\n\nPlaywright 是一个 Web UI 自动化测试的框架，其各方面功能和使用体验全面碾压 Selenium。\n\n> 一入 Playwright 深似海，从此 Selenium 是路人。\n\n曾经，在 Web UI 自动化测试领域，Selenium 如日中天，几乎只要提到 UI 自动化就会想到 Selenium，Selenium 就是 Web\nUI自动化的代名词；\n\n后来，Playwright 出现了，慢慢的大家对 Selenium 开始冷落了；为啥呢？\n\n简单讲，因为在 Selenium 时代，其实大家遇到很多问题，但一直得不到解决；Selenium 2.0 版本是一个巨大的飞跃，因为引入了\nWebDriver，后面 3.0、到现在 4.0 功能上没有什么亮点，而且以前的问题还在，大家对这个玩意儿就提不起兴趣去研究了。\n\n> Selenium 之后不是没有其他 UI\n> 框架，确实也出现过几个小有名气的框架，比如：cypress、puppeteer、testcafe，这些个玩意儿缺点就是不支持 Python，太拉胯，而且像\n> puppeteer 只支持谷歌浏览器，因为它就是谷歌家的它不需要支持其他浏览器，就这，广大的 Firefox 和尊贵的 Safari\n> 用户能忍你吗，给老子滚。于是，Playwright 集各家之所长，补各家之缩短，“天空一声巨响，老子闪亮登场”。\n> \n> 坊间传言，Playwright 有几个核心开发者就是从 puppeteer 过来的，不得不说，老外是真会整活。\n\n第一次尝试使用 Playwright，我仅仅只写了一个小脚本，但有两个点印象深刻：\n\n1、环境安装好简单；\n\n要知道 Selenium 的环境安装是很烦人的，要单独装 WebDriver 的驱动，而且驱动版本要和浏览器版本一致，不然会报一些莫名其妙的错，多少人在\nSelenium 的环境上卡住而无法入门；\n\n2、执行速度好快；\n\n用过 Selenium 应该知道，跑起来挺慢的，Playwright 的执行速度真的“起飞”。\n\n在后面对 Playwright 使用和了解越来越多之后发现，它确实全面碾压 Selenium。微软出品，必属精品。\n\n\n二、安装#\n\n系统环境：deepin-20.8\n\n\n\n完事儿了，这样环境就装好了，是不是很简单，不用去关心用什么浏览器，用什么 WebDriver 驱动，你的电脑上甚至不用装浏览器，playwright\ninstall 已经把测试用的浏览器都装好。\n\n\n三、脚本生成器#\n\nSelenium IDE\n是用来录制脚本的，好多刚开始入门的同学应该都用过，就是在浏览器里面装个插件，然后监控浏览器的事件，生成脚本；我个人倒是极少用，因为会写代码用那玩意儿干啥。（成功\n装到）\n\nPlaywright 当然也有录制的功能，在终端执行：\n\n\n\n会启动一个“浏览器”窗口和一个“脚本生成器”窗口\n\n\n\n脚本生成器初始状态会有模板代码，你通过浏览器操作的时候，每一步的操作，都会对应在脚本生成器自动生成一行代码，比如，我输入百度的网址：\n\n\n\n在百度首页，点击输入框，输入一个内容，点击“百度一下”，一顿操作下来，代码自动生成如下：\n\n\n\n这样就自动生成了一段完整的代码，简直不要太轻松。\n\n有同学说，能不能直接生成测试用例的代码，当然是可以的，在脚本生成器右上角 Target 选择 pytest，一顿操作下来，生成代码如下：\n\n\n\n这个脚本是可以直接用 pytest 来执行的，你需要安装 pytest-playwright 插件：\n\n\n\npytest-playwright 插件是由 Playwright 官方维护的。\n\n相信有上面 pytest 这个例子，对于测试同学来讲，写一些简单的用例是没什么问题了。\n\n\n四、元素定位方法#\n\n对于所有的 UI 自动化来讲，无非就是元素定位和元素操作，Playwright 最常用的元素的定位方法就是 XPath 和 CSS，其次就是它特有的定位方法；\n\n\n1、XPath#\n\nXPath 是一种通用、标准的元素定位方案，它的语法也是标准的，在很多框架里面都有使用到，基本能满足 90% 的元素定位需求；\n\n经常有同学说 XPath 定位不稳定，页面上一点点变化就找不到元素了，说这话的一般是喜欢使用浏览器自带的复制 XPath 的功能，因为复制出来的 XPath\n路径是绝对路径，当然不稳定，我们通过观察，自己写相对路径的XPath 表达式；\n\n简单介绍下 XPath 语法：\n\n（1）节点选取\n\n表达式        描述\nnodename   选取此节点的所有子节点\n/          从根节点选取\n//         从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置\n.          选取当前节点\n..         选取当前节点的父节点\n@          选取属性\n\n（2）属性选取\n\n路径表达式                                结果\n/bookstore/book[1]                   选取属于 bookstore 子元素的第一个 book 元素。\n/bookstore/book[last()]              选取属于 bookstore 子元素的最后一个 book 元素。\n/bookstore/book[last()-1]            选取属于 bookstore 子元素的倒数第二个 book 元素。\n/bookstore/book[position()<3]        选取最前面的两个属于 bookstore 元素的子元素的 book 元素。\n//title[@lang]                       选取所有拥有名为 lang 的属性的 title 元素。\n//title[@lang='eng']                 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。\n/bookstore/book[price>35.00]         选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。\n/bookstore/book[price>35.00]/title   选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于\n                                     35.00。\n\n在浏览器中调试 XPath：\n\n按 F12 打开调试页面—>选择 console，XPath 定位的语法是 ：$x()\n\n举例：\n\n\n\n\n\n说明通过这个 XPath 表达式可以定位到【百度一下】按钮；\n\n在 Playwright 里面是通过 page 对象提供的 locator 方法实现 CSS 或 XPath 定位的：\n\n\n\nPlaywright 会自动检测输入的是 CSS 或 XPath。\n\n\n2、CSS#\n\n了解前端的应该都知道 CSS，这里不多介绍；\n\n在浏览器中调试 CSS 定位：\n\n\n\n\n\n说明通过此 CSS 表达式可以定位到【百度一下】按钮；\n\n在 Playwright 里面：\n\n\n\n\n3、特有的#\n\nPlaywright 内置几个定位器：\n\n * get_by_role 通过角色定位\n   \n   还是上面的例子【百度一下】：\n   \n   html 是这样的：\n   \n   \n   \n   定位可以这样写：\n   \n   \n\n * get_by_text 通过文本定位\n   \n   还是在百度首页找个文本 html ：\n   \n   \n   \n   定位可以这样写：\n   \n   \n\n * get_by_label 通过标签定位\n   \n   html 是这样的：\n   \n   \n   \n   定位可以这样写：\n   \n   \n\n还有其他的内置定位方法：\n\n\n\n\n五、其他#\n\n\n1、截图#\n\n捕获屏幕截图并将其保存到文件中：\n\n\n\n完整页面截图是一个完整的可滚动页面的截图：\n\n\n\n单个元素进行屏幕截图：\n\n\n\n\n2、录屏#\n\n测试过程录屏，保存的视频文件将出现在指定的文件夹中，生成了唯一的名称，视频保存在浏览器上下文在测试结束时关闭：\n\n\n\n还可以指定视频大小\n\n\n\n\n3、PO#\n\nPO（Page Object） 是一种分层设计的思想，最早是 Selenium\n提出来的，但它本身和使用什么框架没有关系，我们在自动化测试实践过程中，应该始终使用 PO 的设计；\n\n\n4、自动等待#\n\nPlaywright 在元素定位的时候是自动等待的，不用再像使用 Selenium\n一样设置各种类型的等待（隐式等待、显示等待、强制等待），这才是框架该有的样子。\n\n\n5、断言#\n\nPlaywright 有自己的断言语句：\n\n\n\n使用 expect 语句，后面跟断言的类型，断言的类型就有点多了，大概看了下有好几十个，列几个常用的：\n\nto_have_value\n\nto_contain_text\n\nto_be_empty\n\n反向断言，前面加 not，如：not_to_contain_text","routePath":"/自动化技术/UI自动化/Playwright—8小时入门版","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":945},{"text":"三、脚本生成器","id":"三脚本生成器","depth":2,"charIndex":1072},{"text":"四、元素定位方法","id":"四元素定位方法","depth":2,"charIndex":1598},{"text":"1、XPath","id":"1xpath","depth":3,"charIndex":1691},{"text":"2、CSS","id":"2css","depth":3,"charIndex":2970},{"text":"3、特有的","id":"3特有的","depth":3,"charIndex":3073},{"text":"五、其他","id":"五其他","depth":2,"charIndex":3369},{"text":"1、截图","id":"1截图","depth":3,"charIndex":3377},{"text":"2、录屏","id":"2录屏","depth":3,"charIndex":3445},{"text":"3、PO","id":"3po","depth":3,"charIndex":3525},{"text":"4、自动等待","id":"4自动等待","depth":3,"charIndex":3624},{"text":"5、断言","id":"5断言","depth":3,"charIndex":3717}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":110,"title":"Selenium—8小时入门版","content":"#\n\n\n一、一句话简介#\n\nselenium 是一个 web 应用程序的测试工具。\n\n\n二、安装#\n\n\n\n浏览器驱动，注意一定要和你的浏览器版本匹配；\n\nselenium 驱动：https://npm.taobao.org/mirrors/chromedriver/\n\n\n三、常用控制方法#\n\n\n启动浏览器#\n\n\n\n\n浏览器控制#\n\n\n\n\n8种元素定位方法#\n\n1.id#\n\n\n\n2.name#\n\n\n\n3.class_name#\n\n\n\n4.tag_name#\n\n\n\n5.link_text#\n\n\n\n6.partial_link_text#\n\n\n\n7.css_selector#\n\n\n\n * .class ，比如：.bg 选择类为 bg 的所有元素；\n * #id ，比如：#kw 选择 id 为 kw 的元素；\n * element>element，比如：span>input 选择 span 下的所有 input 子元素（不含孙）；\n * element element，比如：span input 选择 span 下的所有 input 子元素（含孙）；\n * element+element，比如：span+input 选择与 span 同级的，且紧接着的 input 元素（只有一个）；\n * [attribute^=value]，比如：a[class^=\"bg\"] 选择类是以 bg 开头的 a 元素（$ 是以什么结尾）；\n * :nth-child，比如：input:nth-child(2) 选择父元素下第 2 个位置为 input 的元素（先找位置，再找元素）；\n * :nth-of-type，比如：input:nth-of-type(2) 选择父元素下元素 input 的第 2 个（先找元素，再找位置）；\n\n8.xpth#\n\n\n\n（1）绝对定位\n\n从 /html 开始，一层一层的往下找。\n\n（2）相对定位，以 // 开头\n\n * 元素属性定位\n   \n   \n\n * 层级属性结合\n   \n   \n\n * 使用逻辑运算符\n   \n   \n\n * 使用 contains\n   \n   \n\n\n其他常用#\n\n定位一组元素#\n\n\n\n返回的是一个列表；\n\n使用By类#\n\n\n\n\n四、简单元素操作#\n\n\n1.清除文本#\n\n\n\n\n2.模拟按键输入#\n\n\n\n\n3.单击元素#\n\n\n\n\n4.提交表单#\n\n\n\n\n5.获取元素信息#\n\n\n\n\n6.元素再操作#\n\n\n\n\n五、鼠标事件#\n\n\n1.实例#\n\n\n\n\n2.常用的鼠标事件#\n\n\n\n\n六、键盘事件#\n\n\n1.实例#\n\n\n\n\n2.常用的键盘事件#\n\n\n\n\n七、Select类#\n\n\n1.实例#\n\n\n\n\n八、内联框架#\n\n1.一个网页里面可能会遇到多个frame，不同的frame之间需要切换才能进行操作\n\n2.逐级进入\n\n\n\n3.跳转到兄弟级\n\n先调到上一级，在进入兄弟级\n\n\n\n4.跳出所有的frame\n\n\n\n\n九、窗口切换#\n\n\n\n\n十、其他常见控件#\n\n\n1.日期控件#\n\n能够写的直接写日期，不能写的，去掉readonly属性；\n\n\n\n\n2.单选或复选框#\n\n找到用click即可；\n\n\n3.表格#\n\n\n\n\n十一、警告框处理#\n\n在处理警告弹窗之前，仍然需要先点击触发的按钮\n\n\n1.切换到alert页面#\n\n\n\n\n2.引入Alert类#\n\n\n\n\n十二、截图#\n\n * driver.save_screenshot(\"screnshot.png\") 返回一个图片文件；\n\n * 浏览器换成 PhantomJS，可截整个网页；\n\n * 截下一页，可以先将光标移动到下一页，然后截图即可；\n\n\n十三、设置等待#\n\n\n1.强制等待#\n\n\n\n\n2.隐式等待#\n\n\n\n一般在打开浏览器后进行声明，表示：30秒内一旦加载完毕，就执行下一条语句，如果没有，就抛异常。\n\n\n3.显式等待#\n\n针对某一个步骤，隐式等待时间不够长，可以专门设置一个显式等待。\n\n\n\n\n十四、上传文件#\n\n1.input标签\n\n\n\n2.非 input 标签（弹窗形式）\n\n用三方工具 Auto Windows Info\n\n\n十五、验证码#\n\n1.去掉验证码\n\n2.设置万能验证码\n\n3.验证码识别技术\n\n4.操作 cookie\n\n","routePath":"/自动化技术/UI自动化/Selenium—8小时入门版","lang":"","toc":[{"text":"一、一句话简介","id":"一一句话简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":43},{"text":"三、常用控制方法","id":"三常用控制方法","depth":2,"charIndex":135},{"text":"启动浏览器","id":"启动浏览器","depth":3,"charIndex":147},{"text":"浏览器控制","id":"浏览器控制","depth":3,"charIndex":158},{"text":"8种元素定位方法","id":"8种元素定位方法","depth":3,"charIndex":169},{"text":"1.id","id":"1id","depth":4,"charIndex":180},{"text":"2.name","id":"2name","depth":4,"charIndex":189},{"text":"3.class_name","id":"3class_name","depth":4,"charIndex":200},{"text":"4.tag_name","id":"4tag_name","depth":4,"charIndex":217},{"text":"5.link_text","id":"5link_text","depth":4,"charIndex":232},{"text":"6.partial_link_text","id":"6partial_link_text","depth":4,"charIndex":248},{"text":"7.css_selector","id":"7css_selector","depth":4,"charIndex":272},{"text":"8.xpth","id":"8xpth","depth":4,"charIndex":763},{"text":"其他常用","id":"其他常用","depth":3,"charIndex":905},{"text":"定位一组元素","id":"定位一组元素","depth":4,"charIndex":912},{"text":"使用By类","id":"使用by类","depth":4,"charIndex":934},{"text":"四、简单元素操作","id":"四简单元素操作","depth":2,"charIndex":945},{"text":"1.清除文本","id":"1清除文本","depth":3,"charIndex":957},{"text":"2.模拟按键输入","id":"2模拟按键输入","depth":3,"charIndex":969},{"text":"3.单击元素","id":"3单击元素","depth":3,"charIndex":983},{"text":"4.提交表单","id":"4提交表单","depth":3,"charIndex":995},{"text":"5.获取元素信息","id":"5获取元素信息","depth":3,"charIndex":1007},{"text":"6.元素再操作","id":"6元素再操作","depth":3,"charIndex":1021},{"text":"五、鼠标事件","id":"五鼠标事件","depth":2,"charIndex":1034},{"text":"1.实例","id":"1实例","depth":3,"charIndex":1044},{"text":"2.常用的鼠标事件","id":"2常用的鼠标事件","depth":3,"charIndex":1054},{"text":"六、键盘事件","id":"六键盘事件","depth":2,"charIndex":1069},{"text":"1.实例","id":"1实例-1","depth":3,"charIndex":1079},{"text":"2.常用的键盘事件","id":"2常用的键盘事件","depth":3,"charIndex":1089},{"text":"七、Select类","id":"七select类","depth":2,"charIndex":1104},{"text":"1.实例","id":"1实例-2","depth":3,"charIndex":1117},{"text":"八、内联框架","id":"八内联框架","depth":2,"charIndex":1127},{"text":"九、窗口切换","id":"九窗口切换","depth":2,"charIndex":1233},{"text":"十、其他常见控件","id":"十其他常见控件","depth":2,"charIndex":1245},{"text":"1.日期控件","id":"1日期控件","depth":3,"charIndex":1257},{"text":"2.单选或复选框","id":"2单选或复选框","depth":3,"charIndex":1299},{"text":"3.表格","id":"3表格","depth":3,"charIndex":1324},{"text":"十一、警告框处理","id":"十一警告框处理","depth":2,"charIndex":1334},{"text":"1.切换到alert页面","id":"1切换到alert页面","depth":3,"charIndex":1370},{"text":"2.引入Alert类","id":"2引入alert类","depth":3,"charIndex":1388},{"text":"十二、截图","id":"十二截图","depth":2,"charIndex":1404},{"text":"十三、设置等待","id":"十三设置等待","depth":2,"charIndex":1525},{"text":"1.强制等待","id":"1强制等待","depth":3,"charIndex":1536},{"text":"2.隐式等待","id":"2隐式等待","depth":3,"charIndex":1548},{"text":"3.显式等待","id":"3显式等待","depth":3,"charIndex":1609},{"text":"十四、上传文件","id":"十四上传文件","depth":2,"charIndex":1654},{"text":"十五、验证码","id":"十五验证码","depth":2,"charIndex":1723}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":111,"title":"智能化功能测试","content":"#\n\n\n\n\n\n仓库地址：https://gitlabcd.uniontech.com/autotest/cd-desktop-aitest\n\n\n一、方案概述#\n\n基于深度学习智能识别应用的元素控件，用于在自动化测试操作过程中的元素定位以及判断结果时的断言处理；自动化测试过程中，测试机上的画面通过采集盒传输到服务器上，服务\n器对视频画面进行智能识别后，服务器智能判断用例是否执行成功，然后对测试机下发下一步操作指令，测试机接受并执行下一步操作。\n\n服务器与测试机之间的链接：\n\n * 服务器通过 USB 串口设备（USB-HID 协议）模拟鼠标键盘对测试机进行操作。\n * 通过视频采集设备捕获测试机的实时画面传输给服务器。\n\n服务器对采集的画面进行智能识别，识别其中的元素控件，并返回元素控件在屏幕中的坐标，服务器通过智能化分析，如果测试结果与预期一致将下一步操作指令通过串口模拟键鼠信\n号发送给测试机；如果测试结果与预期不一致将会进入中断处理及异常结果输出，继续执行后续场景，直至所有用例测试完成。\n\n\n二、深度学习环境搭建#\n\n模型训练主要对 GPU 有要求，训练模型的机器显存不低于 6G，其他配置无特殊要求。\n\n推荐性价比较高配置\n\n\n\n\n1、虚拟环境安装#\n\n\n\n一路回车\n\n第一次提示输入 yes/no ：输入 yes\n\n继续一路回车\n\n第二次提示：输入 no\n\n\n\n激活conda环境\n\n\n\n添加公司内网源\n\n\n\n如果是外网添加外网源\n\n\n\n如果要删除源\n\n\n\n\n2、安装依赖#\n\n（1）创建虚拟环境#\n\n\n\n\n\n\n\n（2）安装 Pytorch#\n\n在mmlab虚拟环境中执行\n\n\n\n（3）安装 MMCV#\n\n在mmlab虚拟环境中执行\n\n\n\n（4）安装显卡驱动#\n\n根据你的显卡下载对应驱动，比如我的显卡为 GTX1660，驱动版本为\n430，驱动下载地址：https://www.nvidia.cn/Download/Find.aspx?lang=cn\n\n\n\n禁用 nouveau 驱动\n\n\n\n填入：\n\n\n\n刷新配置文件\n\n\n\nreboot 重启后再进入 tty\n\n关闭图像界面，输入命令关闭图像界面\n\n\n\n安装驱动\n\n\n\nreboot重启，nvidia-smi查看安装状态。注意看下cuda版本，10.1，driver版。\n\n\n三、数据标注#\n\n\n1、数据标注#\n\n标注之前需要先转换图片大小，并且以数字命名，每组命名递增\n\n（1）转换大小并重命名#\n\nrename_pic.py\n\n\n\n根据终端输出的下一个序号的提示，执行 Python 文件的时候传参。\n\n\n\n（2）工具标注#\n\n使用工具 labelImg 标注\n\n\n\n终端直接输入 labelImg，回车\n\n标注模式选择：PascalVOC\n\n\n2、智能标注#\n\n打开屏幕录制软件，录制手动操作一次测试用例，然后将录制的视频进行分帧，然后对比前两帧图标相似度，剔除相似度过高的图片，在保证素材多样性的前提下，剔除重复多余的图\n片生成待标注的素材集，然后取出控件模板数据集，通过 OpenCV\n模板匹配获取控件在待标注的素材图片中所在的左上、左下、右上、右下四处坐标，从而根据模板数据集生成标注数据。参考目录 AnnotationMaterial\n\n（1）模板数据集准备#\n\n1、在界面截取需要标注的元素控件，放在目录下 AnnotationMaterial/template/img\n\n2、维护控件名与元素控件的键对，一个控件名可对应多个元素控件\n\n\n\n（2）素材集准备#\n\n录制视频或或屏幕截图放置目录 AnnotationMaterial/source\n\n（3）开始标注#\n\n\n\n生成的标注数据存放在 AnnotationMaterial/result\n\n\n四、MMDetection#\n\n\n1、 MMDetection 代码#\n\nMMDetection 是一个有名的深度学习目标检测开源项目，也是 openMMlab 的招牌项目，为什么选择它，小孩儿没娘说来话长，感兴趣可以自行深入了解；\n\n你可以直接在 GitHub 上克隆代码，也可以直接使用咱们仓库下 Train 目录中代码，Train 中的代码也是从 GitHub\n上拉取的，不过我们根据项目需要做了一些二次开发，推荐直接使用它。\n\n如果你想从 GitHub 上拉：\n\n\n\n\n2、拉取 voc2coco 代码#\n\n\n\n\n3、转换 coco 数据集#\n\n将所有的图片和xml文件放入train2017，从中挑选几组放入val2017（测试集）\n\n\n\n生成json文件\n\n\n4、修改配置#\n\n（1）读取模型名称\n\n\n\n\n\n（2）修改 faster_rcnn_r101_2x_coco.py\n\nmmdetection/xianjin/faster_rcnn_r101_2x_coco.py\n\n修改46行，num_clasess的值，新增1个，就 +1；\n\n（3）修改 coco.py\n\nmmdetection/mmdet/datasets/coco.py\n\nCLASSES = ()，在里面添加模型名称；\n\n（4）修改 class_names.py\n\nmmdetection/mmdet/core/evaluation/class_names.py\n\ncoco_classes 里面添加模型名称；\n\n\n5、缓存清理#\n\n删除 mmdetection/build 目录\n\n\n\n\n6、训练模型#\n\n（1）指定自己配置的训练模型；\n\n\n\n（2）查看训练结果的测试集结果；\n\n\n\n（3）查看训练结果的准确度；\n\n\n\n\n7、快捷操作#\n\n\n\n将以上 4 - 7 步操作整合成 run.py，一键完成。\n\n\n五、硬件环境#\n\n1、设备清单#\n\n * 测试机至少一台；\n * 服务端一台（目前仅支持AMD架构）；\n * 采集盒一个 （ACASIS hdmi视频采集卡，https://item.jd.com/10024310742602.html ）；\n * USB串口转USB键鼠协议线（优胜电子科技USB串口转USB键鼠协议线B类，https://item.taobao.com/item.htm?spm=a1\n   z10.3-c.w4002-1385258877.57.7ea037891D6nKh&id=611894882981 ）；\n\n2、硬件环境搭建#\n\n * 采集盒，HDMI 端连接测试机， USB 端连接到服务器上；\n * USB 串口线，白色端连接服务器，黑色端连接测试机；\n * 如果需要可以接USB延长线；\n * 测试机上可以不接显示器；\n\n3、推荐配置#\n\n执行用例的服务端对配置没有特殊要求，如果条件允许配置越高，识别速度用例执行速度越快。\n\n\n\n测试机上不执行任何脚本，具体配置根据测试需要决定。\n\n\n六、USB_MK串口驱动方法#\n\n位于control_method目录下的usb_mk.py文件\n\n（1）列出可通信的端口\n\n\n\n\n\n（2）修改串口的权限\n\n\n\n（3）实例化USB_MK\n\n\n\n（4）USB串口设备默认波特率为9600（经测试波特率9600准确性最好）。\n\n\n1、键盘操作#\n\n（1）按下键盘按键\n\n\n\n（2）按下键盘按键并且不放\n\n\n\n（3）组合按键\n\n\n\n（4）组合按键不放\n\n\n\n（5）释放所有键盘按键\n\n\n\n（6）键盘输入字符串（汉字会自动转成拼音输入）\n\n\n\n\n2、鼠标操作#\n\n（1）按下鼠标左键\n\n\n\n（2）按下鼠标左键不放\n\n\n\n（3）释放鼠标所有按键\n\n\n\n（3）按下鼠标右键\n\n\n\n（4）鼠标左键双击\n\n\n\n（5）恢复鼠标至初始位置，默认左上角\n\n\n\n（6）移动鼠标至相对坐标\n\n\n\n（7）以屏幕左上角为圆心坐标移动鼠标至屏幕绝对坐标\n\n\n\n（8）按下鼠标左键，拖动到绝对坐标位置\n\n\n\n（9）按下鼠标左键，拖动到相对坐标位置\n\n\n\n\n七、方法调用入参规则#\n\n\n1、基类#\n\n\n\n\n2、入参说明#\n\n图像识别方法入口为 Base 类下的 find_element_by_ai 。仅接受一个参数 element，类型为 string。\n\n可识别的 string 格式：\n\n（1）大图标（ 图标大于 40 像素）：识别某个大图标，例：\n\n\n\n（2）大图标 / 小图标（图标小于 40 像素）：识别某个小图标，例：window/search_btn\n\n\n\n（3）大图标 / OCR：识别某个大图标内的文字，例：menu/属性\n\n\n\n（4）OCR：全屏识别文字\n\n\n\n\n八、隐藏鼠标#\n\n通过采集盒传输过来的视频流，在识别过程中可能受到鼠标影响，因此用例执行过程中需要隐藏鼠标。\n\n屏蔽鼠标光标显示\n\n\n\n在[Seat:*]下面添加参数\n\n\n\n\n九、智能自动化的意义#\n\n1、改善 Acessibility 定位的稳定性问题\n\nAcessibility 属性定位存在偶尔失效的情况\n\n（1）开发在做新需求开发时可能涉及到对属性标签的修改或者层级的调整，可能造成自动化用例无法定位到元素。\n\n * 比如1040阶段，音乐重构的时候，开发对部分属性和层级做了修改，导致自动化用例定位方法80%需要修改。\n * 开发新功能的时候偶尔也会对属性做调整，遇到5次。\n\n（2）目前主要使用Dogtail识别应用Acessibility属性进行定位，是获取应用当前界面的属性tree，在应用跳转后，Dogtail存在无法及时获取当前\n属性列表的情况。\n\n * 多媒体调用文管窗口的时候，出现找不到文管里面元素的情况，目前出现10+次。\n * 应用设置页面的属性偶尔存在找不到的情况，遇到5次。\n\n（3）Dogtail工具本身存在问题，有时定位元素的时候很慢，让人无法接受，目前出现过很多次。\n\n * 执行用例的时候，定位元素的时间比平常慢3倍，出现4次。\n\n2、解决了使用绝对图像识别定位的容错性差的问题\n\n部分控件无法添加 Acessibility 属性从而使用图像识别定位出现的容错性差的问题。\n\n（1）图像识别定位方法需要维护大量的目标图片资源，在 UI 发生变化之后，会涉及到目标资源的替换，比较耗费人力。\n\n（2）图像识别的定位方法对比精度比较搞，如果UI 的变更会造成无法准确定位到，自动化脚本健壮性不足。\n\n3、使用机器分离，解决了自动化脚本对应用的影响，真实还原用户的使用场景\n\n机器分离的架构设计，保证了测试机的测试环境完全等同于用户，排除测试脚本的影响。\n\n（1）目前的功能自动化是在测试机上直接运行自动化测试脚本，加上用例执行过程中我们添加了一些进程监控、视频录制等功能，自动化脚本本身会消耗一些系统资源，无法还原真\n是的用户使用场景。\n\n（2）性能测试需要排除其他程序的资源消耗影响，性能自动化采用机器分离，保证了性能数据的准确性。\n\n以前的用例执行耗时没条在30秒左右，现在用例耗时在10秒。\n\n4、解决了UI 调整导致定位失败的不稳定性问题\n\n（1）解决了因 UI 调整导致控件位置变化或色差变化后定位不准确的问题，只要控件文案和控件外边框无变化均可准确定位；\n\n（2）目前也会采用基于UI的定位方案，如果UI位置有调整，会导致元素无法定位。\n\n5、简化了用例结构，提升编写友好度\n\n（1）智能自动化识别元素的方法只有一个，就是基于我们训练的模型识别视频流中的元素，经过脚本封装之后，在自动化用例中所有定位的操作都只需要调用这一个方法就行了，编\n写自动化脚本的难度大大降低。\n\n（2）也是由于调用方法简单，在 UI\n自动化测试框架中的分层结构将会减少，多继承的情况会减少，自动化代码的调用结构也会变得简单，而且功能测试同学编写自动化用例会更加容易上手。\n\n以前写用例由于需要结合不同的模块，调用不同的方法，编写一条用例并完成调试的时间平均在20-30分钟，现在写用例脚本能在5分钟左右完成。","routePath":"/自动化技术/UI自动化/智能化功能测试","lang":"","toc":[{"text":"一、方案概述","id":"一方案概述","depth":2,"charIndex":71},{"text":"二、深度学习环境搭建","id":"二深度学习环境搭建","depth":2,"charIndex":453},{"text":"1、虚拟环境安装","id":"1虚拟环境安装","depth":3,"charIndex":524},{"text":"2、安装依赖","id":"2安装依赖","depth":3,"charIndex":639},{"text":"（1）创建虚拟环境","id":"1创建虚拟环境","depth":4,"charIndex":648},{"text":"（2）安装 Pytorch","id":"2安装-pytorch","depth":4,"charIndex":666},{"text":"（3）安装 MMCV","id":"3安装-mmcv","depth":4,"charIndex":699},{"text":"（4）安装显卡驱动","id":"4安装显卡驱动","depth":4,"charIndex":729},{"text":"三、数据标注","id":"三数据标注","depth":2,"charIndex":974},{"text":"1、数据标注","id":"1数据标注","depth":3,"charIndex":984},{"text":"（1）转换大小并重命名","id":"1转换大小并重命名","depth":4,"charIndex":1023},{"text":"（2）工具标注","id":"2工具标注","depth":4,"charIndex":1092},{"text":"2、智能标注","id":"2智能标注","depth":3,"charIndex":1161},{"text":"（1）模板数据集准备","id":"1模板数据集准备","depth":4,"charIndex":1362},{"text":"（2）素材集准备","id":"2素材集准备","depth":4,"charIndex":1465},{"text":"（3）开始标注","id":"3开始标注","depth":4,"charIndex":1518},{"text":"四、MMDetection","id":"四mmdetection","depth":2,"charIndex":1569},{"text":"1、 MMDetection 代码","id":"1-mmdetection-代码","depth":3,"charIndex":1586},{"text":"2、拉取 voc2coco 代码","id":"2拉取-voc2coco-代码","depth":3,"charIndex":1808},{"text":"3、转换 coco 数据集","id":"3转换-coco-数据集","depth":3,"charIndex":1830},{"text":"4、修改配置","id":"4修改配置","depth":3,"charIndex":1905},{"text":"5、缓存清理","id":"5缓存清理","depth":3,"charIndex":2218},{"text":"6、训练模型","id":"6训练模型","depth":3,"charIndex":2255},{"text":"7、快捷操作","id":"7快捷操作","depth":3,"charIndex":2322},{"text":"五、硬件环境","id":"五硬件环境","depth":2,"charIndex":2365},{"text":"1、设备清单","id":"1设备清单","depth":4,"charIndex":2374},{"text":"2、硬件环境搭建","id":"2硬件环境搭建","depth":4,"charIndex":2634},{"text":"3、推荐配置","id":"3推荐配置","depth":4,"charIndex":2744},{"text":"六、USB_MK串口驱动方法","id":"六usb_mk串口驱动方法","depth":2,"charIndex":2827},{"text":"1、键盘操作","id":"1键盘操作","depth":3,"charIndex":2965},{"text":"2、鼠标操作","id":"2鼠标操作","depth":3,"charIndex":3071},{"text":"七、方法调用入参规则","id":"七方法调用入参规则","depth":2,"charIndex":3263},{"text":"1、基类","id":"1基类","depth":3,"charIndex":3277},{"text":"2、入参说明","id":"2入参说明","depth":3,"charIndex":3287},{"text":"八、隐藏鼠标","id":"八隐藏鼠标","depth":2,"charIndex":3527},{"text":"九、智能自动化的意义","id":"九智能自动化的意义","depth":2,"charIndex":3615}],"domain":"","frontmatter":{},"version":""},{"id":112,"title":"智能化性能测试","content":"#\n\n\n\n\n\n\n一、简述#\n\n智能化性能测试\n\n通过自动化手段对应用进行性能测试，提供方便的环境部署、运行配置、用例编写等，用于桌面应用的冷热启动、资源拷贝、页面跳转等性能场景测试。\n\n仓库地址：https://gerrit.uniontech.com/admin/repos/autotest-perf-aitest\n\n\n二、代码结构#\n\n\n\n\n三、环境搭建#\n\n\n1、硬件环境#\n\n（1）设备清单#\n\n * 测试机至少一台。\n\n * 服务端一台。（仅支持 AMD 架构，若需其他架构，咨询相关开发人员）\n\n * 采集盒一个。 （ACASIS HDMI 视频采集盒，https://item.jd.com/100013302599.html#crumb-wrap ）\n\n * USB串口转USB键鼠协议线。（优胜电子科技USB串口转USB键鼠协议线B类，https://item.taobao.com/item.htm?spm=a\n   1z10.3-c.w4002-1385258877.57.7ea037891D6nKh&id=611894882981 ）\n\n（2）硬件环境搭建#\n\n * 采集盒，HDMI 端连接测试机， USB 端连接到服务器上。\n * USB 串口线，白色端连接服务器，黑色端连接测试机（USB3.0 接口上）。\n * 如果需要可以接 USB 延长线。\n * 测试机上可以不接显示器。\n\n（3）服务端推荐配置#\n\n配置越高，解析速度越快。\n\n\n\n\n2、测试机环境搭建#\n\n * 打开控制中心，账户设置为【自动登录】和【无密码登录】，电源管理中使用电源全部设置为【从不】，开启开发者模式。\n\n * 根据应用性能测试要求，导入相关测试资源，比如：导入相册、影院、音乐的测试资源。\n\n * 在服务端打开相机应用后，将测试机桌面壁纸更换为纯色壁纸（注意，服务端需提前开启相机后再设置测试机壁纸，建议纯黑壁纸\n   setting/res/black.png）\n\n * 在文件管理器中，将选项 主菜单-设置-预览-图片预览 取消勾选（如不取消，会影响截图录屏应用的性能数据）\n\n * 移动或删除系统 Logo ，排除桌面右下角 Logo 的影响（重启生效）。\n   \n   \n\n * 安装鼠标绝对坐标操作依赖（必须安装！！）\n   \n   * AMD 安装 setting/res 目录下 xserver-xorg-input-libinput_0.28.2-2_amd64.deb\n   \n   * ARM 安装 setting/res 目录下 xserver-xorg-input-libinput_0.28.2-2_arm64.deb\n   \n   * MIPS 安装 setting/res 目录下 xserver-xorg-input-libinput_0.28.2-2_mips64.deb\n   \n   * 3A5000 安装 setting/res 目录下 xserver-xorg-input-libinput_0.28.2-2_5000.deb\n   \n   * 安装命令\n     \n     \n   \n   安装时会提示已存在相同版本，请忽略，直接覆盖安装，安装完成后，必须重启主机才生效\n\n\n3、服务端一键环境部署#\n\n环境搭建前必须先连接上 USB 串口线和采集盒。\n\n宿主机环境安装\n\n\n\n容器环境安装\n\n\n\n\n四、配置项#\n\n\n1、服务端配置#\n\nsetting/config/server.ini\n\n用于配置测试过程中的一些配置项，包含了所有服务端所有的可配置项。\n\n * 本地无网络运行\n   * 将配置项 network=0 即可开始测试。\n * 本地有网络运行\n   * 配置项 network=1\n   * (1)配置项 client_alias= 配置为你要测试的测试机别名，如 Alias1 测试机别名在\n     setting/config/client.ini 中进行配置，此时，直接运行 python3 manager 即可开始测试。\n   * (2)配置项 client_alias= 为空，测试机别名在 config/client.ini 中进行配置，此时，直接运行 python3\n     manager --client_alias Alias1，即可开始测试。(Alias1 为你配置的测试机别名)\n   * (1)和(2)只要使用其一即可。\n * 有网络运行，且需要通过 Jenkins 上运行一个 job ，同时控制多台机器。\n   * 配置项 network=1\n   * 配置项 client_alias= 不用配置，在运行 run.sh 的时候直接空格加别名即可，比如：测试机别名为 Alias1 ，且已经在\n     config/client.ini 中配置了 Alias1 的user ip password ，则运行 bash run.sh Alias1\n     即可开始测试。\n   * 在 Jenkins pipeline 里面通过并行 stage 或并行调用下层任务的方式可以实现大规模的性能测试需求。\n\n详细配置项说明：\n\n\n\n\n2、测试机配置#\n\nsetting/config/client.ini\n\n用于配置测试机的信息。\n\n * 有网络的情况下，服务端需要动态获取测试机上的一些资源，因此你需要写入 测试机别名 、 user 、ip、 password 。\n   \n   \n   \n   命名建议：AliasA1、AliasA2、AliasB1、AliasB2，不要重名。\n\n * 无网络情况下，仅需要关注测试机分辨率配置项 width=、 height= 即可。\n\n详细配置项说明：\n\n\n\n\n3、场景个性化配置#\n\n随着测试场景的不断引入，发现现有服务端里的配置项并不适用于所有的性能场景，于是将服务端配置进行一个提取，可做单个场景的个性化配置，当然原来的服务端配置功能保留，\n只是当你配置了场景个性化配置后，优先使用个性化配置里面的内容，以下是对个性化配置的介绍。\n\n目前每一个 py 文件对应一个性能测试场景，于是在同级目录下创建一个与之同名的 json 文件，作为个性化配置文件\n\n\n\n以下是对 json 文件中配置的解释，若某项配置不需要，可以缺失，但不能为空；\n\n\n\n\n五、测试流程#\n\n\n\n\n六、用例编写及方法参数指引#\n\n\n1、用例实例说明#\n\n\n\n\n2、方法参数说明#\n\n2.1、find_element 方法\n\n\n\n * 参数 element 和 input_type\n   \n   （1）通过应用 icon 识别元素\n   \n   * input_type 参数为默认参数，默认值为 FIEL_NAME ，表示通过应用 icon 寻找元素，此方法会动态获取测试机上的应用 icon\n     图标。\n   * 举例：默认情况下 input_type 参数不需要传入， find_element(\"deepin-album\")，表示通过 deepin-album\n     的应用 icon 来获取坐标，注意，此时传入的 deepin-album 参数实际是 desktop文件的文件名，和2.3中的 icon 变量一致。\n   * 我们建议优先使用这种方法，但此方法依赖网络，请根据测试环境实际情况选择。\n   \n   （2）通过本地图片识别元素\n   \n   * 参数 input_type 传入图片格式，比如截取的本地图片格式为 png，那么 input_type=\"png\"，此时参数 element\n     传入图片的路径，建议存放在对应的产品 apps/app/picture/ 目录下，路径为项目根目录下的相对路径。\n   * 举例：find_element(\"apps/autotest_deepin_album/picture/open.png\",\n     input_type=\"png\"))，表示通过本地图片 open.png 识别元素。\n\n * 参数 fill_color_position\n   \n   * fill_color_position 参数为默认参数，默认值为 (-1, -1)，(-1, -1) 表示取屏幕中右下角最后一个像素点作为填充坐标，在\n     1920x1080 屏幕分辨率下即实际坐标为 (1919, 1079) ，这样的写法可以适配不同大小的屏幕。\n   * 任务栏在屏幕不同方位：\n     * 任务栏在屏幕下方，从任务栏启动不需要传入该参数。\n     * 任务栏在屏幕左边，fill_color_position=(1, 1)\n     * 任务栏在屏幕右边，fill_color_position=(-1, -1)\n     * 任务栏在屏幕上边，fill_color_position=(1, 1)\n   * 从桌面启动应用，则需要传入除任务栏以外其他位置的坐标，比如(100, 100)，只要这个坐标为除应用和任务栏区域都可以。\n   * 从启动器里面启动应用，需要填充的坐标为启动器区域。\n   \n   注：通过应用 icon 识别时，从测试机获取的 icon 原文件为 svg 矢量图，转换为 png 之后需要填充边缘透明部分。\n\n * 参数 size\n   \n   * size 参数为默认参数，默认值为 (25, 70)，表示测试机上 dock 栏上应用图标的大小范围。\n   * UOS 系统 dock 栏是可以上下拖动大小的，随着 dock 栏大小改变，应用图标的范围为25到70之间。\n   * 如果你的测试机操作系统上 dock 栏大小不一样，可以根据实际情况传入大小范围。\n\n2.2、click_element、 right_click_element， double_click_element 这几个方法参数规则与\nfind_element 方法一样。他们实际上是在 find_element\n方法基础之上做了二次封装，增加了鼠标的动作，如果你不想使用这几个方法，在用例中也可以通过 find_element\n获取到坐标，然后将坐标传入到键鼠的方法中，可以实现同样的效果。\n\n2.3、用例类中有个类变量 icon = [\"deepin-album\"] 需要特殊说明，列表中的元素为这条用例里面需要用到的所有\nicon，用例执行之前会从测试机上拷贝所有需要用的 icon 到服务端用于图像识别。列表中元素为应用 desktop 文件的文件名，相册的 desktop\n文件名为 deepin-album.desktop，只需要写 deepin-album 即可，.desktop 已经在底层做了拼接。\n\n\n七、执行入口#\n\n\n1、用例组织#\n\n在 setting/config/server.ini 文件中 APP_NAME= 字段为用例的执行的目录，默认为 apps\n目录下所有用例。如果你想指定执行某一个应用的用例，你可以将该配置项指定到应用的用例目录，比如：APP_NAME=deepin_album，\n表示执行相册目录下的用例。\n\n\n2、命令行参数#\n\n通过命令行参数配置参数\n\n以下为 python3 manage.py run 提供的一些参数选项：\n\n\n\n在一些 CI 环境下使用命令行参数会更加方便：\n\n\n\n注：在容器中执行时，若强制退出，容器并不会停止运行！\n\n\n八、测试报告#\n\n\n1、Json 报告#\n\n自研视频解析工具会对单条用例执行一轮生成一个 json 文件，存放于 report/{app_name}/{scene}/{run_num}\n目录下，命名格式为：\n\n\n\njson 内容举例：\n\n\n\n说明：\n\n * Stab ：表示解析过程中不同的阶段。\n * images ：表示每一帧的图片序号。\n * startStub： 为识别尾帧的阶段表示，如果 \"startStub\": 1 ，说明尾帧出现在该阶段。\n * type： 为 Stab 或 UnStab ，表示稳定阶段或不稳定阶段。\n\n各阶段有帧数补偿，默认补偿的帧数为 3 帧（可以通过 server.ini 里面 un_stab_start=3 进行配置），表示小于等于 3\n帧的不稳定阶段视为稳定阶段，在最后计算性能结果时前后均需要减掉。\n\n应用启动阶段就是在 Stab2 阶段，启动时间为：171 减 151 再减掉前后补偿帧数 6 帧，即 14 帧，视频帧率 30 帧/秒，因此启动耗时为：14 *\n33 = 462 ms\n\n\n2、Excel 报告#\n\n所有用例执行并解析完之后会 report 目录下生成一个汇总数据的 Excel 文件，文件名为：{time}_perf_time.xlsx。\n\n注意，report 目录为可配置项，默认情况下会在项目根目录下生成，如果你将 report，指定到项目下其他路径，则会在对应的路径下生成 json 和\nExcel 文件。\n\n你也可以根据需要读取所有 json / excel 报告的数据，生成你自己想要的一些测试报告形式。\n\n\n九、USB 串口驱动键鼠方法#\n\n位于 src/utils/control/serial_communication 目录下的 usb_mk.py 文件\n\n\n\n\n1、键盘操作#\n\n（1）按下键盘按键\n\n\n\n（2）按下键盘按键并且不放\n\n\n\n（3）组合按键\n\n\n\n（4）组合按键不放\n\n\n\n（5）释放所有键盘按键\n\n\n\n（6）键盘输入字符串（支持传入汉字，会自动转成拼音输入）\n\n\n\n\n2、鼠标操作#\n\n（1）按下鼠标左键\n\n\n\n（2）按下鼠标左键不放\n\n\n\n（3）释放鼠标所有按键\n\n\n\n（4）按下鼠标右键\n\n\n\n（5）鼠标左键双击\n\n\n\n（6）恢复鼠标至初始位置，默认左上角\n\n\n\n（7）移动鼠标至相对坐标\n\n\n\n（8）以屏幕左上角为圆心坐标移动鼠标至屏幕绝对坐标\n\n\n\n（9）按下鼠标左键，拖动到绝对坐标位置\n\n\n\n（10）按下鼠标左键，拖动到相对坐标位置\n\n\n\n\n十、继电器控制主机开机/重启#\n\n（若不使用继电器，可忽略该步骤，执行时会通过命令 reboot）\n\n\n1、继电器设备#\n\nLCUS-2 型 双路 USB 智能串口控制继电器。\n\nhttps://item.taobao.com/item.htm?spm=a1z09.2.0.0.41d72e8dUYx2pi&id=582653718178&\n_u=i25r20ia6a2e\n\n\n\n\n2、USB 延长线#\n\n普通的 USB 线即可。\n\n\n\n\n3、杜邦线#\n\n3.1、40P 母对公杜邦线。\n\n\n\n3.2、一母二公杜邦线。\n\n\n\n\n4、安装图文教程#\n\n4.1、使用 USB 延长线连接控制端和继电器。\n\n\n\n4.2、在继电器常端和公共端均连接一根杜邦线。\n\n\n\n4.3、在主板上开机针和重启针上插上一母二公杜邦线。\n\n\n\n4.4、将开机针外接的一母二公杜邦线的两根公线分别接入继电器的1路继电器（如图 1左侧继电器）和原电源开关。\n\n4.5、将重启针外接的一母二公杜邦线的两根公线分别接入继电器的2路继电器（如图 1 右侧继电器）和原电源开关。\n\n\n\n若想保留原电源开关的电源灯，可根据如上图所示，使用杜邦线连接主板上的电源灯和原电源开关\n\n\n十一、常见问题说明#\n\n1、ERROR: for uos Cannot restart container\n2301b1a1395d7959ee6523d61b61c87084649af530786cdb8fb5b3ecbcbd1068: linux runtime\nspec devices: error gathering device information while adding custom device\n\"/dev/ttyACM0\": no such file or directory\n\n检查 USB 串口线连接状态，查看 /dev/ttyACM0 是否存在，若存在 /dev/ttyACMn（n为任意数字），重启电脑解决。\n\n2、Error response from daemon: Container\n5e700fdc769e8c74666d68a7f2bc3de58268b4594cf88706609d59f8dbc7362d is not running\n\n容器启动失败\n\n1）检查哪一个容器未启动\n\n\n\n\n\n2）缺少 uos 容器，检查 USB 串口连接线和采集盒连接线是否正常，重启后执行\n\n\n\n或执行\n\n\n\n**3、**若部署时提示挂载 ttyACM0、video0 失败，请检查 USB 串口线及采集盒是否接触良好，若接触良好，重启即可解决。\n\n4、若出现图片能识别，但是鼠标未移动操作时，安装绝对鼠标操作的依赖包，见第三节第二小节测试机环境搭建，安装完成后，必须重启测试机。\n\n5、由于通过采集卡获取的测试机实时画面，包含了鼠标的样式，所以对图片识别时，鼠标若停留在图标上层，则会对识别结果造成影响，需要将鼠标移动至其他位置，或者隐藏鼠标\n解决。\n\n6、Excel 报告中，测试场景列与用例中的不一致，关键字scene、app_name、架构别名，不能包含下划线和英文符号的圆括号。","routePath":"/自动化技术/UI自动化/智能化性能测试","lang":"","toc":[{"text":"一、简述","id":"一简述","depth":2,"charIndex":7},{"text":"二、代码结构","id":"二代码结构","depth":2,"charIndex":161},{"text":"三、环境搭建","id":"三环境搭建","depth":2,"charIndex":173},{"text":"1、硬件环境","id":"1硬件环境","depth":3,"charIndex":183},{"text":"（1）设备清单","id":"1设备清单","depth":4,"charIndex":192},{"text":"（2）硬件环境搭建","id":"2硬件环境搭建","depth":4,"charIndex":482},{"text":"（3）服务端推荐配置","id":"3服务端推荐配置","depth":4,"charIndex":607},{"text":"2、测试机环境搭建","id":"2测试机环境搭建","depth":3,"charIndex":637},{"text":"3、服务端一键环境部署","id":"3服务端一键环境部署","depth":3,"charIndex":1367},{"text":"四、配置项","id":"四配置项","depth":2,"charIndex":1429},{"text":"1、服务端配置","id":"1服务端配置","depth":3,"charIndex":1438},{"text":"2、测试机配置","id":"2测试机配置","depth":3,"charIndex":2170},{"text":"3、场景个性化配置","id":"3场景个性化配置","depth":3,"charIndex":2405},{"text":"五、测试流程","id":"五测试流程","depth":2,"charIndex":2649},{"text":"六、用例编写及方法参数指引","id":"六用例编写及方法参数指引","depth":2,"charIndex":2661},{"text":"1、用例实例说明","id":"1用例实例说明","depth":3,"charIndex":2678},{"text":"2、方法参数说明","id":"2方法参数说明","depth":3,"charIndex":2692},{"text":"七、执行入口","id":"七执行入口","depth":2,"charIndex":4466},{"text":"1、用例组织","id":"1用例组织","depth":3,"charIndex":4476},{"text":"2、命令行参数","id":"2命令行参数","depth":3,"charIndex":4634},{"text":"八、测试报告","id":"八测试报告","depth":2,"charIndex":4753},{"text":"1、Json 报告","id":"1json-报告","depth":3,"charIndex":4763},{"text":"2、Excel 报告","id":"2excel-报告","depth":3,"charIndex":5223},{"text":"九、USB 串口驱动键鼠方法","id":"九usb-串口驱动键鼠方法","depth":2,"charIndex":5447},{"text":"1、键盘操作","id":"1键盘操作","depth":3,"charIndex":5528},{"text":"2、鼠标操作","id":"2鼠标操作","depth":3,"charIndex":5639},{"text":"十、继电器控制主机开机/重启","id":"十继电器控制主机开机重启","depth":2,"charIndex":5832},{"text":"1、继电器设备","id":"1继电器设备","depth":3,"charIndex":5884},{"text":"2、USB 延长线","id":"2usb-延长线","depth":3,"charIndex":6023},{"text":"3、杜邦线","id":"3杜邦线","depth":3,"charIndex":6052},{"text":"4、安装图文教程","id":"4安装图文教程","depth":3,"charIndex":6096},{"text":"十一、常见问题说明","id":"十一常见问题说明","depth":2,"charIndex":6353}],"domain":"","frontmatter":{},"version":""},{"id":113,"title":"自动化技术-章节预览","content":"","routePath":"/自动化技术/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"自动化技术-章节预览"},"version":""},{"id":114,"title":"JMeter—10小时入门版","content":"#\n\n\n简介#\n\n全称 Apache JMeter ，一个基于 Java 的开源性能测试工具，有些同学也用来做一些简单的接口测试，但它主要的功能是用来做性能的。\n\n其工作原理是，建立一个线程池，多线程运行取样器产生大量负载，在运行中通过断言来验证结果的正确性，通过监听器来记录测试结果；\n\nGithub地址：https://github.com/apache/jmeter\n\n\nJmeter 组件#\n\n\n线程组#\n\n可以看做一个虚拟用户组，线程组中的每个线程都可以理解为一个虚拟用户；\n\n线程数就表示虚拟用户数；\n\nRamp-up Period 爬坡启动时间，单位是秒，默认时间是1，它制定了启动所有线程所花费的时间。\n\n（举例：线程数10个，运行时间5，就是1秒启动2个）\n\n\n\n\n\n\n取样器（sampler）#\n\n性能测试中向服务器发送请求，记录响应信息，记录响应时间的最小单元。\n\n\n\n\n逻辑控制器（logic controller）#\n\n两类：\n\n① 控制测试计划中取样器节点发送请求的逻辑顺序的控制器（if/switch/Controller）\n\n② 用来组织可控制取样器节点的，失误控制器、吞吐量控制器。\n\n（1）循环控制器#\n\n\n\n线程组循环次数与循环控制器循环次数叠加（相乘）\n\nbadboy 录制的循环控制器和 jmeter 带的循环控制器不兼容\n\n（2）ForEach控制器#\n\n\n\n后面的请求是加在 ForEach 控制器下面\n\n\n\n（3）If 控制器#\n\n\n\n注意：条件里面，变量要用 \"${}\" ,if 下面加 http 请求\n\n（4）switch 控制器（开关）#\n\n 1. 在逻辑控制器里面选择 switch controller（switch控制器）\n 2. 在控制器内添加多个请求\n 3. 可通过请求名称来控制，或通过请求序号来控制（序号从0开始）\n\n\n\n\n\n（5）吞吐量控制器#\n\n 1. 在逻辑控制器里面选择吞吐量控制器（用于控制发送的请求数）\n\n 2. Total Executions（吞吐量）输入数据，输入数据要小于等于线程组数（每个线程发送4次，线程组数和循环次数无效）\n\n 3. Percent Executions 吞吐量百分比（线程组数10个，吞吐量百分比25，每个线程发送2次，百分比25.5，每个线程发送3次）\n\n\n\n\n\n\n定时器#\n\n①固定定时器（思考时间）\n\n每个线程在请求之前按相同的制定时间停顿。\n\n②同步定时器（集合点）\n\n集合点，等到特定的用户数后再一起执行某个操作。\n\n\n\n\n\n\n\nNumber of Simulated Users to Group by:集合多少人后再执行请求；\n\nTimeout in milliseconds\n:指定人数多少秒没有集合到算超时（延迟时间，单位毫秒）;如果为0，表示无超时时间，会一直等下去。如果线程数小于集合人数，到时间就会发出去。\n\n\n配置元件#\n\n用于提供对静态数据配置的支持\n\n参数化有三种：\n\n 1. CSV Data Set config\n 2. 函数助手\n 3. 用户自定义变量\n\n① CSV Data Set config\n\n可以将本地数据文件形成数据池。\n\n\n\n\n\n② 函数助手\n\n选项-函数助手\n\n\n\n\n\n\n\n\n\n\n\n③ 用户自定义变量\n\n\n\n\n\n\n\n\n\n④计数器\n\n\n\n\n\n\n\n\n\n${__v(name_${N})} 两层变量用v函数，固定用法。\n\n\n元件的作用域#\n\n 1. 配置元件\n\n会影响其作用范围内的所有元件。\n\n 2. 前置处理程序\n\n在其作用范围内的每个sampler元件之前执行。\n\n 3. 定时器\n\n对在其所用范围内的每个sampler有效。\n\n 4. 后置处理程序\n\n在其作用范围内的每个sampler元件之后执行。\n\n 5. 断言\n\n在其作用范围内的每个sampler元件执行后结果进行校验。\n\n 6. 监听器\n\n收集其作用范围内的每个什么sampler元件的信息并呈现。\n\n 7. 取样器\n\n不予其他元件相互作用。\n\n 8. 逻辑控制器\n\n对其子节点中的去延期或逻辑控制器作用。\n\n\n脚本开发#\n\n\n脚本录制#\n\nbadboy\n\n\n脚本生成#\n\n1.关联\n\n关联：用于获取一个响应数据中的结果；\n\n在后置处理器中-正则表达式提取器；\n\n\n\n正则表达式\n\n 1. 引用名称：下一个请求要引用的参数名称，\n\n2.（）：括起来的部分就是要提取\n\n\n\n3.模块：用$$引用起来，如果有多个（）内容，可以用$1$,$2$等，标识解析到第几个值\n\n4.匹配数字：0代表随机，-1代表全部，其余整整数代表提取第几个匹配的内容。\n\n5.添加Debug进行调试\n\n任意字符串的取法：（.+?）或（.*?）\n\n\n\n数字的取法：\n\n（[0-9]*）,[0-9]表示取0-9的任意数字，*表示任意多次 ##表达式前面的字符不要太多\n\n\n\n2.http请求默认值\n\n有相同的服务器名称或IP地址时，将其填入请求默认值中，减小工作量。\n\n\n\n\n\n\n\n\nwebservice接口测试#\n\nsoap请求底层是调用的http请求\n\n请求的报文是xml，返回的报文也是xml\n\n\n\n\nJDBC请求#\n\n 1. 添加控制元件，JDBC Connection Configuration\n 2. 添加sampler ，JDBC Request\n 3. 配置如下：\n\n（1）Variable Name：变量名可自定义\n\n（2）JDBC URL：jdbc:mysql://127.0.0.1:3306/ecshop\n\n（3）JDBC Driver Class：com.mysql.jdbc.Driver\n\n（4）username: 数据库名\n\n（5）password：数据库密码\n\n\n\n 4. 时区设置问题\n\n在 URL 末尾加 ?serverTimezone=UTC\n\n 5. 要添加多条 SQL 语句\n\n在 URL 末尾加 ?allowMultiQueries=true （前面有？的用&连接），JDBC Request 中\n\n 6. 设置字符集类型\n\n在URL末尾加 ?characterEncoding=UTF-8\n\n\n\n\n\n 7. 插入删除更新操作，Query Type 都选 update Statement\n\n\n\n\nFTP请求#\n\n 1. sampler 中添加 FTP 请求\n 2. 配置如下\n\n端口号：21\n\n服务器名称和 IP：上传或用来下载的服务器地址\n\nRemote File：远程 FTP 服务器文件路径（要加文件名）\n\nLocal File：本地文件路径（要加文件名）\n\nLocal File Contents：本地文件内容\n\n用户名：如果是匿名用户登录，也要填入“anonymous”\n\n密码：\n\n\n\n\n\n\n\n\n\n\n场景设置#\n\n分布式运行#\n\n控制机：又称调度机，参与脚本的运行，主要是管理远程负载机，指挥远程负载机运行的任务，收集测试结果；\n\n负载机：又称执行机，运行脚本的机子；\n\n（1）分布式执行原理\n\n①选择一台机器作为调度机，其他机器作为执行机\n\n②执行时，master 会把脚本发送给每台 slave，slave 拿到脚本后执行，slave 执行时启动 jmeter-server.bat 即可（无需启动\nJmeter 软件）\n\n③执行完后 slave 会把结果回传给 master\n\n（2）分布式配置方式\n\n①调度机（master）配置\n\n仅需将自己的 IP 添加到配置文件里面就行\n\n * 找到J meter.properties\n\n * 在 remote_hosts 后面加上负载机的 IP 地址\n\n②执行机（slave）配置\n\n * 找到 Jmeter.properties\n\n * 修改配置项（默认端口：1099）\n   \n   \n\n * 启动 Jmeter-server.bat\n\n\n\n③注意事项\n\n * 软件版本要一致\n\n * 三方配置文件要配置在负载机上，路径要一致\n\n * 注册等特殊情况，分发给负载机的参数化文件，参数不能相同。\n\nd.脚本不要放在桌面上\n\n④如果连接失败需检查：\n\n * 是否关闭了防火墙\n\n * 是否禁用了所有的虚拟网卡\n\n * 参数化的 CSV 文件要复制到负载机上\n\n * 三方的jar包要复制到负载机上\n\n浪涌测试#\n\n（1）概述\n\n定义：浪涌测试是持续进行高强度和普通强度的交叉压力测试。\n\n目的：主要是查看资源的释放情况。\n\n（2）操作步骤\n\n①在测试计划，右键添加 threads→Ultimate Thread Group\n\n②添加以下测试策略数据：\n\n * Start Thread Count：开始线程数量\n * Initial Ddlay，sec：线程加载多长时间开始运行\n * Startup Time，sec：线程加载多长时间\n * Hold Load For，sec：线程持续运行多长时间\n * Shutdown Time：线程停止时长，在多长时间内停止下来。\n\n\nIP欺骗#\n\n 1. 对电脑添加多个可用 IP，并将IP地址保存在一个 txt 或 csv 文档中\n 2. 添加配置元件 CSV Data Set Config 将文档中 IP 参数化\n 3. 在请求中选择 [Advanced]，implementation 选择 HttpClient4，Source address 选择\n    IP/Hostname，并输入 IP 参数（${ip}）\n\n\n\n\n\n\n\n\n\n连不上网，需要把“首选 DNS 服务器”填上 192.168.1.1，\n\n\n\n将网络禁用后重启；\n\n\n\n\n曲线拐点模型分析#\n\n1.定义\n\n性能测试曲线模型是一条随着测试时间不断变化的曲线，与服务器资源，用户数或其他的性能指标密切相关的曲线。\n\n2.解释\n\nx轴代表并发用户数，Y轴代表资源利用率、吞吐量、响应时间。\n\n从左往右依次为轻负载区、重负载区、拐点区\n\n（1）响应时间：轻负载区变化不大，重负载区增长，拐点区倾斜率增大。\n\n（2）吞吐量：轻负载区增加，重压力区逐步平稳，拐点区急剧下降。\n\n","routePath":"/自动化技术/性能自动化/JMeter—10小时入门版","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"Jmeter 组件","id":"jmeter-组件","depth":2,"charIndex":188},{"text":"线程组","id":"线程组","depth":3,"charIndex":201},{"text":"取样器（sampler）","id":"取样器sampler","depth":3,"charIndex":343},{"text":"逻辑控制器（logic controller）","id":"逻辑控制器logic-controller","depth":3,"charIndex":396},{"text":"（1）循环控制器","id":"1循环控制器","depth":4,"charIndex":509},{"text":"（2）ForEach控制器","id":"2foreach控制器","depth":4,"charIndex":583},{"text":"（3）If 控制器","id":"3if-控制器","depth":4,"charIndex":627},{"text":"（4）switch 控制器（开关）","id":"4switch-控制器开关","depth":4,"charIndex":677},{"text":"（5）吞吐量控制器","id":"5吞吐量控制器","depth":4,"charIndex":796},{"text":"定时器","id":"定时器","depth":3,"charIndex":989},{"text":"配置元件","id":"配置元件","depth":3,"charIndex":1223},{"text":"元件的作用域","id":"元件的作用域","depth":2,"charIndex":1440},{"text":"脚本开发","id":"脚本开发","depth":2,"charIndex":1718},{"text":"脚本录制","id":"脚本录制","depth":3,"charIndex":1726},{"text":"脚本生成","id":"脚本生成","depth":3,"charIndex":1742},{"text":"webservice接口测试","id":"webservice接口测试","depth":3,"charIndex":2088},{"text":"JDBC请求","id":"jdbc请求","depth":3,"charIndex":2150},{"text":"FTP请求","id":"ftp请求","depth":3,"charIndex":2619},{"text":"场景设置","id":"场景设置","depth":3,"charIndex":2827},{"text":"分布式运行","id":"分布式运行","depth":4,"charIndex":2834},{"text":"浪涌测试","id":"浪涌测试","depth":4,"charIndex":3452},{"text":"IP欺骗","id":"ip欺骗","depth":3,"charIndex":3742},{"text":"曲线拐点模型分析","id":"曲线拐点模型分析","depth":3,"charIndex":4000}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":115,"title":"Locust—2小时入门版","content":"#\n\n\n一、简介#\n\n性能测试通常指的是 API 性能测试，使用 JMeter\n做的同学会多一点，因为它开源免费，提供了一些插件，只需要在图形化的界面录入一些数据就能很方便的进行接口测试、性能测试，相比于商用软件\nLoadRunner更适合普通玩家，所以 JMeter 群众基础更好。\n\nlocust 是近几年才流行起来的，主要是因为需要编码，所以好多同学有点抵触，但其功能完全不输 JMeter ；\n\n\n二、安装#\n\n\n\n检查是否安装成功：\n\n\n\n\n三、用例模板#\n\n\n\n执行时在终端输入：\n\n\n\n\n四、简单测试#\n\n\n1、mock接口#\n\n咱们先使用 FastAPI 简单 Mock 一个接口：\n\n\n\n\n2、测试用例#\n\n\n\n\n五、运行#\n\n\n网页在线运行#\n\n\n\n终端会提示一个链接，使劲戳他：\n\n\n\n\n\n第1个\"Number of users\" 总共将运行的用户数；\n\n第2个 \"Spawn rate\" 每秒加载的用户数；\n\n第3个 \"Host\"，被测接口的域名；咱们 Mock 的接口地址是：http://10.8.13.224:5000/items?name=mikigo\n\n\n\n点击【Start swarming】开始测试：\n\n\n\n这玩意儿是一直跑的，不会自己停下来，要停止测试，需要点击右上角【STOP】；\n\n\n命令行运行#\n\n常用的参数\n\n\n\n终端会以表格的形式刷新数据，在当前目录会生成一些 csv 的报告；\n\n\n分布式运行#\n\n主控机器\n\n\n\n助攻机器\n\n\n\n助攻机器可以有多个；\n\n主控机器终端输入类似这样：\n\n\n\n就说明呼应上了；\n\n分布式运行同样支持网页运行和命令行运行；","routePath":"/自动化技术/性能自动化/Locust—2小时入门版","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":202},{"text":"三、用例模板","id":"三用例模板","depth":2,"charIndex":225},{"text":"四、简单测试","id":"四简单测试","depth":2,"charIndex":250},{"text":"1、mock接口","id":"1mock接口","depth":3,"charIndex":260},{"text":"2、测试用例","id":"2测试用例","depth":3,"charIndex":303},{"text":"五、运行","id":"五运行","depth":2,"charIndex":315},{"text":"网页在线运行","id":"网页在线运行","depth":3,"charIndex":323},{"text":"命令行运行","id":"命令行运行","depth":3,"charIndex":563},{"text":"分布式运行","id":"分布式运行","depth":3,"charIndex":616}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":116,"title":"HttpRunner—2小时入门版","content":"#\n\n\n一、简介#\n\n接口测试很多同学用 Postman、Jmeter 来做，用起来也挺简单的，但是接口用例多了之后就发现不好管理维护，要落地到公司级 CI 项目就有点难搞了；\n\n稍微有点技术能力的同学更愿意直接用 requests 来做接口自动化，但是大多用 requests\n来做的接口自动化项目，在工程化方面都做得不太好，与其说是接口自动化项目，不如说是接口脚本的集中存放，没有体系化的框架结构设计，因此在大型 CI\n项目中落地也显得不太够用，维护人员除了忙于接口脚本的维护，还要投入大量时间做新功能和修复代码中的 Bug。\n\n想要轻松快速的落地接口自动化，又不想自己去折腾，我个人还是推荐 HttpRunner，只需要写写配置文件就把活干完了；\n\n\n二、安装#\n\n系统环境：deepin / UOS\n\n\n\n注意，使用 sudo 安装，不然命令行工具无法写入系统环境变量。\n\n装完之后会有一些版本、命令行参数的输出，说明安装成功。\n\n\n三、创建项目#\n\n\n\n这里会使用 venv 创建一个虚拟，有可能报错需要安装 python3-venv；\n\n不要慌，我们来修复一下环境：\n\n\n\n如果不出意外，环境就安装好了；\n\n\n四、目录结构#\n\n\n\ntestcases\n\n这里面用例是 yaml 或 json 文件，用 yaml 文件写接口自动化的用例也是常规操作，因为接口几乎都是以字典（或 json）的形式提供参数，而 yaml\n文件读出来刚好就是，所以大家就喜欢用这种格式。\n\n前面我说这个框架简单就是因为把接口的信息就直接在 yaml 文件里面一配置，活就干完了，根本都不需要写代码；\n\n对新手来说简直了，下面介绍一下 yaml 文件的字段：\n\n\n\n * config：测试用例的公共配置部分，包括用例名称、base_url、参数化数据源、是否开启 SSL 校验等，举例：\n   \n   \n\n * teststeps：有序步骤的集合；\n   \n   测试步骤类型        含义\n   request       用于发起 HTTP 请求的步骤类型\n   api           用于引用 API 的步骤类型\n   testcase      用于引用其他测试用例的步骤类型\n   transaction   用于定义一个事务\n   rendezvous    集合点\n   think_time    思考时间\n   websocket     用于发起 WebSocket 请求的步骤类型\n   \n   除了基本的测试步骤之外，部分测试步骤还可以进行增强；\n   \n   增强操作类型           含义     适用的测试步骤\n   variables        局部变量   通用\n   setup_hooks      前置函数   request/api/websocket\n   teardown_hooks   后置函数   request/api/websocket\n   extract          参数提取   request/api/websocket\n   validate         结果校验   request/api/websocket\n   export           导出变量   testcase\n   \n   举例：\n   \n   \n\n特殊值的规则：\n\n * 变量引用：约定通过 ${} 或 $ 的形式来引用变量，例如 $foo1 或 ${foo1}\n\n * 函数调用：约定通过 ${} 的形式来调用插件函数，例如 ${sum_two(1, 2)} ；\n   \n   有同学要问了，yaml 文件里面写 ${sum_two(1, 2)}，从哪里来的；\n   \n   其实，sum_two 在debugtalk.py 里面定义;\n   \n   \n\n\n五、执行用例#\n\n\n\n执行完成之后，在 result 目录下生成 html 测试报告。\n\n\n六、实例#\n\n\n1、mock接口#\n\n咱们先使用 FastAPI 简单 Mock 一个接口：\n\n\n\n看看接口文档，非常简单的一个接口\n\n\n\n好，那咱们回到httprunner里面来写用例了；\n\n\n2、写接口用例#\n\n用例也非常简单：\n\n\n\n\n3、执行用例#\n\n使用hrp命令执行\n\n\n\nrun 是使用 go 驱动执行；\n\n如果你习惯使用 pytest：\n\n\n\n后面你要生成什么报告，加什么参数就完全按照 pytest 的规范来就好，不过 pytest 那一套咱们已经熟得不能再熟了，没啥意思，就用 go 驱动吧。\n\n跑完之后在 results 目录下生成一个 html 文件，打开它：\n\n\n\n\n七、debugtalk.py底层实现原理#\n\n前面讲到可以在 debugtalk.py （下面就用“它”指代）里面定义一些变量或函数，然后在用例里面通过 $var 、${func()} 的方式调用；\n\n这章咱们就讲讲，为啥在 debugtalk.py 里面定义的代码，能在 yaml 文件里面写字符串的方式调用；\n\n\n1、获取路径#\n\n在 loader.py 里面：\n\n\n\n很明显返回了两个路径：ebugtalk_path, project_root_directory\n\n\n2、原始数据#\n\n\n\n返回的 project_meta 是 pydantic 的模型对象，你可以理解成就是一个字典；\n\n在这个函数里面主要逻辑是通过一个函数获取它里面的函数对象：\n\n\n\n这里面主要用到了 vars 函数来获取，感兴趣的同学可以去查一下这个用法；\n\n到这里也就是说获取到了它里面的 函数名 及 函数对象 ，有了函数对象在合适的位置调用就行了；\n\n咱们接着往后看；\n\n\n3、参数解构#\n\n在 parser.py 中进行参数结构：\n\n\n\n经过一系列的数据处理，把参数列表返回出来\n\n\n4、函数调用#\n\n\n\n在这个函数里面主要代码：\n\n\n\nfunc 为函数对象，通过 parse_data 函数获取到参数 parsed_args 和 parsed_kwargs，通过\nfunc(*parsed_args, **parsed_kwargs) 调用函数并获取到值；\n\n最后经过一顿组装返回最终的字符串；\n\n\n5、变量获取#\n\n变量获取相对简单，不想函数调用，要考虑函数对象及参数；\n\n\n\n也是通过 parse_data 函数来获取；\n\n\n6、驱动入口#\n\n\n\n在入口文件 runner.py 里面把上面所有的逻辑串起来；\n\n在 test_start 里面调用私有方法 __parse_config，在 __parse_config 里面挨个处理前面的逻辑；\n\n在 step 里面通过：\n\n\n\n进行驱动执行；","routePath":"/自动化技术/接口自动化/HttpRunner-2小时入门版","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":328},{"text":"三、创建项目","id":"三创建项目","depth":2,"charIndex":420},{"text":"四、目录结构","id":"四目录结构","depth":2,"charIndex":510},{"text":"五、执行用例","id":"五执行用例","depth":2,"charIndex":1612},{"text":"六、实例","id":"六实例","depth":2,"charIndex":1658},{"text":"1、mock接口","id":"1mock接口","depth":3,"charIndex":1666},{"text":"2、写接口用例","id":"2写接口用例","depth":3,"charIndex":1756},{"text":"3、执行用例","id":"3执行用例","depth":3,"charIndex":1779},{"text":"七、debugtalk.py底层实现原理","id":"七debugtalkpy底层实现原理","depth":2,"charIndex":1955},{"text":"1、获取路径","id":"1获取路径","depth":3,"charIndex":2114},{"text":"2、原始数据","id":"2原始数据","depth":3,"charIndex":2193},{"text":"3、参数解构","id":"3参数解构","depth":3,"charIndex":2384},{"text":"4、函数调用","id":"4函数调用","depth":3,"charIndex":2440},{"text":"5、变量获取","id":"5变量获取","depth":3,"charIndex":2599},{"text":"6、驱动入口","id":"6驱动入口","depth":3,"charIndex":2664}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":117,"title":"PageObjects（PO）","content":"#\n\n\nPO是什么#\n\nPageObjects 又称 PO 设计模式，以下简称 PO，通常翻译过来叫页面对象设计模式，是一种 UI 自动化测试领域流行的设计模式。\n\n在圈内流行起来主要源于 Web UI 自动化测试领域的明星级项目 Selenium，在 Selenium 官方文档 最佳实践 - 指南 中描述了 PO\n设计模式；\n\n但实际早在 2013 年国外有个哥们儿 Martin Fowler 在他的博客里就提到了 PO 设计模式，Selenium 官方 2015\n年对其做了进一步诠释；\n\n有了 Selenium 的官方背书，这种设计模式迅速在圈内流行起来，几乎是每个自动化测试工程师必备技能。\n\n\nPO设计思想#\n\n其设计思想简单讲就是，将一个页面中元素操作方法封装为一个页面类，测试用例中涉及到与这些元素交互时，调用页面类里面的方法即可。\n\n这样做可以减少重复代码，并且当 UI 界面改变时，只需要修改一个地方。\n\n\n\n\nPO实现#\n\n下面以在百度搜索一个东西举例，写一个线性脚本：\n\n\n\n脚本看起来很好理解，不用过多解释对吧。\n\n那现在你可以想象一下，如果所有用例都这样写，是不是会存在一个问题，就是当页面中某个元素发生改变时，你需要到你所有的脚本中去修改。\n\n这茫茫多的脚本，得改到什么时候。。\n\n所以这就说到 PageObjects 的理念，需要将每一步操作封装成一个方法，这些方法统一放到一个页面类（Page Class）里面。\n\n首先我们写一个页面基类 BasePage 来处理通用页面行为，如打开页面和等待页面加载完成：\n\n\n\n然后，为百度搜索页面创建一个专门的类 BaiduSearchPage：\n\n\n\n最后，创建一个主类 SearchScript 来执行搜索并处理结果：\n\n\n\n你看，经过一顿操作，方法封装好之后再写脚本就方便许多了：\n\n\n\n用例里面只需要调用方法即可，而方法是可以复用的，如果某个元素发生改变，你只需要修改方法里面这一个地方就可以；\n\n而且你有没有发现，封装之后，用例脚本看起来更容易理解，可读性更好。\n\n\n总结#\n\n\n核心理念#\n\n一个页面一个类，一个元素一个方法。\n\n\n使用PO的好处#\n\n * 提高脚本可维护性，某个元素改变只需要修改一个地方；\n * 提高脚本可读性，用例层和方法层各司其职，用例层主要关注用例逻辑（业务场景），方法层主要关注元素操作。","routePath":"/自动化技术/自动化思想理念/PageObjects","lang":"","toc":[{"text":"PO是什么","id":"po是什么","depth":2,"charIndex":3},{"text":"PO设计思想","id":"po设计思想","depth":2,"charIndex":303},{"text":"PO实现","id":"po实现","depth":2,"charIndex":416},{"text":"总结","id":"总结","depth":2,"charIndex":876},{"text":"核心理念","id":"核心理念","depth":3,"charIndex":882},{"text":"使用PO的好处","id":"使用po的好处","depth":3,"charIndex":909}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":118,"title":"RPA测试技术","content":"#\n\n\n相关术语#\n\n术语         全称   描述\nSelenium   /    一个开源的 Web UI 自动化测试工具，提供了基础的操作 Web 页面元素的方法。\nQTP        /    一个商用的 UI 自动化测试工具，支持 Web、桌面自动化测试。\nRequests   /    一个基于 Python 实现的网络接口请求的工具。\nPostman    /    一款流程的接口调试工具，特点就是使用简单，测试人员都可以使用它进行接口调试或测试。\nYouQu      /    统信自研的自动化测试基础框架，使用简单，功能强大。\n\n\nRPA是什么#\n\nRPA（Robotic Process\nAutomation，机器人流程自动化）是一种技术理念，其核心是将一些人工重复性的任务使用自动化的手段来执行。可以提高企业的运行效率，降低人工投入。\n\nRPA 是一个很泛的概念，一句话讲清楚就是：把一切能手工执行的任务交给自动化来执行。至于具体使用哪种自动化技术，我只能说不确定，因为这是需要 因需制宜 的。\n\n在 RPA 这个概念提出来之前（大概是90年代），财务人员能使用 Excel 进行财务计算，就已经是在践行 RPA\n了，毕竟以前都是用算盘在做，稍微先进点的用计算器，不仅需要投入大量的人力，而且还容易出错，Excel\n里面的公式能自动处理大量的数据，工作效率是一个飞跃，再到后来出现财务管理软件出现，又在 Excel 的基础上进一步提高的自动化程度。\n\n在不同的时期，RPA 技术用到的具体技术或工具是不同的，在不同的行业也是这样，文案工作者从最开始一个本子一支笔，再到用 Word，再到用 GPT 自动生成。\n\n所以说，RPA 是一种技术理念，一种将一切行为自动化的理念，凡是可以替代人工的技术或工具，都可以称之为 RPA 技术。\n\n\nRPA测试的由来#\n\n前面咱们理清了 RPA 核心就是自动化，那 RPA 测试即自动化测试是 RPA 的一个子集，这节我来简单的介绍下自动化测试的由来；\n\n软件测试行业在刚开始的时候，所有的测试人员都是手工测试，互联网行业飞速发展，快速迭代发布，主打的就是一个快，现实的情况是每次迭代测试时间不够、人力不够，维护成本\n太高。\n\n有机智的测试小伙伴就想，每次迭代都是那些活，这些事情能不能自动化来执行，我在旁边喝咖啡就行了，于是直接上网查资料一看，还真有技术能做这些活。\n\n要想替代人工测试，最直接最容易想到的就是替代人工做点击输入类的动作，这类称为 UI 自动化测试；UI\n自动化测试是最接近于真实用户的自动化测试类型，早期的自动化测试工具如：QTP、Selenium 等很快流行起来。\n\n但自动化测试项目稍微一落地运行就会发现，太难维护了，前端功能界面一天变三回，测试工程师维护用例脚本的投入太大。\n\n既然是前后端分离的系统，只管后端接口的输入输出正常岂不方便许多，又上网查资料找到一个 Requests\n的库能做接口请求，于是开始搞接口自动化测试了；发现接口自动化测试投入产出比高，效果很好，靠着口口相传，测试圈内刮起了一股浩浩荡荡的接口自动化测试风潮。\n\n后来，在接口自动化测试基础上又衍生出了性能自动化，因为高并发的场景如果靠人工来测试几乎是不可能的，而利用多线程并发做接口请求可以轻松做到。\n\n测试全面接入 RPA 之后优势很明显，提高了测试效率、减少了人力投入、以及频繁的人工操作可能导致的错误。\n\n但 RPA 测试也不尽完美，也存在一些局限性，比如 RPA 测试不能完全替代人工测试，它主要做一些重复性的任务，还有就是面对复杂流程或频繁变动时对 RPA\n测试工具可维护性、灵活性提出考验。\n\n\nRPA测试技术#\n\n自动化测试始终是贯穿于软件开发过程周期的，在不同的阶段介入，做不同的自动化测试：\n\n\n开发阶段#\n\n这个阶段开发还在疯狂的新增和修改代码，适合做的只有单元测试自动化。\n\n圈内有个很有名的黑话叫测试驱动开发（TDD，Test Driven\nDevelopment），说的是在编写某个功能代码之前要求先编写测试代码，这里的测试代码实际指的是单元测试代码。据观察，测试同学写应用单元测试代码的情况，还比较\n少的，这里面主要有学习、沟通成本等问题。\n\n单元测试往往是由开发同学自己写，在国内这个情况是比较普遍的，因此这里就不过多描述。\n\n\n集成交付阶段#\n\n到这个阶段说明开发至少交付了一个版本，但是又还没有稳定下来，各功能、界面等还有可能会改动，因此这个阶段适合做接口自动化。\n\n无论是从业务上还是技术上讲，接口自动化都属于是比较容易开展起来的自动化类型：\n\n * 业务上，互联网行业都在流行微服务架构，服务端接口小修小补很正常，无非是些参数的增删改，整个接口大改的情况少，毕竟前期经过了多轮次评审，因此后端服务接口是相\n   对稳定的。\n\n * 技术上，自动化测试只要有一个能做接口请求的工具，就可以开展起来，这类工具以 Requests 、Postman 为代表，且不论工程化等方面，使用\n   unittest + requests 能做接口请求，能组织用例跑起来，就能快速的把接口自动化开展起来。\n\n因此，业务接口稳定，技术门槛低，接口自动化很自然的就能很顺利落地。\n\n最流行的接口自动化组合套装#\n\nPytest + Requests + Allure\n\n * Pytest 用于驱动用例批量执行；如果对测试用例过程管控没有太多需求，使用 unittest 足矣。\n * Requests 用于做接口请求。\n * Allure 用于生成测试报告；如果对测试报告UI效果要求不高，不用 Allure 也行，Pytest 或 unittest\n   驱动用例跑完之后终端也会有简易的结果展示。\n\n此技术路线是比较通用的，当然不同的人使用这些工具做出来的效果也是不同的，需要有一些框架设计，这里不做赘述；\n\n一条龙的工具#\n\nHttpRunner\n\nHttpRunner 实际上也是基于 用例驱动工具 + 接口请求工具 + 测试报告工具\n进行封装，以框架级服务提供功能，让使用者能专注于接口用例的维护，而不用关心其他的。\n\n--------------------------------------------------------------------------------\n\n此外，性能自动化测试也开始在这一阶段介入，常用的性能测试工具：JMeter、Locust。\n\n\n验收维护阶段#\n\n此阶段系统各方面功能已经趋于稳定，适合做 UI 自动化。\n\nUI 自动化是从功能的层面模拟手工操作进行自动化测试，核心内容是 元素定位 和 元素操作 ；看起来很简单对吧，但实际上 UI\n自动化是所有自动化测试类型中最难的。\n\n为什么这么说？\n\nUI 自动化是从用户视角进行自动化测试，测试的对象是客户端，而客户端又分布在不同的平台设备上。\n\n\n\nWeb#\n\nWeb UI 自动化就是基于浏览器的 UI 自动化测试；不同的浏览器，自动化测试用到的底层驱动是不同的，但由于一些自动化工具封装了统一的 API 接口（如\nPlaywright），在编码上并没有特别大的区别。\n\n难点在于网速、浏览器、脚本的健壮性和测试环境等因素都会导致 UI 自动化测试的失败，产品迭代的过程中维护性差，维护成本高。\n\n常用到的工具：Selenium、Playwright、Cypress、Puppeteer、TestCafe。\n\nApp#\n\nApp UI 自动化可能涉及到多平台设备，如\nAndroid、IOS、Windows、Linux，不同的平台设备上用到的自动化测试工具是不同的，下面简单的列举一些：\n\n * Android 自动化测试：Appium、UIAutomator、UIAutomator2；\n * IOS 自动化测试：XCUITest、Appium、facebook-wda；\n * Windows 自动化测试：UIautomation、WinAppDriver；\n * Linux 自动化测试：Dogtail、LDTP；\n\n可以看到，App UI 自动化涉及的工具多，学习门槛高，且相比于 Web UI 自动化维护难度翻倍；\n\n\n统信RPA测试应用#\n\n\n自动化测试框架—YouQu#\n\n统信的主要产品是基于 Linux 的操作系统。\n\n首先，操作系统提供了一些 DBus 接口、Gsetting 接口、命令行接口等，能做接口自动化测试；然后，操作系统桌面 App 也可以做 UI 自动化 和\n性能自动化。\n\n列举一些主要用到的技术：\n\n\n\nYouQu 自动化测试框架的定位是一个全功能的自动化测试框架，能支持公司所有类型的自动化测试类型。\n\n\n\nYouQu\n在整合上述底层技术基础上，进行了工程化的框架设计，并对底层的工具进行了二次开发，使得上层测试用例能非常方便轻松的进行调用，大幅减少了自动化测试用例编写的难度，并\n且我们还针对 UI 自动化维护性差的问题，做了很多的功能开发及优化，比如：自研了基于 UI\n相对位移的元素定位方案、用例标签化管理、自动生成日志系统、用例失败录屏、全流程超时管控等等。\n\n详细情况请查看：http://youqu.uniontech.com/ ；\n\nYouQu 目前累计已经支撑公司 40+ 自动化测试项目落地运行，累计下载使用 13k+ 次。\n\n\nCI/CD#\n\n针对每日构建的新镜像，CI/CD 每日会使用 Jenkins 流水线分别对新镜像进行自动化测试，保障每日镜像系统的质量。\n\n\n\n\n测试单驱动自动化测试#\n\n针对子项目测试单，使用流水线配合相关爬虫技术，实现项目经理提测后快速进行自动化测试；\n\n\n\n目前冒烟测试单能实现零人工投入，新需求测试单或回归测试单也能减少 30% 的人工投入。\n\n\n性能自动化测试#\n\n针对 App 启动类场景的性能测试，我们自研了基于视频流 + 设备分离技术方案的性能自动化测试框架 AIPerf，性能测试的效率提高超 100 倍。\n\n\n\n\nRPA测试+AI#\n\nRPA 测试与 AI 的结合主要从前面提到的几个方面的痛点（学习成本高、维护成本高、兼容性问题）入手。\n\n结合当前深度学习领域的发展，RPA 测试可以从以下方面进行结合：\n\n\nLLM#\n\nLLM（大语言模型，Large Language\nModel）要解决的问题是降低测试工程师编写脚本的难度，只需要描述一个业务场景，就能自动生成并执行自动化测试用例。\n\n目前类似 ChatGPT 这样的通用大语言模型已经能做到这种效果，像文件管理器这种用例场景比较复杂的自动化用例，一个用例脚本写几十上百行属于正常，这还是在基于\nYouQu 框架封装程度比较高的情况下能做到如此。\n\n结合大语言模型，能实现只需要使用自然语言描述一个具体的业务场景，它就能对自然语言进行识别，进而生成对应的自动化用例操作步骤。\n\n比如描述一个用例场景：在桌面新建一个 Word 文档，然后把它复制到下载目录下。\n\n模型识别之后就可以解析为用例步骤：\n\n\n\n在此基础上，每个用例步骤可以继续理解生成对应要执行的方法代码。\n\n测试工程师维护的是自然语言的脚本，相比于传统的用例脚本，维护难度将大幅减低。\n\n\nOCR#\n\nOCR （光学字符识别，Optical Character\nRecognition）通俗讲就是识别文字，在各行各业已经有比较成熟的运用，比如：车牌识别、证件识别、OCR扫描等。\n\n目前统信 RPA 测试已经运用了基于深度学习的 PaddleOCR，PaddleOCR 是百度飞桨团队开源的一个 OCR 解决方案，在中文识别领域首屈一指。\n\nYouQu 框架将 PaddleOCR 进行功能整合，可用于文本类元素定位和断言，我们使用 RPC 技术进行封装部署，并独立发布到\nPyPI，经过两年多的落地运用，识别准确度超过 99.9%。\n\n《YouQu OCR 应用详细文档说明》\n\n\n目标检测#\n\n目标检测（Object Detection）通俗讲就是在图像中识别某个特定的元素，在人脸识别、车辆识别等方面有大量运用。\n\n流行的目标检测模型如：YOLO 系列、R-CNN 系列、RetinaNet 等。\n\n流行的目标检测框架如：MMDetection、Detectron2、SimpleDet 等。\n\n其中，MMDetection 来自商汤科技 OpenMMLab 团队，在国内成名已久，MMDetection 也是 OpenMMLab\n的明星开源项目，几乎支持了所有的模型，有丰富的开发文档能让使用者快速上手。\n\nRPA\n测试结合深度学习目标检测的目的是从计算机视觉的角度识别某些元素，并且能达到两个效果：一是在环境改变（主题、背景、颜色、分辨率等）时能准确的识别出来；二是联想找图\n，就是能自动识别出类似的图标。\n\n主要的难点有两方面：\n\n一是，需要大量的人工标注训练素材，业内有句调侃的话：有多少人工就有多少智能，几百上千张图片人工标注很简单，但 10W、100W\n。。。的图片就很不简单了，需要投入大量的人力。\n\n二是，目标检测所训练的素材是有限的，我们不可能穷举出各种环境下、各种各样的元素图标，因为使用环境和 UI\n界面是带灵感和创造性的，是不可穷举的，这就是为什么识别率不可能达到 100%。\n\n因此，如何以有限的人力、有限的训练素材，实现用户场景下的稳定识别，是需要我们解决的问题，也是努力的方向。\n\n\n总结#\n\nRPA 是一种自动化的技术理念，RPA 测试的核心是将过去手工测试的工作使用自动化的手段来执行，各种 RPA 测试技术也随着行业技术的发展层出不穷，日新月异。\n\n统信 RPA 测试从很早之前就被公司领导提出并落地运行，经过多年的技术发展演进，无论是在 RPA 测试框架体系的开发、维护、演进，还是在 RPA\n测试流程落地运用，都已经达到了一定的成熟度；\n\n除了功能测试转自动化测试的业务场景运用外，还有 DBus、 Gsetting、命令行等接口测试，App\n性能自动化方面我们也自研了智能化性能测试框架；我们不仅在践行 RPA 测试的理念，还在对 RPA 测试所用到的技术做持续的探索、优化、创新，如 YouQu\n自动化测试框架的插件化设计、统一名称空间导入、脚手架功能等等都是我们为提高脚本编写效率、提高可维护性等做的创新实践。\n\n但统信 RPA 测试仍然存在许多问题和挑战，如：学习成本高、维护成本高、兼容性问题等问题，目前我们也在积极的和外部团队（清华）展开 AI\n方面的技术合作，未来我们将努力尝试通过 RPA 测试 + AI 的方式持续优化现有的 RPA\n测试框架技术体系，以尽量为用户提供更简单的端到端解决方案，持续为公司产品质量提供保障。\n\n\n参考文献#\n\n《Fact vs. Fiction: Business Users Can Easily Build Software Robots Using RPA\nTools》\n\n《What is robotic process automation (RPA)》\n\n《RPA百年发展简史》","routePath":"/自动化技术/自动化思想理念/RPA测试技术","lang":"","toc":[{"text":"相关术语","id":"相关术语","depth":2,"charIndex":3},{"text":"RPA是什么","id":"rpa是什么","depth":2,"charIndex":281},{"text":"RPA测试的由来","id":"rpa测试的由来","depth":2,"charIndex":785},{"text":"RPA测试技术","id":"rpa测试技术-1","depth":2,"charIndex":-1},{"text":"开发阶段","id":"开发阶段","depth":3,"charIndex":1592},{"text":"集成交付阶段","id":"集成交付阶段","depth":3,"charIndex":1815},{"text":"最流行的接口自动化组合套装","id":"最流行的接口自动化组合套装","depth":4,"charIndex":2185},{"text":"一条龙的工具","id":"一条龙的工具","depth":4,"charIndex":2452},{"text":"验收维护阶段","id":"验收维护阶段","depth":3,"charIndex":2690},{"text":"Web","id":"web","depth":4,"charIndex":2872},{"text":"App","id":"app","depth":4,"charIndex":3103},{"text":"统信RPA测试应用","id":"统信rpa测试应用","depth":2,"charIndex":3413},{"text":"自动化测试框架—YouQu","id":"自动化测试框架youqu","depth":3,"charIndex":3426},{"text":"CI/CD","id":"cicd","depth":3,"charIndex":3892},{"text":"测试单驱动自动化测试","id":"测试单驱动自动化测试","depth":3,"charIndex":3965},{"text":"性能自动化测试","id":"性能自动化测试","depth":3,"charIndex":4070},{"text":"RPA测试+AI","id":"rpa测试ai","depth":2,"charIndex":4159},{"text":"LLM","id":"llm","depth":3,"charIndex":4258},{"text":"OCR","id":"ocr","depth":3,"charIndex":4656},{"text":"目标检测","id":"目标检测","depth":3,"charIndex":4953},{"text":"总结","id":"总结","depth":2,"charIndex":5571},{"text":"参考文献","id":"参考文献","depth":2,"charIndex":6106}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":119,"title":"Pytest 从入门到起飞","content":"#\n\n\n一、简介#\n\nPytest 是一个流行的基于 Python 的自动化测试框架，以其灵活性、可扩展性、易用性俘获了大批 Python 程序员的心。网上关于 pytest\n的教程不少，但是都是零散的知识点，几乎没有很全面的教程，当初学习它的时候就苦于没有全面的教程而不得不去研读它的官方文档，看完一遍官方文档之后感觉还有些没弄明白，\n到京东上买了一本《pytest测试实战(Brian.Okken)》，如获至宝，应该说是当时唯一的一个讲解 Pytest\n的书籍了，看完之后我有点失望，写得也太简单了，2天就看完了，还不如看官方文档呢，就这都能出书，我都能写书了，后面又回过头来看 Pytest 官方文档。\n\n大家知道官方文档确实是最全的，能够让你全方位的掌握，但是，就是因为太详细了，有些东西对于99.9%的使用者来说，其实没必要掌握。经过长期摸索，我将我们经常使用到\n的、核心的内容总结成这篇教程，希望能以一种轻松、简单、令人愉悦的方式，将这些内容讲清楚。\n\n也希望通过讲解各个模块的知识，潜移默化的让你理解 Pytest 的 Plugin 设计哲学。\n\n\n二、安装#\n\n\n\n只需要这样安装一下就行了，够简单易用吧。\n\n\n三、用例编写#\n\n\n1、函数式#\n\n\n\n这种是函数式的用例写法，就是直接在 py 文件里面定义函数，函数里面写测试用例。\n\n\n2、类式#\n\n\n\n这种写法是基于类的用例写法，在函数里面写测试用例即可。\n\n两种写法都是可以的，在执行的时候都能被 pytest 识别为用例。\n\n从工程的角度，我更推荐使用基于类的用例写法，因为函数式的写法不能使用类级别的 fixture，因为它没有类。基于类的用例写法给我们提供了更加灵活的\nfixture 的处理，让你在应对复杂测试场景的时候，游刃有余。\n\n\n四、fixture#\n\nfixture 翻译过来是\n“夹具”，简单讲就是用例执行前后要做的操作，我们称为前置（setup）和后置（teardown）操作。用例就像夹心饼干一样被夹在中间。\n\nPytest 灵活性很重要的一方面就是体现在它的\nfixture，那是相当的灵活。不仅支持多个级别，各个级别的写法还支持多样，还可以共享、默认调用、指定调用，很多骚操作，现在不知道没关系，看完这一章应该能有所收\n获。\n\n\n1、级别#\n\n总共有四个级别：函数级别（funciton）、类级别（class）、模块级别（module）、会话级别（session）\n\n这部分只需要理解概念，不需要纠结与具体的写法。\n\n * 函数级别（funciton）\n   \n   函数就是用例，函数级别的fixture就是在每个用例执行前后的操作，即： function_setup test_case\n   function_teardown 。\n\n * 类级别（class）\n   \n   类级别就是在每个用例类执行前后要执行的操作，注意，一个类只执行一次哦。\n   \n   * 如果一个类里面只有一个函数，类级别相对于函数级别，就是在函数级别前后执行，即：class_setup function_setup test_case\n     function_teardown class_teardown 。\n     \n     你看其实就是在前面函数级别的基础之上外面加了一层，很好理解是吧。\n   \n   * 如果一类里面有多个函数，执行的顺序是：class_setup function_setup test_case_001\n     function_teardown function_setup test_case_001 function_teardown\n     class_teardown 。\n     \n     你注意看区别，中间有多个用例函数，每个函数外都夹了一个函数级别的fixture，然后类级别fixture是放在最外层的。\n\n * 模块级别（module）\n   \n   理解了前面类级别的fixture之后，相信你已经能推理出来了，模块其实可以理解成一个 py 文件，在一个 py\n   文件里面可以写多个类，每个类里面可以写多个函数。一层夹一层的。\n\n * 会话级别（session）\n   \n   这个相对来讲有点抽象，其实就是你执行一次用例就是一次会话，当然一次会话里面可能只有一个用例，也可能包含多个用例模块、多个用例类、多个用例。\n\n\n2、不同的写法#\n\n这里骚操作就比较多了，看准了哈。\n\n2.1、XUnit 的写法#\n\n熟悉 unittest 框架的人都知道，unittest 里面 fixture 的写法是 setUp 和 tearDown，setUp_class 和\ntearDown_class，只有这一种写法，而且是固定的写法哈。\n\nPytest 是兼容 unittest 的，当然也支持这样写：\n\n\n\n注意是继承了 unittest.TestCase 的，Pytest 可以兼容运行的，基本操作哈。\n\n除此之外还有一些你没见过的 Xunit 写法：\n\n\n\n\n\n你看，setup 和 teardown 这种写法也是会被自动识别的。\n\n还有这种，看准了哈：\n\n\n\n\n\nsetup_method 和 teardown_method 也可以。\n\n这里还要讲一下 setup_method 和 setup_function 的区别，setup_function\n是在基于函数的用例写法时使用的，setup_method\n是基于类的用例写法使用的，我面试别人的时候喜欢问这两个的区别，如果知道这个的，基本对本部分内容是了解的。\n\n以上只是用例级别的，下面说下类级别的写法：\n\n\n\n\n\n直接写成 setup_class 就可以了，在 unitest 里面类级别的是需要加类方法装饰器 @classmethod 的，pytest\n里面可加可不加，看你喜欢。\n\n模块级别的就用 setup_module，会话级别的就用 setup_session，这都好理解，这里就不举例了。\n\n2.2、fixture 写法#\n\n前面 Xunit 的写法已经很灵活了，但是 Pytest 真正厉害的是它自己特有的 fixture 写法。\n\n\n\n这里有几点要注意：\n\n * fixture 必须要加@pytest.fixture() 装饰器；\n\n * scope 为 fixture 级别；\n\n * fixture 的函数名 do_something_before 可以自定义，但是不要和 Xunit 的函数名一样，不然就乱掉了。\n\n * yield 之前是前置，yield 之后是后置，这里实际上是利用了生成器的原理；\n\n * 函数名 do_something_before 需要显式的传入用例参数：\n   \n   \n   \n   或者使用 @pytest.mark.usefixtures() ，就像这样：\n   \n   \n   \n   不过这种写法我个人不建议哈，字符串的形式属于硬编码，不好维护。\n\n这里要好好理解一下哈，短短的几句话，其实包含了很多内容哦。这种写法没有一个严格的定式，更多是一种模式。\n\n\n3、共享#\n\nfixture 共享是 Pytest 的一大特点，也是它灵活性的重要体现。\n\n3.1、用例之间共享#\n\n我们经常遇到多个用例需要用到同一个 fixture ：\n\n\n\n\n\n你看，我们只定义了一个 fixture，然后将它的函数名 do_something_before 分别都传给了两个用例，这样它就对两个用例都生效了。\n\n那有同学要问了，我如果有很多的用例，每个用例都要传入参数，好麻烦嘞，有没有更妙的写法？\n\n当然有：\n\n\n\n@pytest.fixture 里面有个参数 autouse ，就是自动使用，默认是 False，我们传 True 就表示对当前作用域下的所有用例都生效。这个\n“作用域” 要看这个 fixture 做处的位置，比如例子中，fixture\n是在类里面，它就对这个类中的所有用例都生效，如果你把它放到模块里面，它对这个模块里的所有用例都生效。\n\nautouse 一定要慎用，处理不好的话会引起执行逻辑的混乱，就是你会发现有些用例莫名奇妙，不知道在执行什么，可能就是有其他没注意到的 fixture 生效了。\n\n3.2、用例类之间共享#\n\n前面的例子都是将 fixture 放在类里面，这样只能对这一个类里面的用例生效，要实现用例类之间共享，就不能写在某一个类的里面了：\n\n\n\n我们将 fixture 写在module 里面，这样就对文件里面的所有用例都生效。\n\n3.3、超级共享#\n\nconftest.py 相当于是 Pytest 的一个本地插件库，你可以在用例的目录结构中任意位置新建一个 conftest.py 文件，然后在里面写入\nfixture，这些 fixture 可以对这个 conftest.py\n文件对当前目录及子目录下的所有用例生效，所以我称之为“超级共享”，而且各个目录都可以有自己的 conftest.py。\n\n“超级共享” 不是官方术语，是我自创的哈。\n\n咱们来新建一个 conftest.py 文件：\n\n\n\n在 conftest.py 文件中写一个 fixture：\n\n\n\n用例：\n\n\n\n在根目录使用 pytest -s -v 执行一下：\n\n\n\n这样当前目录下哪怕有多个用例文件，里面有成千上万条用例，执行时都会加载这条fixture，你说是不是超级共享。\n\n\n4、顺序#\n\n前面讲“超级共享”提到，我们可以把 fixture 写在 conftest.py 文件里面，conftest.py\n文件对当前目录及子目录下的所有用例生效，而各个目录都可以有自己的 conftest.py，用例文件里面还可以写 fixture，那写了这么多\nfixture，它的执行顺序是怎样的，怎么去解除一些作用，这个问题非常重要，理不清楚的话，在实际项目中你会发现这条用例都在干嘛，它为什么执行这个。\n\n跟上思路哈。\n\n首先，从层级上来讲仍然是：会话级别（session）—> 模块级别（module）—> 类级别（class）—> 函数级别（funciton）这样的执行顺序。\n\n然后，相同层级的情况下，要看 fixture 的位置，简单讲就是：外层 fixture 先执行。\n\n我们以 function 级别的 fixture 举例，构造一个多层级的\nfixture，建议你在本地按照下面的描述自己建一个demo，不然可能需要你有比较强的结构化思维：\n\n\n\n最外层 conftest：\n\n\n\ncases_1 目录下 conftest：\n\n\n\ncases_1_1 目录下 conftest：\n\n\n\n用例里面：\n\n\n\n这样我们就在不同层级写了一些 function 级别的 fixture，执行一下就可以清楚的看到。\n\n\n\n从上到下，你仔细看之后，结论呼之欲出：外层先执行。\n\n外层 conftest 先于内层 conftest，内层 conftest 先于类外面的，类外面的先于类里面的。\n\n所以我们在写fixture的时候一定要特别注意，Pytest 给我们提供的很灵活很方便的fixture的各种写法，特别是加了 autouse=True\n之后，如果你搞不清楚fixture哪个先执行哪个后执行，那你最好就别用这些写法，老老实实用 Xunit 的写法，已经能满足多大部分项目需求了。\n\n注意，以上我们写的这些fixture的函数名都是不同的，如果是相同的函数名会出现什么情况呢？\n\n咱们把 do_something_out 改成 do_something_in ，两个 fixture 函数名都是\ndo_something_in，我们看看会发生什么。\n\n\n\n你看，类外面的 do_something_in 没有执行，说明相同函数名的 fixture，只会执行内层的。\n\n这点知识也非常重要哈，因为在实际项目中，我们经常会遇到有些用例我不想用某些外层的 fixture，于是我们可以在内层定义一个同名的\nfixture，里面写pass，相当于抵消掉了外层 fixture 的作用。\n\n\n五、断言#\n\n\n1、常规断言#\n\nPytest 本身并没有提供断言的方法，而是直接使用Python自带的 assert 语句进行断言。\n\n\n\nassert 后面直接写表达式就好了，so easy!\n\n\n2、自定义断言#\n\n使用 assert 断言很简单，但是抛的异常日志基本没什么参考意义，因为在断言失败的时候，只会提示你 assert\n后面的表达式不成立，这不是废话吗，肯定不成立才断言失败噻，问题是我的表达式可能是一些比较复杂的封装，这里面具体什么问题就不知道了。因此，使用自定义断言会比较好。\n\n从本质上讲，断言失败实际上都是捕获的 AssertionError（断言异常），所以我们只需要定义一个自定义异常类，然后抛一个 AssertionError\n就可以了。\n\n\n\n通过给 AssertionError 传入自定义的字符串，用例失败时，我们就可以看到明确的失败信息。\n\n\n六、命令行参数#\n\n使用 Pytest\n执行用例时，我们经常都是通过命令行来执行的，有同学要说了，我一般是通过编辑器里面直接就执行了；在实际项目中编写用例调试用例，使用编辑器执行用例没问题，但在 CI\n集成环境下，一般是需要用命令行的。\n\nPytest 要想玩得溜，命令行参数必须要熟悉，Pytest\n支持的参数很多，有自带的参数，插件提供的参数，还有我们自己定义的一些参数，下面就介绍在项目中常用的参数：\n\n\n1、-s#\n\n有时候你发现在用例里面使用 print 语句，但是执行的时候却没有打印，那多半是因为你没有加这个参数。等价于 --capture=no，用途就是捕获 print\n输出。如果你不知道 capture 参数也没关系，不重要。\n\n\n2、-v#\n\n详细展示终端输出。比详细更详细使用 -vv ，我们当然是希望输出信息越详细越好。\n\n\n3、-k#\n\n执行用例的时候非常有用，通过关键词来匹配用例，用例的关键词有很多，模块名、文件名、类名、函数名都是关键词，比如：\n\n\n\n表示执行所有包含 test_music 关键词的用例。\n\n-k 还有一点可能好多同学都不知道，它还支持逻辑表达式，比如：\n\n\n\n\n\n逻辑表达是支持 and/or/not 的逻辑组合。\n\n在批量支持用例时，我们通常是不需要执行全量用例的，学会精准的组装用例集对于自动化测试非常重要。\n\n\n4、-m#\n\n我们可以给用例打上标签（mark）：\n\n\n\n使用装饰器 @pytest.mark 点后面加标签名，就可以给用例打标签，标签名随意指定，甚至可以用中文。\n\n打完标签之后，批量执行用例时就可以通过标签来加载用例，用法和 -k 是一样的。\n\n\n\n\n5、--co#\n\n这个参数全称是 --collect-only，表示只收集用例，不执行。\n\n每周我需要给老板汇报目前所有用例多少条，咱总不可能在代码里面一条条去数吧，我通常会使用：\n\n\n\n直接就可以看到加载了多少条用例。\n\n另外，有时候批量修改了一些代码，可能引起一些错误，我们可以通过执行 pytest --co 来快速检测一下是否存在错误，因为 Pytest\n在加载用例的时候同时也会检测代码中存在的一些问题。这个也非常好用。\n\n\n6、maxfail#\n\n配置最大失败次数，如果一次执行出现了大量的失败，多半这次测试是无效的，通过配置这个参数，我们不用等到所有用例执行完才结束，尽早结束节约时间。\n\n\n\n这里的 int_number 就是最大的失败次数，你可以根据你的经验来指定一个数字。\n\n我的方案是先获取到本次要执行的总用例数 collected_cases_num，然后配置一个总数的比例，如\n0.5，表示只要失败次数达到了总数的一半，就可以直接结束测试。\n\n\n\n这样做的好处是，随着项目中用例数量的增加，我不需要去修改这个最大失败的数据，而是通过配置整体的失败比例，这样做更加合理，也更易于维护。\n\n\n7、reruns#\n\n失败重跑次数，在自动化测试过程中经常会有一些不确定性，网络问题、环境问题、量子力学、地球引力等等都有可能造成用例失败，特别是 UI\n自动化测试，这些情况经常发生，为了尽量排除环境问题造成的用例失败，采用失败后自动重跑是一个比较好的方案。\n\n\n\n表示失败后重跑2次，如果后面重跑用例成功了，最终的用例状态为 PASSED。\n\n这个参数需要安装三方插件：\n\n\n\n\n8、timeout#\n\n用例超时在 CI\n流程中非常重要，因为所有的每日构建都应该是有时长限制的，一跑就是两三天不停就不叫每日构建了，用例执行过程中可能存在一些异常情况，导致用例卡住不动，或者执行速度变\n慢，我们使用 --timeout 可以给每条用例设置一个最大的时长，如果超时没有执行完，就是强制停止用例。\n\n\n\n表示每条用例的超时时间为 200 秒，注意单位是秒哦。\n\n这个参数需要安装三方插件：\n\n\n\n\n9、自定义命令行参数#\n\n以上参数都是 Pytest 自带的或者三方插件给我们提供的参数，当这些参数不能满足我们的需求的时候我们就需要自定义一些命令行参数。\n\n首先，我们需要注册命令行参数，前面讲超级共享的时候讲了 conftest.py，但是 conftest.py 能做的事情可不仅仅是写点 fixture，它可是\nPytest 的本地插件，在里面我们可以写 hook（钩子）函数，这里我们介绍其中一个 hook 函数，即实现自定义命令行参数的 hook 函数，其他的\nhook 函数我们后面会介绍到。\n\n官方说法是：注册命令行选项。实际就是自定义命令行参数。\n\n举例：\n\n\n\nparser.addoption() 里面可以传入挺多参数的，但是不是所有的都需要：\n\n\n\n常用的几个参数就这几个，以下是项目实例：\n\n\n\n用于控制日志输出的级别，CI 集成环境下我们不需要输出 DEBUG 级别的日志，我们可以这样用：\n\n\n\n这样在执行用例的时候，参数就可以传递进来，那么传递进来之后，我们在哪里用？\n\n同样是在 conftest.py 里面：\n\n（1）通过 fixture 里面的 request 对象：\n\n\n\n这样可以获取到，request.config.getoption 是固定写法，经常有同学问你咋知道可以这么用呢，在哪里可以看到，实际上可以通过给 request\n打断点，你会看到这个对象内有哪些方法。\n\n（2）通过 hook 函数里面的 seesion 对象：\n\n\n\n这里的 hook 函数不一定是 pytest_sessionstart，好多 hook 函数都可以。\n\n（3）通过 hook 函数里面的 item 对象：\n\n\n\n（4）在用例中使用：\n\n\n\npytestconfig 是 pytest 提供的一个内容 fixture ，可以获取到所有的参数；获取参数值的方法除了\npytestconfig.option.logLevel 这种写法，pytestconfig.getoption(\"logLevel\") 这种写法也是 ok\n的。\n\n仔细观察，获取命令行参数都在 config 这个对象里面，以上举例的不同的 hook 函数默认的参数是不同的。\n\n\n七、参数化#\n\n参数化是自动化测试里面非常重要的一个特性，特别是对于接口自动化测试，那是肯定要用到的。我看到很多网上的教程将参数化称为高级技能，通过这点能看出来，高级也不咋的哈\n。\n\nPytest 的参数化使用方法也很简单，使用装饰器：\n\n\n\n * 装饰器是固定用法 @pytest.mark.parametrize，记住就行了，记不住就记住两个东西，首先是在 mark 里面，然后 p\n   开头，最后用编辑器补全就好了。\n\n * 参数有 3 个：\n   \n   * 第 1 个参数是字符串类型，里面是参数的变量名称，多个变量需要用逗号分隔；\n     \n     这也是最常见的用法，网上教程基本都是这样讲的，但如果你看过 Pytest 源代码这个参数类型是这样定义的： argnames: Union[str,\n     List[str], Tuple[str, ...]] 说明列表和元组也可以，只要里面是字符串就行。\n   \n   * 第 2 个参数是一个列表，准确的讲是一个可迭代对象，一般咱们就用列表好了，如果是多个参数就是 2 维列表，列表中每个元素的个数对应变量的个数。\n     \n     \n     \n     这个参数虽然是可迭代对象，但你最好别使用随机工具生成（每次都是随机数），这可能影响重跑失败用例等一些功能，也最好别使用生成器放里面。\n   \n   * 第 3 个参数是 ids，这个参数是标记 ID\n     的，不传也可以，区别就是不传的话终端输出的用例标题会自动加上参数，可能好多同学没用过，不理解也没关系哈，本身用的不多。\n\n用例的参数化用法就是这么简单。\n\nPytest 其实还支持 fixture 的参数化，这也是 fixture 相对于 Xunit\n写法的其中一点优势，但在实际项目中很少用，没有太多这样的需求，这里就不讲了。\n\n\n八、Hook（钩子）函数#\n\nhook 函数相当于是 Pytest 的一些本地插件，Pytest 给我们提供了许多的 hook 函数，用于处理不同阶段的自定义行为。\n\n有几个注意点：\n\n * hook 函数一般不建议写在非根目录下的 conftest 插件文件里面，我们一般是写在最外层的那个 conftest 里面。\n * hook 函数都是以 pytest_ 开头的函数。\n * 不同的 hook 函数有它自己的功能和所属的阶段。\n\n\n1、hook 函数略览#\n\nPytest 内置了许多的 hook 函数供我们使用，下面我们就按照阶段划分，罗列一下有哪些 hook 函数，可以大致感受一下：\n\n引导钩子：\n\n\n\n初始化钩子：\n\n\n\n收集钩子：\n\n\n\n测试运行（runtest）钩子：\n\n\n\n报告钩子：\n\n\n\n调试钩子：\n\n\n\n这些钩子函数都是 Pytest 给我们提供的，你可以在 conftest 插件文件里面去重写函数来实现你的自定义功能。\n\n看到这么多函数先别慌，咱不需要掌握所有的，因为很多是不常用的，也就是我开篇提到的 99% 的人都用不到的，其中经常使用到的一些比较常用的 hook\n函数，将会在后续内容介绍到。\n\n\n2、常用的 hook 函数#\n\n2.1、pytest_addoption#\n\n这个 hook 函数在前面将自定义命令行参数的时候已经用过了，它的用途就是注册命令行参数，这些值在测试运行开始时会被调用一次。\n\n\n\n前面有例子，这里就不多讲了，用法很简单。\n\n它都是通过 parser.addoption 在定义命令行参数的。\n\n2.2、pytest_configure#\n\n这个函数主要是用来获取命令行参数的：\n\n\n\n是在执行测试执行运行，简单哈。\n\npytest_unconfigure 则是在执行测试退出之前运行。\n\n2.3、pytest_sessionstart#\n\n这个函数在 session 对象创建之后，执行收集之前调用：\n\n\n\nsession 对象里面有很多属性，常用的：\n\n * startdir：用例根目录的绝对路径。\n * items：用例对象的列表。\n * config：config对象。\n\n你也可以往里面动态添加一些属性。\n\n和它对应的 pytest_sessionfinish 是在所有测试结束，退出之前执行。\n\n2.4、pytest_collection_modifyitems#\n\n这个函数主要用来调整用例：\n\n\n\n * session 为 Pytest 的 session 对象。\n\n * config 为 Pytest 的 config 对象。\n\n * items 是一个列表，其他每个元素就是一个用例对象。\n   \n   item 里面有很多属性，常用的：\n   \n   \n\npytest_collection_finish 则是在收集完并且修改完之后运行，它是在 pytest_collection_modifyitems 之后的。\n\n2.5、pytest_runtest_setup#\n\n这个函数是在调用 setup 的时候运行：\n\n\n\n注意是 item，不是 items，item 是用例对象。\n\n比如，你可以在每次用例执行之前输出用例的标题：\n\n\n\npytest_runtest_call 和 pytest_runtest_teardown 分别是在用例执行过程中和用例 teardown\n阶段运行，用法是一样的。\n\n2.6、pytest_runtest_makereport#\n\n这个函数是用于创建测试报告的，每个测试用例的测试报告都分为 setup、call 和 teardown 三个测试阶段。如果你熟悉 allure\n报告的话，应该能轻易 get 到我说的。\n\n\n\n\n九、测试报告#\n\n\n1、allure#\n\nPytest 最常用的测试报告是 allure，它是一个三方插件，安装它：\n\n\n\n使用也很简单，只需要执行时加参数 --alluredir=xxx 即可：\n\n\n\n这样就能在 report 目录下生成报告，打开它你会发现 report 目录下是一堆文本文件，这咋看呢？\n\n还没完~\n\n你还需要安装 allure 的查看工具，你可以直接从 github上去下载最新的版本，然后安装它即可，比如我现在下来安装是这样的：\n\n\n\n查看报告：\n\n * 在线查看：\n\n\n\n * 生成本地 html\n\n\n\n这样在 allure-report 目录下会一堆文件，其中有一个 index.html 是报告的主文件。\n\n使用浏览器直接打开它，你会发现没有数据！\n\n还没完~~\n\n使用命令打开：\n\n\n\n不出意外浏览器会自动打开报告。\n\n需要说明的是，allure 可不是专门为 Pytest\n开发的，经过很长时间的发展，它已经进化为一个报告框架了，能支持非常多的语言及工具生成测试报告，总之这玩意儿老狠了。想深入研究的同学看这里 allure 。\n\n\n2、pytest-html#\n\n上古时期 Pytest 的“糟糠之妻”，尽管该项目是由 Pytest\n官方在维护，但是社区热度不行了，主要是因为颜值不行，很少有人用，也不想过多的介绍它，走个过场吧。\n\n安装：\n\n\n\n使用：\n\n\n\n\n3、xml#\n\n这是个 Pytest 自带的报告，不需要安装插件：\n\n\n\n我个人还是非常喜欢这种报告形式的，因为它不需要安装其他插件，而且处理报告中的数据也非常简单。\n\n\n十、Pytest 框架核心#\n\n我们通常基于 Pytest 来编写搭建我们自己的测试框架，Pytest 自然就成了我们自己测试框架的核心，那么同学们有没有想过，Pytest 的核心是什么？\n\n相信 90% 的同学没去考虑过或者没了解过~\n\nPluggy 就是 Pytest 的核心框架，几乎 Pytest 所有的功能都是基于 Pluggy\n实现的，这是一个被极少人知道且严重低估的框架，它到底是什么玩意儿，咱们这里简单聊一聊。\n\nPluggy 是从 Pytest 框架中被开发者抽取出来的，因为开发者发现他们设计的这种插件化方案，完全可用在其他的项目中，因此他们总结提炼出了 Pluggy\n项目；\n\n令人直呼“厚礼谢”的是整个 Pluggy 项目加起来也就 1100 来行代码（包含注释 ），这就是 Pytest 的核心基石，就像是 Linux 系统中的\nLinux 内核的作用。理解它你才能真正理解 Pytest 插件化设计哲学。\n\n为什么说它被低估了，github 上才不到 900 的 star，真的是深藏功与名！\n\n咱们先随便写个函数：\n\n\n\n通常，类里面的函数咱们想要重写，只需要继承这个类，然后重写覆盖函数就好了，这就是类的多态，不多讲了；\n\n那咱们使用 Pluggy 怎么去覆盖类里面的函数呢？\n\n\n\n\n\n你看，原来的 Mikigo 类里面的函数是没有执行的，而是执行了 Plugin_1 类里面的函数，并且获取到了返回值。\n\n * PluginManager 是整个插件系统的管理器，传递一个工程名称即可进行实例化；\n\n * add_hookspecs 添加一个钩子到管理器中，参数是 module 或 class 对象，底层实际是通过 dir() 自省函数进行遍历添加到一个\n   names 的容器中。\n\n * register 注册插件\n\n如果咱们还想增加一个插件呢?\n\n\n\n\n\nPlugin_2 先执行，然后 Plugin_1 也执行了，两个插件的返回值也都放到一个列表里面了，是不是很神奇。\n\n那如果想 Plugin_1 先执行，Plugin_2 后执行呢？\n\n\n\n\n\n可以通过 tryfirst 和 trylast 来控制，有同学应该有印象， Pytest hook 里面也是用 tryfirst 和 trylast 控制其\nhook 函数执行的先后顺序的，其底层实现是从这里来的。\n\n正是因为可以随意添加插件以及修改插件的执行顺序，才使得在 Pytest 中我们能灵活的定义一些 hook 函数来实现我们想要的功能，Pytest\n以及其三方插件，都是基于此基本逻辑构建起来的。\n\n这里就简单介绍一下基本原理，想要深入了解的同学点这里 Pluggy。","routePath":"/自动化技术/自动化测试框架/Pytest从入门到起飞","lang":"","toc":[{"text":"一、简介","id":"一简介","depth":2,"charIndex":3},{"text":"二、安装","id":"二安装","depth":2,"charIndex":481},{"text":"三、用例编写","id":"三用例编写","depth":2,"charIndex":513},{"text":"1、函数式","id":"1函数式","depth":3,"charIndex":523},{"text":"2、类式","id":"2类式","depth":3,"charIndex":576},{"text":"四、fixture","id":"四fixture","depth":2,"charIndex":758},{"text":"1、级别","id":"1级别","depth":3,"charIndex":964},{"text":"2、不同的写法","id":"2不同的写法","depth":3,"charIndex":1840},{"text":"2.1、XUnit 的写法","id":"21xunit-的写法","depth":4,"charIndex":1868},{"text":"2.2、fixture 写法","id":"22fixture-写法","depth":4,"charIndex":2510},{"text":"3、共享","id":"3共享","depth":3,"charIndex":2969},{"text":"3.1、用例之间共享","id":"31用例之间共享","depth":4,"charIndex":3015},{"text":"3.2、用例类之间共享","id":"32用例类之间共享","depth":4,"charIndex":3443},{"text":"3.3、超级共享","id":"33超级共享","depth":4,"charIndex":3569},{"text":"4、顺序","id":"4顺序","depth":3,"charIndex":3932},{"text":"五、断言","id":"五断言","depth":2,"charIndex":5036},{"text":"1、常规断言","id":"1常规断言","depth":3,"charIndex":5044},{"text":"2、自定义断言","id":"2自定义断言","depth":3,"charIndex":5137},{"text":"六、命令行参数","id":"六命令行参数","depth":2,"charIndex":5428},{"text":"1、-s","id":"1-s","depth":3,"charIndex":5634},{"text":"2、-v","id":"2-v","depth":3,"charIndex":5754},{"text":"3、-k","id":"3-k","depth":3,"charIndex":5804},{"text":"4、-m","id":"4-m","depth":3,"charIndex":6014},{"text":"5、--co","id":"5--co","depth":3,"charIndex":6142},{"text":"6、maxfail","id":"6maxfail","depth":3,"charIndex":6360},{"text":"7、reruns","id":"7reruns","depth":3,"charIndex":6649},{"text":"8、timeout","id":"8timeout","depth":3,"charIndex":6840},{"text":"9、自定义命令行参数","id":"9自定义命令行参数","depth":3,"charIndex":7046},{"text":"七、参数化","id":"七参数化","depth":2,"charIndex":7984},{"text":"八、Hook（钩子）函数","id":"八hook钩子函数","depth":2,"charIndex":8775},{"text":"1、hook 函数略览","id":"1hook-函数略览","depth":3,"charIndex":8995},{"text":"2、常用的 hook 函数","id":"2常用的-hook-函数","depth":3,"charIndex":9293},{"text":"2.1、pytest_addoption","id":"21pytest_addoption","depth":4,"charIndex":9309},{"text":"2.2、pytest_configure","id":"22pytest_configure","depth":4,"charIndex":9456},{"text":"2.3、pytest_sessionstart","id":"23pytest_sessionstart","depth":4,"charIndex":9553},{"text":"2.4、pytest_collection_modifyitems","id":"24pytest_collection_modifyitems","depth":4,"charIndex":9763},{"text":"2.5、pytest_runtest_setup","id":"25pytest_runtest_setup","depth":4,"charIndex":10030},{"text":"2.6、pytest_runtest_makereport","id":"26pytest_runtest_makereport","depth":4,"charIndex":10224},{"text":"九、测试报告","id":"九测试报告","depth":2,"charIndex":10353},{"text":"1、allure","id":"1allure","depth":3,"charIndex":10363},{"text":"2、pytest-html","id":"2pytest-html","depth":3,"charIndex":10838},{"text":"3、xml","id":"3xml","depth":3,"charIndex":10954},{"text":"十、Pytest 框架核心","id":"十pytest-框架核心","depth":2,"charIndex":11040}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""},{"id":120,"title":"unittest—3小时入门版","content":"#\n\n\n简介#\n\nunittest 是 Python 标准库提供的一个测试框架，有点是简单方便，语言能力强的可以对其进行二次开发，使其在单元测试、接口测试领域应用广泛；\n\n由一个或多个自动化测试基础模块、自动化测试管理模块、自动化测试统计模块等组成的工具集合。\n\n\nunittest实例#\n\n\n\n\n重要概念#\n\n\nTest Case#\n\n一个测试用例，就是一个完整的单元，包含了 setUp、run、tearDown；\n\n\nTest Suite#\n\n测试集，用来组装测试用例，通过 addTest 加载的 TestCase 的 Testsuite 中，返回一个 TestSuite 实例；\n\n\nTest Runner#\n\n执行，TestTestRunner 类提供的run()方法来执行；\n\n\nTest Fixture#\n\n环境修复，setUp 和 tearDown；\n\n\n测试用例组织#\n\n获取不同模块下的所有用例；\n\n\nTestSuite#\n\n创建测试集 testSuite：\n\n\n\n添加用例到测试集中：\n\n\n\n执行测试集：\n\n\n\n\ndiscover 方法#\n\n\n\n\n断言#\n\n每个用例当中都需要断言\n\n\n\n\n参数化#\n\n1.安装 ddt（数据驱动测试）：\n\n\n\n2.使用方法\n\n① 单个参数\n\n\n\n备注：@ddt.data(\"admin\",\"a\")，括号里面有几个元素就会跑几遍\n\n② 多个参数\n\n\n\n\nPage Object#\n\n * Page Object是一种自动化测试思想，其理念是将页面的交互细节封装起来，使用例更关注业务而非界面细节，从而提高测试案例的可读性，提高项目的可维护性。\n * 规范项目文件夹： ① driver 驱动文件，用户存放浏览器驱动文件等； ② model 函数文件夹，启动浏览器等； ③ page\n   页面文件夹，所有的基类（定位器、找元素）； ④ testcase 测试用例，用例的基类； ⑤ 存放测试报告，截图等测试结果文件；\n * 一个页面一个类，一个元素一个方法。","routePath":"/自动化技术/自动化测试框架/unittest—3小时入门版","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"unittest实例","id":"unittest实例","depth":2,"charIndex":132},{"text":"重要概念","id":"重要概念","depth":2,"charIndex":148},{"text":"Test Case","id":"test-case","depth":3,"charIndex":156},{"text":"Test Suite","id":"test-suite","depth":3,"charIndex":211},{"text":"Test Runner","id":"test-runner","depth":3,"charIndex":296},{"text":"Test Fixture","id":"test-fixture","depth":3,"charIndex":346},{"text":"测试用例组织","id":"测试用例组织","depth":2,"charIndex":386},{"text":"`TestSuite`","id":"testsuite","depth":3,"charIndex":-1},{"text":"`discover` 方法","id":"discover-方法","depth":3,"charIndex":-1},{"text":"断言","id":"断言","depth":2,"charIndex":485},{"text":"参数化","id":"参数化","depth":2,"charIndex":506},{"text":"Page Object","id":"page-object","depth":2,"charIndex":604}],"domain":"","frontmatter":{"Author":"mikigo"},"version":""}]